----- Archivo: layout.tsx ----- 
// app/layout.tsx
"use client";
import React from "react";
import "./globals.css";
import "@picocss/pico";
import { tooltipStyles } from "@/styles/tooltip";
import { geistMono, geistSans } from "@/styles/geist";
import ClientAppProvider from "@/context/ClientAppProvider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="es" data-theme="light">
      <head>
        <title>Lampo</title>
      </head>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <style>{tooltipStyles}</style>
        <ClientAppProvider>{children}</ClientAppProvider>
      </body>
    </html>
  );
}
 
----- Archivo: page.tsx ----- 
"use client";
import React from "react";
import "@picocss/pico";
import CalendarModule from "./pages/pet/calendar/page";

export default function Home() {
  return (
    <CalendarModule />
  );
}

 
----- Archivo: globals.css ----- 
/**
 * Custom theme
*/
/* Red Light scheme (Default) */
/* Can be forced with data-theme="light" */
[data-theme="light"],
:root:not([data-theme="dark"]) {
  --primary: #e53935;
  --primary-hover: #d32f2f;
  --primary-focus: rgba(229, 57, 53, 0.125);
  --primary-inverse: #FFF;
}

/* Red Dark scheme (Auto) */
/* Automatically enabled if user has Dark mode enabled */
@media only screen and (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --primary: #e53935;
    --primary-hover: #f44336;
    --primary-focus: rgba(229, 57, 53, 0.25);
    --primary-inverse: #FFF;
  }
}

/* Red Dark scheme (Forced) */
/* Enabled if forced with data-theme="dark" */
[data-theme="dark"] {
  --primary: #e53935;
  --primary-hover: #f44336;
  --primary-focus: rgba(229, 57, 53, 0.25);
  --primary-inverse: #FFF;
}

/* Red (Common styles) */
:root {
  --form-element-active-border-color: var(--primary);
  --form-element-focus-color: var(--primary-focus);
  --switch-color: var(--primary-inverse);
  --switch-checked-background-color: var(--primary);
}

.pet-dropdown {
  --pico-box-shadow: 'none' !important;
}

.pet-selection:hover {
  background-color: gray;
}

body {
  -webkit-touch-callout: none;
  /* iOS Safari */
  -webkit-user-select: none;
  /* Safari */
  -khtml-user-select: none;
  /* Konqueror HTML */
  -moz-user-select: none;
  /* Old versions of Firefox */
  -ms-user-select: none;
  /* Internet Explorer/Edge */
  user-select: none;
  /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.modal-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #02659a !important;
}

.modal-description {
  font-size: 0.9rem;
  color: #555;
  margin-bottom: 1.5rem;
}

.text-error {
  color: #d32f2f;
}

main {
  background-color: rgb(249, 250, 251);
} 
----- Archivo: page.module.css ----- 
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  background-color: rgb(249, 250, 251);
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer Image {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    background-color: rgb(249, 250, 251);
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
} 
----- Archivo: index.ts ----- 
import { ApiParams } from "@/types/lib";
import { Strings } from "@/utils/index";

export async function getFetch(url: string, params: ApiParams | undefined = undefined) {
    return await methodFetch("GET", url, params);
}

export async function putFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PUT", url, params, payload);
}

export async function postFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("POST", url, params, payload);
}

export async function patchFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PATCH", url, params, payload);
}

export async function deleteFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("DELETE", url, params, payload);
}

async function methodFetch(method: string, url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    let parameters = "";
    if (params) {
        parameters = Strings.fromParams(params);
    }
    let body = undefined;
    if (payload) {
        body = JSON.stringify(payload);
    }
    return await fetch(`${process.env.PROTOCOL}://${process.env.VERCEL_URL}${url}${parameters}`, {
        method: method,
        headers: method == "GET" ? undefined : { 'Content-Type': 'application/json' },
        body: body
    })
} 
----- Archivo: route.ts ----- 
// src/app/api/auth/reset-password/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { resetPassword } from '@/services/authService';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { z } from 'zod';
import { LogInType } from '@/types/lib';

const ResetSchema = z.object({
    email: z.string().email()
});

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling('POST', req, ResetSchema, async ({ email }: LogInType) => {
        const { data, error } = await resetPassword(email);
        if (error) {
            return NextResponse.json({ success: false, message: error.message }, { status: 400 });
        }
        return NextResponse.json({ success: true, message: 'Correo de recuperación enviado', data });
    });
}
 
----- Archivo: route.ts ----- 
// src/app/api/auth/session/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getSession } from "@/services/authService";
import { withErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
    return withErrorHandling("GET", req, async () => {
        const { data, error } = await getSession();
        if (error) {
            return NextResponse.json({ success: false, message: error.message }, { status: 401 });
        }
        return NextResponse.json({ success: true, session: data.session });
    });
}
 
----- Archivo: route.ts ----- 
// src/app/api/auth/set-session/route.ts
import { NextRequest, NextResponse } from "next/server";
import { withValidationAndErrorHandling } from "@/services/apiService";
import { z } from "zod";
import { SetSesionType } from "@/types/lib";
import { setSession } from "@/services/authService";

const SessionSchema = z.object({
    access_token: z.string(),
    refresh_token: z.string(),
});

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling("POST", req, SessionSchema, async (data: SetSesionType) => {
        const { error } = await setSession(data);
        if (error) {
            return NextResponse.json({ success: false, message: error.message }, { status: 401 });
        }
        return NextResponse.json({ success: true, message: "Sesión establecida" });
    });
} 
----- Archivo: route.ts ----- 
// src/app/api/auth/sign-in/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { setSession, signIn } from '@/services/authService';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { z } from 'zod';
import { LogInType } from '@/types/lib';

const SignInSchema = z.object({
    email: z.string().email(),
    password: z.string().min(6)
});

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling('POST', req, SignInSchema, async ({ email, password }: LogInType) => {
        const { data, error } = await signIn(email, password!);
        if (error) {
            return NextResponse.json({ success: false, message: error.message }, { status: 401 });
        }
        // Persist tokens in HTTP-only cookies:
        await setSession(data.session!);
        return NextResponse.json({ success: true, user: data.session });
    });
} 
----- Archivo: route.ts ----- 
// src/app/api/auth/sign-out/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { signOut } from '@/services/authService';
import { withErrorHandling } from '@/services/apiService';

export async function POST(req: NextRequest) {
    return withErrorHandling('POST', req, async () => {
        await signOut();
        return NextResponse.json({ success: true, message: 'Sesión cerrada correctamente' });
    });
}
 
----- Archivo: route.ts ----- 
// src/app/api/auth/sign-up/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ownerSignUp } from '@/services/authService';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { z } from 'zod';
import { LogInType } from '@/types/lib';

const SignUpSchema = z.object({
    email: z.string().email(),
    password: z.string().min(6),
    role: z.enum(['owner', 'veterinarian']).optional().nullable()
});

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling('POST', req, SignUpSchema, async ({ email, password, role }: LogInType) => {
        const { data, error } = await ownerSignUp(email, password!, role ?? 'owner');
        if (error) {
            return NextResponse.json({ success: false, message: error.message }, { status: 400 });
        }
        return NextResponse.json({ success: true, user: data.user });
    });
}
 
----- Archivo: route.ts ----- 

// src/app/api/feedback/route.ts
import { NextResponse } from 'next/server';
import { sendEmail } from '@/services/emailService';

export const runtime = 'nodejs';

export async function POST(req: Request) {
  try {
    const { feedback, anonymous, userEmail } = await req.json();
    if (!feedback || typeof feedback !== 'string') {
      return NextResponse.json({ error: 'Falta el texto del feedback' }, { status: 400 });
    }

    const subjectBase = process.env.MAILTRAP_SUBJECT || 'Feedback de Lampo';
    const subject = anonymous
      ? `${subjectBase} (Anonymous)`
      : `${subjectBase} (From ${userEmail})`;

    // Llamada al servicio de email
    await sendEmail({ subject, text: feedback });

    return NextResponse.json({ ok: true }, { status: 200 });
  } catch (err) {
    console.error('Error interno en /api/feedback:', err);
    const message = err instanceof Error ? err.message : 'Error interno del servidor';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
 
----- Archivo: route.ts ----- 
// app/api/owners/route.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { OwnerRepository } from '@/repos/index';
import type { OwnerDataType } from '@/types/index';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { OwnerDataTypeSchema } from '@/schemas/validationSchemas';
import { RepositoryError } from '@/types/lib';

// PUT /api/owner : crea o actualiza datos del dueño
export async function PUT(request: NextRequest) {
    try {
        const payload: OwnerDataType = await request.json();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const ownerId = (payload as any).owner_id;
        if (!ownerId) {
            return NextResponse.json({ error: 'El campo owner_id es requerido' }, { status: 400 });
        }

        const existing = await OwnerRepository.findById(ownerId);
        if (existing) {
            await OwnerRepository.update(payload);
        } else {
            await OwnerRepository.create(payload);
        }

        const saved = await OwnerRepository.findById(ownerId);
        return NextResponse.json({ owner: saved });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
        console.error('Error upserting owner:', error);
        return NextResponse.json({ error: error.message || 'Error interno del servidor' }, { status: 500 });
    }
}



export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        OwnerDataTypeSchema,
        async (ownerData: OwnerDataType) => {
            try {
                const { data, error } = await OwnerRepository.create(ownerData);
                if (error) {
                    throw new RepositoryError(`Error creating record: ${JSON.stringify(ownerData)}`);
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error creating record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { PetRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            try {
                const data = await PetRepository.findByOwnerId(id);
                return NextResponse.json(data);
            }
            catch {
                throw new RepositoryError("Error getting pets");
            }
        });
}
 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { OwnerRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError(`Falta parámetro OwnerId`);
            }

            const ownerData = await OwnerRepository.findById(id);
            if (!ownerData) {
                throw new RepositoryError(`Owner no encontrado: ${id}`);
            }
            return NextResponse.json(ownerData);
        }
    );
}
 
----- Archivo: route.ts ----- 
// app/api/pets/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getRequiredQueryParam, withValidationAndErrorHandling, getWithErrorHandling } from '@/services/apiService'
import PetRepository from '@/repos/pet.repository'
import { z } from 'zod'
import { PetType } from '@/types/index'

const petSchema = z.object({
    id: z.string().optional(),
    name: z.string(),
    image: z.string().optional(),
    owner_id: z.string(),
})

export async function GET(req: NextRequest) {
    return getWithErrorHandling(
        req,
        async () => {
            // ahora delegamos la validación del ownerId
            const ownerId = getRequiredQueryParam(req, 'ownerId')
            const pets = await PetRepository.findByOwnerId(ownerId)
            return NextResponse.json(pets, { status: 200 })
        });
}

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        petSchema,
        async (pet) => {
            const { data, error } = await PetRepository.upsert(pet as PetType)
            if (error) {
                return NextResponse.json(
                    { success: false, message: error.message },
                    { status: 500 }
                )
            }
            return NextResponse.json(data, { status: 201 })
        }
    )
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { BasicDataRepository } from '@/repos/index'
import { getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { BasicDataTypeSchema } from '@/schemas/validationSchemas';
import { BasicDataType } from '@/types/index';
import { RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ petId: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { petId } = await params;
            const data = await BasicDataRepository.findByPetId(petId);
            return NextResponse.json(data);
        });
}

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        BasicDataTypeSchema,
        async (basicData) => {
            try {
                const { data, error } = await BasicDataRepository.upsert(basicData as BasicDataType);
                if (error) {
                    return NextResponse.json(
                        { success: false, message: `Error upserting record: ${error.message}` },
                        { status: 500 }
                    )
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error upserting record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/pets/exists/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const id = getRequiredQueryParam(req, "id");

    const exists = await PetRepository.existsById(id);
    return NextResponse.json({ success: true, exists });
  });
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getWithErrorHandling, withErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { Empty } from '@/data/index';
import { RepositoryError, StepsStateType, StepStateError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            const step = getStep(req);
            if (step.repository) {
                try {
                    const data = await step.repository.findByParentId(id);
                    return NextResponse.json(data);
                }
                catch {
                    throw new RepositoryError("Error getting records");
                }
            }
            throw new StepStateError("Missing repository");
        });
}

export async function POST(req: NextRequest) {
    const step = getStep(req);
    return withValidationAndErrorHandling(
        'POST',
        req,
        step.schema,
        async (list) => {
            if (step.repository) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const { data, error } = await step.repository.createAll(list as any[])
                    if (error) {
                        throw new RepositoryError(error.message);
                    }
                    return NextResponse.json(data, { status: 201 });
                }
                catch {
                    throw new RepositoryError("Error upserting records");
                }
            }
            throw new StepStateError("Missing repository");
        }
    );
}

export async function DELETE(req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }) {
    const step = getStep(req);
    return withErrorHandling(
        'DELETE',
        req,
        async () => {
            const { id } = await params;
            if (step.repository) {
                const response = await step.repository.delete(id);
                if (!response) {
                    throw new RepositoryError("Error deleting record");
                }
                return NextResponse.json({ success: true, message: "Se eliminó correctamente el registro" }, { status: 200 });
            }
            throw new StepStateError("Missing repository");
        }
    )
}

function getStep(req: NextRequest): StepsStateType {
    const filter = Empty.Steps().filter(s => req.url.includes(s.url || "") && s.repository);
    if (filter.length == 0) {
        throw new StepStateError("Missing step");
    }
    else if (filter.length > 1) {
        throw new StepStateError("Too many steps");
    }
    else {
        return filter[0];
    }
} 
----- Archivo: route.tsx ----- 
// app/api/pets/me/code/route.ts
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";

export async function POST(req: Request) {
  try {
    const { owner_id, pet_id } = await req.json();

    // 1) Mascota del owner
    const pet = await PetRepository.findByOwnerIdAndPetId(owner_id, pet_id);
    if (!pet) {
      return NextResponse.json(
        { error: "Mascota no encontrada" },
        { status: 404 }
      );
    }

    // 2) Invalida códigos anteriores
    await PetCodeRepository.invalidateAll(pet_id);

    // 3) Crea nuevo código
    const ttl = parseInt(process.env.CODE_EXPIRE_AT!);
    const code = await PetCodeRepository.create(pet_id, ttl);

    return NextResponse.json({ code });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    const msg = err.message.includes("No autorizado")
      ? { error: "No autorizado" }
      : { error: err.message || "Error interno" };
    const status = msg.error === "No autorizado" ? 401 : 500;
    return NextResponse.json(msg, { status });
  }
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.ts (resumiendo lo anterior)
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { PetRepository } from "@/repos/index";
import { getWithErrorHandling, withValidationAndErrorHandling } from "@/services/apiService";
import { PetType } from "@/types/index";
import { RepositoryError } from "@/types/lib";

const updatePetSchema = z.object({
  name: z.string().optional(),
  image: z.string().url().optional(),
});

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  return getWithErrorHandling(
    req,
    async () => {
      const { id } = await params;
      const pets = await PetRepository.findById(id)
      return NextResponse.json(pets, { status: 200 })
    });
}

export async function PATCH(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  return withValidationAndErrorHandling(
    "PATCH",
    req,
    updatePetSchema,
    async (updates) => {
      const { id } = await params;
      const updated = await PetRepository.updateById(id, updates as Partial<PetType>);
      if (!updated) {
        return NextResponse.json(
          { success: false, message: "Mascota no encontrada" },
          { status: 404 }
        );
      }
      return NextResponse.json(
        { success: true, message: "Actualizado correctamente" },
        { status: 200 }
      );
    }
  );
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  return getWithErrorHandling(req, async () => {
    const { id } = await params;
    const deleted = await PetRepository.deleteById(id);
    if (!deleted) {
      throw new RepositoryError("Mascota no encontrada");
    }
    return NextResponse.json(
      { success: true, message: "Eliminado correctamente" },
      { status: 200 }
    );
  });
} 
----- Archivo: route.ts ----- 
import { NextRequest, NextResponse } from "next/server";
import { PlanRepository } from "@/repos/index";
import { getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const plans = await PlanRepository.getAllCurrent();
    return NextResponse.json({ success: true, plans });
  });
}
 
----- Archivo: route.ts ----- 
import { NextRequest, NextResponse } from "next/server";
import { SubscriptionRepository } from "@/repos/index";
import { withValidationAndErrorHandling } from "@/services/apiService";
import { z } from "zod";
import { CreateSubscriptionType } from "@/types/index";

const SubscriptionSchema = z.object({
  ownerId: z.string(),
  planVersionId: z.string(),
  cycle: z.enum(["monthly", "annual"]),
  priceAtPurchase: z.number(),
  discountApplied: z.number()
});

export async function POST(req: NextRequest) {
  return withValidationAndErrorHandling("POST", req, SubscriptionSchema, async (data: CreateSubscriptionType) => {
    const result = await SubscriptionRepository.create(data);
    return NextResponse.json({ success: true, subscription: result });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/veterinarians/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import type { VeterinarianType } from '@/types/index';
import { VeterinarianTypeSchema } from '@/schemas/validationSchemas';
import VeterinarianRepository from '@/repos/veterinarian.repository';

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        VeterinarianTypeSchema,
        async (vetData: VeterinarianType) => {
            try {
                const { data, error } = await VeterinarianRepository.create(vetData);
                if (error) {
                    console.log(error);
                    throw new RepositoryError(
                        `Error creating veterinarian: ${JSON.stringify(vetData)}`
                    );
                }
                return NextResponse.json(data, { status: 201 });
            } catch(err) {
                console.log(err);
                throw new RepositoryError('Error creating veterinarian');
            }
        }
    );
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.tsx
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";

interface UpdateBody {
    code: string;
    name?: string;
    image?: string;
}
export async function PUT(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { code, ...updates } = (await req.json()) as UpdateBody;
    if (!code) {
      return NextResponse.json({ error: "Código requerido." }, { status: 400 });
    }

    // 1) Validar código
    const codeData = await PetCodeRepository.find(code);
    if (!codeData) {
      return NextResponse.json({ error: "Código inválido." }, { status: 401 });
    }
    if (new Date(codeData.expires_at) < new Date()) {
      return NextResponse.json(
        { error: "Código expirado." },
        { status: 410 }
      );
    }
    if (codeData.pet_id !== id) {
      return NextResponse.json(
        { error: "Código no corresponde a esta mascota." },
        { status: 403 }
      );
    }

    // 2) Actualizar pet
    await PetRepository.updateById(id, updates);
    return NextResponse.json({ success: true });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
} 
----- Archivo: route.tsx ----- 
// app/api/vet/use-code/route.ts
import { NextResponse } from "next/server";
import { PetCodeRepository, VeterinaryAccessRepository } from "@/repos/index";

export async function POST(req: Request) {
  try {
    const {
      code,
      firstName,
      lastName,
      registration,
      clinicName,
      city,
    } = await req.json();

    // 1) Obtener y validar código
    const data = await PetCodeRepository.find(code);
    if (!data) {
      return NextResponse.json({ error: "Código inválido" }, { status: 404 });
    }
    const now = new Date().toISOString();
    if (data.used) {
      return NextResponse.json({ error: "Código ya utilizado" }, { status: 410 });
    }
    if (data.expires_at < now) {
      return NextResponse.json({ error: "Código expirado" }, { status: 410 });
    }

    // 2) Marcar como usado
    await PetCodeRepository.markUsed(code);

    // 3) Registrar acceso veterinario
    const vetAccess = await VeterinaryAccessRepository.create({
      pet_id: data.pet_id,
      pet_code_id: data.id,
      vet_first_name: firstName,
      vet_last_name: lastName,
      professional_registration: registration,
      clinic_name: clinicName,
      city,
    });

    // 4) Devolver petId
    return NextResponse.json({ success: true, pet_id: data.pet_id, pet_code: data.id, vet_access: vetAccess.id });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
}
 
----- Archivo: route.ts ----- 
// src/app/api/vet-access/validate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetCodeRepository, PetRepository, VeterinaryAccessRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const code = getRequiredQueryParam(req, "code");

    // 1. Validar código
    const codeRecord = await PetCodeRepository.find(code);
    if (!codeRecord) {
      return NextResponse.json({ success: false, message: "Código inválido." }, { status: 404 });
    }

    // 2. Validar expiración
    if (new Date(codeRecord.expires_at) < new Date()) {
      return NextResponse.json({ success: false, message: "Código expirado." }, { status: 403 });
    }

    // 3. Buscar mascota
    const pet = await PetRepository.findById(codeRecord.pet_id);
    if (!pet) {
      return NextResponse.json({ success: false, message: "Mascota no encontrada." }, { status: 404 });
    }

    // 4. Buscar acceso del veterinario (si existe)
    const vetAccess = await VeterinaryAccessRepository.findByCodeAndByPetId(code, pet.id);

    return NextResponse.json({
      success: true,
      pet,
      codeRecord,
      vetAccess
    });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/veterinarians/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import VeterinarianRepository from '@/repos/veterinarian.repository';
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError('Falta parámetro VeterinarianId');
            }

            const vetData = await VeterinarianRepository.findById(id);
            if (!vetData) {
                throw new RepositoryError(`Veterinario no encontrado: ${id}`);
            }
            return NextResponse.json(vetData);
        }
    );
}
 
----- Archivo: layout.tsx ----- 
// app/login/layout.tsx
export default function LoginLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/login/page.tsx
"use client";
import React, { FormEvent, useState } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import Image from "next/image";

import type { OwnerDataType } from "@/types/index";
import { FaEye, FaEyeSlash } from "react-icons/fa";
import { postFetch } from "@/app/api";
import { setSession } from "@/services/authService";
import ModalComponent from "@/components/lib/modal";

export default function LoginPage() {
  const router = useRouter();

  // Estados comunes
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isRegistering, setIsRegistering] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  // Estados adicionales para registro
  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "",
    country: "",
    email: ""
  });

  const handleAuth = async (e: FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    if (isRegistering) {
      // 1) Registro vía API
      const signUpResponse = await postFetch("/api/auth/sign-up", undefined, { email, password });
      const signUpJson = await signUpResponse.json();

      if (!signUpResponse.ok || !signUpJson.success) {
        console.error("Signup error:", signUpJson);
        setError("Ocurrió un error al registrar el usuario.");
        setLoading(false);
        return;
      }

      const ownerId = signUpJson.user?.id;

      // 2) Guardar datos del owner
      if (ownerId) {
        const response = await postFetch('/api/owners', undefined, {
          ...(ownerInfo as OwnerDataType),
          owner_id: ownerId,
          email
        });
        if (!response.ok) {
          setError("Error creando al dueño de la mascota");
          setLoading(false);
          return;
        }
      }

      setShowConfirmModal(true);
    } else {
      // Inicio de sesión
      const loginResponse = await postFetch("/api/auth/sign-in", undefined, { email, password });
      const loginJson = await loginResponse.json();

      if (!loginResponse.ok || !loginJson.success) {
        setError(loginJson?.message || "Error iniciando sesión");
      } else {
        setSession({ access_token: loginJson.user.access_token, refresh_token: loginJson.user.refresh_token });
        router.refresh();
        router.push("/");
      }
    }

    setLoading(false);
  };

  const handleReset = async () => {
    setError("");
    if (!email) {
      setError("Ingresa tu correo para restablecer la contraseña.");
      return;
    }

    const resetResponse = await postFetch("/api/auth/reset-password", undefined, { email });
    const resetJson = await resetResponse.json();

    if (!resetResponse.ok || !resetJson.success) {
      setError(resetJson?.message || "Error al enviar correo de recuperación.");
    } else {
      setError("Revisa tu correo para restablecer la contraseña.");
    }
  };

  const goToVetPage = () => {
    router.replace("/vet-access");
  }

  const goToRegister = () => {
    router.replace("/pages/owner/register");
  }

  // 4) Mostrar modal de “verifica tu correo”
  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal}
      >
        <button
          className="contrast"
          onClick={goToRegister}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          Ya confirmé, continuar
        </button>
      </ModalComponent>
    );
  }

  return (
    <main
      style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        background: "#F9FAFB",
      }}
    >
      <form
        onSubmit={handleAuth}
        style={{
          background: "#fff",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
          width: "100%",
          maxWidth: "550px",
        }}
      >
        <div style={{ textAlign: "center", marginBottom: "1.5rem" }}>
          <Image loading={"lazy"} src="/logo.png" alt="Lampo" width="150" height="48" style={{ width: "auto", height: "auto", marginBottom: '10px' }} />
          <h1>{isRegistering ? "Regístrate" : "Inicia sesión"}</h1>
        </div>

        {/* Campos comunes */}
        <label htmlFor="email">
          Email
          <input
            id="email"
            type="email"
            autoComplete="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </label>

        {/* Campos extra sólo en registro */}
        {isRegistering && (
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
            <label htmlFor="name">
              Nombre
              <input
                id="name"
                type="text"
                autoComplete="given-name"
                value={ownerInfo.name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="lastname">
              Apellido
              <input
                id="lastname"
                type="text"
                autoComplete="family-name"
                value={ownerInfo.last_name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="phone">
              Teléfono
              <input
                id="phone"
                type="tel"
                autoComplete="phone"
                value={ownerInfo.phone || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, phone: e.target.value })}
                required
              />
            </label>

            <label htmlFor="address">
              Dirección
              <input
                id="address"
                type="text"
                autoComplete="address-line1"
                value={ownerInfo.address || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })}
                required
              />
            </label>

            <label htmlFor="city">
              Ciudad
              <input
                id="city"
                type="text"
                autoComplete="address-level2"
                value={ownerInfo.city || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })}
                required
              />
            </label>

            <label htmlFor="country">
              País
              <input
                id="country"
                type="text"
                autoComplete="country-name"
                value={ownerInfo.country || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, country: e.target.value })}
                required
              />
            </label>

          </div>
        )}

        <label htmlFor="password" style={{ position: 'relative' }}>
          Contraseña
          <input
            id="password"
            type={showPassword ? "text" : "password"}
            autoComplete={isRegistering ? 'new-password' : 'current-password'}
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            style={{ paddingRight: '2.5rem' }} // espacio para el botón
          />
          <button
            type="button"
            onClick={() => setShowPassword(!showPassword)}
            aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
            style={{
              position: 'absolute',
              right: '0.75rem',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'none',
              border: 'none',
              padding: 0,
              cursor: 'pointer',
            }}
          >
            {showPassword ? <FaEyeSlash size={23} color={'#000'} style={{ marginTop: '16px' }} /> : <FaEye size={23} color={'#000'} style={{ marginTop: '16px' }} />}
          </button>
        </label>

        {error && <p style={{ color: "red", marginTop: "0.5rem" }}>{error}</p>}

        <button
          type="submit"
          disabled={loading}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          {loading
            ? isRegistering
              ? "Guardando..."
              : "Accediendo..."
            : isRegistering
              ? "Registrarse"
              : "Entrar"}
        </button>

        {!isRegistering && (
          <p style={{ textAlign: "right", marginTop: "0.5rem" }}>
            <button
              type="button"
              onClick={handleReset}
              className="contrast"
              style={{
                background: "none",
                border: "none",
                padding: 0,
                cursor: "pointer",
                color: "rgb(55, 60, 68)",
              }}
            >
              ¿Olvidaste tu contraseña?
            </button>
          </p>
        )}

        <p style={{ textAlign: "center", marginTop: "1rem" }}>
          {isRegistering ? "¿Ya tienes cuenta?" : "¿No tienes cuenta?"}
          <button
            type="button"
            onClick={() => setIsRegistering(!isRegistering)}
            style={{
              background: "none",
              border: "none",
              color: "#3B82F6",
              cursor: "pointer",
              marginLeft: "0.25rem",
            }}
          >
            {isRegistering ? "Inicia sesión" : "Regístrate"}
          </button>
        </p>
        {!isRegistering &&
          <p style={{ textAlign: "center", marginTop: "1rem" }}>

            <button
              type="button"
              onClick={() => goToVetPage()}
              style={{
                background: "none",
                border: "none",
                color: "#3B82F6",
                cursor: "pointer",
                marginLeft: "0.25rem",
              }}
            >
              Soy médico veterinario sin registro
            </button>
          </p>
        }
      </form>
    </main>
  );
} 
----- Archivo: index.ts ----- 
// app/pages/index.tsx
export { default as BasicDataPage } from "./pet/basic-data/page";
export { default as CalendarPage } from "./pet/calendar/page";
export { default as ConditionsPage } from "./pet/conditions/page";
export { default as LabTestsPage } from "./pet/lab-tests/page";
export { default as LoginPage } from "../login/page";
export { default as MedicinesPage } from "./pet/medicines/page";
export { default as SettingsPage } from "./owner/settings/page";
export { default as UpgradePage } from "./owner/upgrade/page";
export { default as VaccinesPage } from "./pet/vaccines/page";
export { default as VetPage } from "./vet/[code]/page";
export { default as OwnerSettings } from "./owner/settings/page"; 
----- Archivo: layout.tsx ----- 
// app/pages/auth/verify/layout.tsx
export default function AuthVerifyLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body className="p-4">
        {children}
      </body>
    </html>
  );
} 
----- Archivo: page.tsx ----- 
// app/pages/auth/verify/page.tsx
"use client";
import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { getFetch, postFetch } from "@/app/api";

export default function VerifyEmail() {
  const router = useRouter();

  useEffect(() => {
    const url = new URL(window.location.href);
    const access_token = url.searchParams.get("access_token");
    const refresh_token = url.searchParams.get("refresh_token");
    const type = url.searchParams.get("type");

    const trySetSession = async () => {
      try {
        const response = await postFetch("/api/auth/set-session", undefined, { access_token, refresh_token });
        const result = await response.json();

        if (!response.ok || !result.success) {
          console.error("Error al establecer sesión:", result.message);
          router.replace("/login");
          return;
        }

        router.replace("/owners/register");
      } catch (err) {
        console.error("Error de red al establecer sesión:", err);
        router.replace("/login");
      }
    };

    const checkSession = async () => {
      try {
        const response = await getFetch("/api/auth/session");
        const result = await response.json();

        if (response.ok && result.success && result.session) {
          router.replace("/owners/register");
        } else {
          router.replace("/login");
        }
      } catch (err) {
        console.error("Error al verificar sesión:", err);
        router.replace("/login");
      }
    };

    if (access_token && refresh_token && type === "signup") {
      trySetSession();
    } else {
      checkSession();
    }
  }, [router]);

  return (
    <div style={{ padding: "2rem", textAlign: "center", maxWidth: '500px' }}>
      <h1>Verificando tu correo…</h1>
      <p>Por favor espera un momento.</p>
    </div>
  );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/register/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { FaCheck } from "react-icons/fa";
import { PlanVersionType } from "@/types/index";
import { useRouter } from "next/navigation";
import { useSession } from "@/hooks/useSession";
import { getFetch, postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";

export default function RegisterPage() {
    useSession();
    const router = useRouter();
    const [plans, setPlans] = useState<PlanVersionType[]>([]);
    const [cycles, setCycles] = useState<Record<string, "monthly" | "annual">>(
        {}
    );
    const [loading, setLoading] = useState<boolean>(false);
    const session = useSessionContext();

    useEffect(() => {
        async function load() {
            try {
                const response = await getFetch("/api/plans/current");
                const json = await response.json();
                if (json.success) {
                    const data = json.plans;
                    setPlans(data);

                    const initialCycles: Record<string, "monthly" | "annual"> = {};
                    data.forEach((p: PlanVersionType) => {
                        initialCycles[p.id.toString()] = "monthly";
                    });
                    setCycles(initialCycles);
                } else {
                    console.error("Error obteniendo planes:", json.message);
                }
            } catch (err) {
                console.error("Error en petición de planes:", err);
            }
        }
        load();
    }, []);

    // Validar sesión
    if (!session?.db?.user?.id) {
        console.error("No hay sesión activa o falta el user.id");
        return null;
    }

    const ownerId = session?.db?.user?.id;

    const handleCycle = (planId: string, cycle: "monthly" | "annual") => {
        setCycles((prev) => ({ ...prev, [planId]: cycle }));
    };

    const formatPrice = (cents: number) =>
        new Intl.NumberFormat("es-CO", {
            style: "currency",
            currency: "USD",
            minimumFractionDigits: 2,
        }).format(cents / 100);

    const handleSelect = async (plan: PlanVersionType) => {
        setLoading(true);
        try {
            const cycle = cycles[plan.id.toString()];
            const priceAtPurchase = cycle === "annual" ? plan.price_year : plan.price_month;
            const discountApplied = cycle === "annual" ? plan.discount_year : plan.discount_month;

            const response = await postFetch("/api/plans/subscriptions", undefined, {
                ownerId,
                planVersionId: plan.id,
                cycle,
                priceAtPurchase,
                discountApplied
            });
            const json = await response.json();

            if (!response.ok || !json.success) {
                throw new Error(json.message || "Error al crear suscripción");
            }

            router.replace("/pages/pet/register");
        } catch (e) {
            console.error("Error creando suscripción:", e);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main style={{ padding: "2rem", background: "#F9FAFB" }}>
            <div
                style={{
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(260px, 1fr))",
                    gap: "1.5rem",
                }}
            >
                {plans.map((plan) => {
                    const key = plan.id.toString();
                    const cycle = cycles[key] || "monthly";
                    const isStandard = plan.slug === "standard";
                    const borderColor = "#3B82F6";
                    const darkBg = isStandard;
                    const cardStyle: React.CSSProperties = darkBg
                        ? { background: "#0B1446", color: "#fff", borderRadius: "8px" }
                        : { border: `2px solid ${borderColor}`, background: "#fff", borderRadius: "8px" };

                    const discountMonthlyLabel =
                        plan.discount_month > 0 ? `${plan.discount_month}% Descuento` : undefined;
                    const discountYearLabel =
                        plan.discount_year > 0 ? `${plan.discount_year}% Descuento` : undefined;

                    return (
                        <article
                            key={plan.id}
                            style={{ ...cardStyle, padding: "2rem", position: "relative" }}
                        >
                            {plan.slug === "standard" && (
                                <span
                                    style={{
                                        position: "absolute",
                                        top: "1rem",
                                        left: "1rem",
                                        background: borderColor,
                                        color: "#fff",
                                        fontSize: "0.75rem",
                                        padding: "0.25rem 0.75rem",
                                        borderRadius: "4px",
                                        textTransform: "uppercase",
                                    }}
                                >
                                    Popular
                                </span>
                            )}
                            {(plan.slug === "standard" || plan.slug === "advanced") && (
                                <div
                                    style={{
                                        display: "flex",
                                        border: darkBg ? "none" : `1px solid ${borderColor}`,
                                        borderRadius: "4px",
                                        overflow: "hidden",
                                        marginBottom: "1rem",
                                        background: darkBg ? "rgba(255,255,255,0.1)" : undefined,
                                    }}
                                >
                                    <button
                                        onClick={() => handleCycle(key, "monthly")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "monthly" ? "#fff" : "transparent",
                                            color: darkBg ? "#fff" : "#111",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                        }}
                                    >
                                        Mensual
                                        {cycle === "monthly" && discountMonthlyLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "#FBBF24",
                                                    color: "#111827",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {discountMonthlyLabel}
                                            </span>
                                        )}
                                    </button>
                                    <button
                                        onClick={() => handleCycle(key, "annual")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "annual" ? "#fff" : "transparent",
                                            color: darkBg ? "#fff" : "#111",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                            position: "relative",
                                        }}
                                    >
                                        Anual
                                        {cycle === "annual" && discountYearLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "#FBBF24",
                                                    color: "#111827",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {discountYearLabel}
                                            </span>
                                        )}
                                    </button>
                                </div>
                            )}

                            <h3 style={{ marginTop: isStandard ? "2rem" : 0, marginBottom: "0.5rem" }}>
                                {plan.title}
                            </h3>
                            <p
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1rem",
                                    opacity: darkBg ? 0.75 : 1,
                                }}
                            >
                                {plan.description}
                            </p>

                            <div style={{ fontSize: "2rem", fontWeight: 700, marginBottom: "0.25rem" }}>
                                {cycle === "annual"
                                    ? formatPrice(plan.price_year)
                                    : formatPrice(plan.price_month)}
                            </div>
                            <div
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1.5rem",
                                    opacity: 0.75,
                                }}
                            >
                                {cycle === "annual"
                                    ? "Por usuario, por año"
                                    : "Por usuario, por mes"}
                            </div>

                            <ul style={{ listStyle: "none", padding: 0, marginBottom: "1.5rem" }}>
                                {plan.features.map((feat, idx) => (
                                    <li
                                        key={idx}
                                        style={{ display: "flex", alignItems: "center", marginBottom: "0.5rem" }}
                                    >
                                        <FaCheck
                                            style={{
                                                marginRight: "0.5rem",
                                                color: darkBg ? "#FBBF24" : borderColor,
                                            }}
                                        />
                                        <span style={{ fontSize: "0.875rem" }}>{feat.text}</span>
                                        {feat.badge && (
                                            <span
                                                style={{
                                                    marginLeft: "0.5rem",
                                                    background: "#10B981",
                                                    color: "#fff",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {feat.badge}
                                            </span>
                                        )}
                                    </li>
                                ))}
                            </ul>

                            <button
                                onClick={() => handleSelect(plan)}
                                className="contrast"
                                style={{
                                    width: "100%",
                                    padding: "0.75rem",
                                    fontWeight: 600,
                                    fontSize: "1rem",
                                    opacity: loading ? 0.6 : 1,
                                    cursor: loading ? "not-allowed" : "pointer",
                                }}
                                disabled={loading}
                            >
                                {plan.slug === "free" ? "Selecciona este plan GRATIS" : "Continuar al pago"}
                            </button>
                        </article>
                    );
                })}
            </div>
        </main>
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/settings/page.tsx

"use client";
import { Title } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch, putFetch } from "@/app/api";
import type { OwnerDataType, PetType } from "@/types/index";
import React, { FormEvent, useEffect, useState } from "react";
import { FaCog, FaExclamationTriangle } from "react-icons/fa";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { Empty } from "@/data/index";
import { useRouter } from "next/navigation";

export default function SettingsPage() {
  const { isMobile } = useDeviceDetect();
  const router = useRouter();
  const session = useSessionContext();
  const storage = useStorageContext();
  const userId = session?.db?.user.id;
  const userEmail = session?.db?.user.email;

  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "",
    country: "",
    email: ""
  });

  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [confirmText, setConfirmText] = useState("");
  // asumo que en tu contexto tienes la mascota seleccionada:
  const pet: PetType | null = storage.storedPet;

  const [loadLoading, setLoadLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  useEffect(() => {
    if (!session || !userId) return;

    const fetchData = async () => {
      try {
        if (!storage.storedOwnerData.owner_id) {
          const res = await getFetch(`/api/owners/${encodeURIComponent(userId)}`);
          const json = await res.json();
          if (res.ok) {
            storage.setStoredOwnerData(json);
            setOwnerInfo(json);
          } else {
            console.error("Error al obtener owner:", json.error);
            setError("No se pudo cargar la información del dueño.");
            setFormFailed(true);
          }
        }
        else {
          setOwnerInfo(storage.storedOwnerData);
        }
      } catch (err) {
        console.error("Fetch owner error:", err);
        setError("Error de red al cargar datos.");
        setFormFailed(true);
      }
      finally {
        setLoadLoading(false);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [userId, session]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!userId) {
      setError("Usuario no identificado.");
      setFormFailed(true);
      return;
    }

    try {
      if (userEmail) {
        const payload: OwnerDataType = {
          owner_id: userId,
          name: ownerInfo.name || "",
          last_name: ownerInfo.last_name || "",
          phone: ownerInfo.phone || "",
          address: ownerInfo.address || "",
          city: ownerInfo.city || "",
          country: ownerInfo.country || "",
          email: userEmail
        };

        const res = await putFetch('/api/owners', undefined, payload);
        const json = await res.json();

        if (res.ok) {
          setError("Datos actualizados correctamente.");
          storage.setStoredOwnerData(payload);
          setFormFailed(false);
        } else {
          console.error("API error:", json.error);
          setError(json.error || "Error al guardar los cambios.");
          setFormFailed(true);
        }
      }
    } catch (err) {
      console.error("Submit error:", err);
      setError("Error de red al guardar cambios.");
      setFormFailed(true);
    }
  };

  const handleDelete = async () => {
    if (!pet) return;
    const res = await fetch(`/api/pets/${encodeURIComponent(pet.id)}`, {
      method: "DELETE",
    });
    if (res.ok) {
      // actualizar lista en el contexto
      storage.setStoredOwnerPets(
        storage.storedOwnerPets.filter((p) => p.id !== pet.id)
      );
      storage.setStoredPet(Empty.Pet());
      router.replace("/");
    } else {
      console.error("Error al eliminar mascota");
    }
  };

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      <section style={{ marginBottom: "2rem" }}>
        <Title icon={<FaCog />} title="Configuración del dueño" />
        <form
          onSubmit={handleSubmit}
          style={{ display: "grid", gap: "1rem" }}
        >
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
            <label htmlFor="name">
              Nombre
              <input
                id="name"
                type="text"
                autoComplete="given-name"
                disabled={loadLoading}
                value={ownerInfo.name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="lastname">
              Apellido
              <input
                id="lastname"
                type="text"
                autoComplete="family-name"
                disabled={loadLoading}
                value={ownerInfo.last_name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="phone">
              Teléfono
              <input
                id="phone"
                type="tel"
                autoComplete="tel"
                disabled={loadLoading}
                value={ownerInfo.phone || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, phone: e.target.value })}
                required
              />
            </label>

            <label htmlFor="address">
              Dirección
              <input
                id="address"
                type="text"
                disabled={loadLoading}
                autoComplete="address-line1"
                value={ownerInfo.address || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })}
                required
              />
            </label>

            <label htmlFor="city">
              Ciudad
              <input
                id="city"
                type="text"
                disabled={loadLoading}
                autoComplete="address-level2"
                value={ownerInfo.city || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })}
                required
              />
            </label>

            <label htmlFor="country">
              País
              <input
                id="country"
                type="text"
                disabled={loadLoading}
                autoComplete="country-name"
                value={ownerInfo.country || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, country: e.target.value })}
                required
              />
            </label>
          </div>

          <button type="submit">
            Guardar cambios
          </button>

          {error && (
            <p style={{ color: formFailed ? "red" : "green" }}>{error}</p>
          )}
        </form>
      </section>


      {/* ——— Sección Danger Zone para eliminar mascota ——— */}
      {pet && (
        <section
          style={{
            marginTop: "3rem",
            padding: "1rem",
            border: "1px solid #d73a49",
            borderRadius: "6px",
          }}
        >
          <h3
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              color: "#d73a49",
            }}
          >
            <FaExclamationTriangle /> Danger Zone
          </h3>
          <p>Eliminar permanentemente la mascota seleccionada.</p>
          <button
            type="button"
            style={{
              backgroundColor: "#d73a49",
              color: "white",
              padding: "0.5rem 1rem",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
            onClick={() => setShowDeleteModal(true)}
          >
            Eliminar mascota
          </button>
        </section>
      )}

      {/* ——— Modal de confirmación ——— */}
      {showDeleteModal && pet && (
        <div
          style={{
            position: "fixed",
            inset: 0,
            backgroundColor: "rgba(0,0,0,0.5)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            zIndex: 1000,
          }}
        >
          <div
            style={{
              background: "white",
              padding: "2rem",
              borderRadius: "6px",
              width: "90%",
              maxWidth: "400px",
            }}
          >
            <h2>Confirmar eliminación</h2>
            <p>
              Escribe el nombre de la mascota{" "}
              <strong>{pet.name}</strong> para confirmar:
            </p>
            <input
              type="text"
              placeholder="Nombre de la mascota"
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              style={{
                width: "100%",
                padding: "0.5rem",
                marginTop: "0.5rem",
                marginBottom: "1rem",
                border: "1px solid #ccc",
                borderRadius: "4px",
              }}
            />
            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}
            >
              <button
                type="button"
                onClick={() => {
                  setShowDeleteModal(false);
                  setConfirmText("");
                }}
              >
                Cancelar
              </button>
              <button
                type="button"
                disabled={confirmText !== pet.name}
                style={{
                  backgroundColor: "#d73a49",
                  color: "white",
                  padding: "0.5rem 1rem",
                  border: "none",
                  borderRadius: "4px",
                  cursor:
                    confirmText === pet.name ? "pointer" : "not-allowed",
                  opacity: confirmText === pet.name ? 1 : 0.6,
                }}
                onClick={handleDelete}
              >
                Eliminar
              </button>
            </div>
          </div>
        </div>
      )}

    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/upgrade/page.tsx
"use client";
import React from "react";

export default function UpgradePage() {
    return (
        <div style={{ width: "100%" }}>
            <h2>Mejora tu plan</h2>
            <section style={{ width: "100%", marginBottom: "2rem" }}>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/basic-data/page.tsx (server component)
"use client";
import React, { useEffect, useState } from "react";
import { FaUser } from "react-icons/fa";
import { format } from "@/utils/dates";
import { BasicField, Loading, Title } from "@/components/index";
import { FieldType } from "@/types/lib";
import { BasicDataType, OwnerDataType } from "@/types/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch } from "@/app/api";
import { useSession } from "@/hooks/useSession";
import { useStorageContext } from "@/context/StorageProvider";

export default function BasicDataPage() {
  useSession();

  const { isMobile } = useDeviceDetect();
  const storage = useStorageContext();
  const [petData, setPetData] = useState<BasicDataType | null>(null);
  const [ownerData, setOwnerData] = useState<OwnerDataType | null>(null);
  const [basicDataItems, setBasicDataItems] = useState<FieldType[]>([]);
  const [contactItems, setContactItems] = useState<FieldType[]>([]);

  useEffect(() => {
    const petId = storage.storedPet.id;
    if (!petId || storage.storedBasicData.pet_id) {
      setPetData(storage.storedBasicData);
      return;
    }

    const fetchData = async () => {
      try {
        // 1) Datos básicos de la mascota
        const resPet = await getFetch(`/api/pets/basic-data/${storage.storedPet.id}`);
        if (!resPet.ok) throw new Error("Falló fetch basic-data");
        const basicData: BasicDataType = await resPet.json();
        storage.setStoredBasicData(basicData);
        setPetData(basicData);
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedBasicData]);


  useEffect(() => {
    const ownerId = storage.storedPet.owner_id;
    if (!ownerId || storage.storedOwnerData.owner_id) {
      setOwnerData(storage.storedOwnerData);
      return;
    }
    const fetchData = async () => {
      try {
        const resOwner = await getFetch(`/api/owners/${storage.storedPet.owner_id}`);
        if (!resOwner.ok) throw new Error("Falló fetch owners");
        const owner: OwnerDataType = await resOwner.json();
        storage.setStoredOwnerData(owner);
        setOwnerData(owner);
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedOwnerData]);

  useEffect(() => {
    if (!petData) return;
    setBasicDataItems([
      { label: "Tipo de mascota", show: true, value: petData.pet_type },
      { label: "Género", show: true, value: petData.gender },
      { label: "Peso", show: true, value: petData.weight },
      { label: "Raza", show: true, value: petData.race },
      { label: "Alergias", show: true, value: petData.has_allergies ? 'Si' : 'No' },
      { label: "Condición de peso", show: true, value: petData.weight_condition },
      { label: "Tamaño", show: true, value: petData.size },
      { label: "Vive con otros", show: true, value: petData.lives_with_others ? 'Si' : 'No' },
      { label: "Comida principal", show: true, value: petData.main_food },
      { label: "Última vacuna", show: true, value: petData.has_vaccine ? (`${petData.last_vaccine_name} (${format(petData.last_vaccine_date)})`) : 'No tiene vacunas' },
      { label: "Castrado", show: true, value: petData.is_castrated ? (`Sí (${format(petData.castration_date)})`) : 'No' },
      { label: "Antipulgas", show: true, value: petData.has_anti_flea ? (`Sí (${format(petData.anti_flea_date)})`) : 'No' },
      { label: "¿Usa medicina?", show: true, value: petData.uses_medicine ? 'Si' : 'No' },
      { label: "Condición especial", show: true, value: petData.special_condition ? 'Si' : 'No' },
    ]);
  }, [petData]);


  useEffect(() => {
    if (!ownerData) return;
    setContactItems([
      { label: "Nombre del contacto", show: true, value: ownerData.name },
      { label: "Teléfono", show: ownerData.phone != null, value: ownerData.phone },
      { label: "Dirección", show: ownerData.address != null, value: ownerData.address },
      { label: "Ciudad", show: true, value: ownerData.city },
      { label: "País", show: true, value: ownerData.country },
      { label: "Email", show: true, value: ownerData.email },
    ]);
  }, [ownerData]);

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      {/* Datos básicos en tres columnas */}
      <section style={{ marginBottom: "2rem" }}>
        {<Title icon={<FaUser />} title="Datos básicos" />}
        {!petData &&
          <Loading />
        }
        {petData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "1rem" }}>
            {basicDataItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
      <section>
        {<Title icon={<FaUser />} title="Datos de contacto" />}
        {!ownerData &&
          <Loading />
        }
        {ownerData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "1rem" }}>
            {contactItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
    </main>
  );
}

 
----- Archivo: page.tsx ----- 
// app/pages/pet/calendar/page.tsx (server component)
"use client";
import { Title } from "@/components/index";
import React from "react";
import { FaCalendar } from "react-icons/fa";

export default function CalendarPage() {
    return (
        <div style={{ width: "100%" }}>
            {<Title icon={<FaCalendar />} title="Próximos eventos programados" />}
            <section style={{ width: "100%", marginBottom: "2rem" }}>
                {/* <input type="date" value="2025-01-01" /> */}
            </section>

            <section>
                <h3>Datos de contacto</h3>
                <div
                    style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fit, minmax(120px, auto))",
                        gap: "0.5rem",
                        alignItems: "center",
                        marginBottom: "1rem",
                        fontSize: "0.8rem"
                    }}
                >
                    <select>
                        <option>Last 12 months</option>
                        <option>Last 6 months</option>
                    </select>
                    <input type="date" defaultValue="2020-08-01" />
                    <span style={{ textAlign: "center" }}>a</span>
                    <input type="date" defaultValue="2020-07-07" />
                    <select>
                        <option>Previous period</option>
                    </select>
                    <select>
                        <option>Monthly</option>
                    </select>
                    <button>Edit charts</button>
                </div>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/conditions/page.tsx
"use client";
import React from "react";
import { FaCloudSun } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function ConditionsPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Condiciones especiales"
            icon={<FaCloudSun />}
            apiUrl={'/api/pets/list/conditions/'}
            storedList={storage.storedConditionData}
            setStoredList={storage.setStoredConditionData}
            emptyMessage="No hay registro de condiciones especiales."
            mapItemToFields={FieldData.ForConditions}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/lab-tests/page.tsx
"use client";
import React from "react";
import { FaFlask } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function LabTestsPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Exámenes de laboratorio"
            icon={<FaFlask />}
            apiUrl={'/api/pets/list/lab-tests/'}
            storedList={storage.storedLabTestData}
            setStoredList={storage.setStoredLabTestData}
            emptyMessage="No hay registro de resultados de laboratorio."
            mapItemToFields={FieldData.ForLabTests}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaPills } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function MedicinesPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Medicinas"
            icon={<FaPills />}
            apiUrl={'/api/pets/list/medicines/'}
            storedList={storage.storedMedicineData}
            setStoredList={storage.setStoredMedicineData}
            emptyMessage="No hay registro de medicamentos."
            mapItemToFields={FieldData.ForMedicines}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/register/page.tsx
export default function PetRegisterPage(){
    return <div></div>
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaCut } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function SurgeriesPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Cirugías"
            icon={<FaCut />}
            apiUrl={'/api/pets/list/surgeries/'}
            storedList={storage.storedSurgeryData}
            setStoredList={storage.setStoredSurgeryData}
            emptyMessage="No hay registro de cirugías."
            mapItemToFields={FieldData.ForSurgeries}
        />
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/vaccines/page.tsx
"use client";
import React from "react";
import { FaSyringe } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function VaccinesPage() {
  const storage = useStorageContext();
  return (
    <PageComponent
      parentId={storage.storedPet.id}
      title="Vacunas"
      icon={<FaSyringe />}
      apiUrl={'/api/pets/list/vaccines/'}
      storedList={storage.storedVaccineData}
      setStoredList={storage.setStoredVaccineData}
      emptyMessage="No hay registro de vacunas."
      mapItemToFields={FieldData.ForVaccines}
    />
  );
}
 
----- Archivo: page.tsx ----- 
// app/pages/vet/[code]/page.tsx
"use client";
import { useEffect, useState } from "react";
import { useStorageContext } from "@/context/StorageProvider";
import PetEditForm from "./components/forms/PetEditForm";
import { PetType } from "@/types/index";

interface VetPageProps {
  params: Promise<{ code: string }>;
}

export default function VetPage({ params }: VetPageProps) {
  const [validatedCode, setValidatedCode] = useState("");
  const [pet, setPet] = useState<PetType | null>(null);
  const [isValid, setIsValid] = useState(false);
  const [message, setMessage] = useState("");

  const storage = useStorageContext();

  useEffect(() => {
    const fetchData = async () => {
      const { code } = await params;
      setValidatedCode(code);

      try {
        const res = await fetch(`/api/vet-access/validate?code=${code}`);
        const data = await res.json();

        if (!res.ok || !data.success) {
          setMessage(data.message || "Error validando el código.");
          return;
        }

        storage.setStoredPetCode(data.codeRecord);
        storage.setStoredPet(data.pet);
        if (data.vetAccess) {
          storage.setStoredVetAccess(data.vetAccess);
        }

        setPet(data.pet);
        setIsValid(true);
      } catch (err) {
        console.error("Error validando código veterinario:", err);
        setMessage("Ocurrió un error al validar el código.");
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params]);

  return (
    <main className="container" style={{ padding: "2rem" }}>
      <h1>Editar datos de mascota</h1>

      {!isValid && (
        <p style={{ marginBottom: "1rem", color: "red" }}>
          {message}
        </p>
      )}

      {pet && (
        <PetEditForm code={validatedCode} pet={pet} disabled={!isValid} />
      )}
    </main>
  );
}
 
----- Archivo: PetEditForm.tsx ----- 
// app/pages/vet/[code]/components/forms/PetEditForm.tsx
"use client";
import { putFetch } from "@/app/api";
import { PetType } from "@/types/index";
import React, { useState, FormEvent } from "react";

interface Props {
  code: string;
  pet: PetType;
  disabled?: boolean;
}

export default function PetEditForm({ code, pet, disabled = false }: Props) {
  const [name, setName] = useState(pet.name);
  const [image, setImage] = useState(pet.image || "");
  const [alert, setAlert] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (disabled) return;

    const res = await putFetch(`/api/vet/edit/${pet.id}`, undefined, { code, name, image });

    // ← usar res.ok para determinar éxito
    const success = res.ok;
    setFormFailed(!success);

    if (success) {
      setAlert("Datos actualizados correctamente.");
    } else {
      const json = await res.json();
      setAlert(json.error || "Error al actualizar.");
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: 400, display: "grid", gap: "1rem" }}
    >
      <label>
        Nombre
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          disabled={disabled}
          required
        />
      </label>

      <label>
        Imagen
        <input
          type="text"
          value={image}
          onChange={(e) => setImage(e.target.value)}
          disabled={disabled}
        />
      </label>

      <button type="submit" disabled={disabled}>
        Guardar cambios
      </button>

      {alert && (
        // ← solo basar color en formFailed
        <p style={{ color: formFailed ? "red" : "green" }}>{alert}</p>
      )}
    </form>
  );
}
 
----- Archivo: layout.tsx ----- 
// app/vet-access/layout.tsx
export default function VetLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body className="p-4">
        {children}
      </body>
    </html>
  );
} 
----- Archivo: page.tsx ----- 
// app/vet-access/page.tsx
"use client";
import React, { useState } from "react";
import Link from "next/link";
import VeterinaryModal from "@/components/modals/VeterinaryModal";

export default function VetAccessPage() {
  const [showVetModal, setShowVetModal] = useState(false);

  return (
    <main className="container" style={{ padding: "2rem", maxWidth: 600 }}>
      <h1>Acceso Veterinario</h1>
      <p>
        Introduce el código de la mascota que te haya facilitado el dueño para
        ver su historial y agregar nuevas entradas.
      </p>

      <div
        className="grid"
        style={{ gridTemplateColumns: "1fr", gap: "1rem", margin: "2rem 0" }}
      >
        {/* Botón para acceder sin registrarse */}
        <button
          className="contrast"
          onClick={() => setShowVetModal(true)}
        >
          Ingresar sin registrarse
        </button>

        {/* Enlace a registro de veterinario (implementa esta ruta si lo deseas) */}
        <Link href="/vet-access/register" className="primary">
          Registrarme como veterinario
        </Link>
      </div>

      {/**  
       * Reutilizamos el componente VeterinaryModal para capturar datos
       * y hacer el POST a VeterinaryAccessRepository.create  
       */}
      {showVetModal && (
        <VeterinaryModal />
      )}
    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// app/vet-access/register/page.tsx
"use client";
import React, { FormEvent, useState } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import ModalComponent from "@/components/lib/modal";
import { postFetch } from "@/app/api";
import { FaEye, FaEyeSlash } from "react-icons/fa";

export default function VetRegisterPage() {
  const router = useRouter();

  // Estados del formulario
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  // Estados UI
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError("");

    // Validación básica
    if (![firstName, lastName, registration, clinicName, city, email, password].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }

    setLoading(true);
    try {
      // 1) Crear cuenta en auth
      const signUpRes = await postFetch("/api/auth/sign-up", undefined, { email, password, role: 'veterinarian' });
      const signUpJson = await signUpRes.json();
      if (!signUpRes.ok || !signUpJson.success) {
        setError("Error al registrar la cuenta.");
        return;
      }

      const vetId = signUpJson.user?.id;
      if (vetId) {
        // 2) Guardar perfil de veterinario
        const profileRes = await postFetch("/api/vet", undefined, {
          vet_id: vetId,
          first_name: firstName,
          last_name: lastName,
          registration,
          clinic_name: clinicName,
          city,
          email
        });
        if (!profileRes.ok) {
          setError("Error creando perfil de veterinario.");
          return;
        }
      }

      // 3) Mostrar modal de confirmación de correo
      setShowConfirmModal(true);

    } catch {
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  // Modal de “Confirma tu correo”
  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal}
      >
        <button
          className="contrast"
          onClick={() => router.push("/")}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          Ya confirmé, continuar
        </button>
      </ModalComponent>
    );
  }

  // Formulario de registro
  return (
    <main style={{ maxWidth: 600, margin: "2rem auto", padding: '2rem' }}>
      <h1>Registro Veterinario</h1>
      <form onSubmit={handleSubmit}
        style={{
          background: "#fff",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
          width: "100%",
          maxWidth: "550px",
        }}>
        <div className="grid" style={{ gridTemplateColumns: "1fr 1fr", gap: "1rem" }}>
          <label>
            Nombre
            <input
              type="text"
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              required
            />
          </label>
          <label>
            Apellido
            <input
              type="text"
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              required
            />
          </label>
          <label>
            Registro profesional
            <input
              type="text"
              value={registration}
              onChange={e => setRegistration(e.target.value)}
              required
            />
          </label>
          <label>
            Clínica / Laboratorio
            <input
              type="text"
              value={clinicName}
              onChange={e => setClinicName(e.target.value)}
              required
            />
          </label>
          <label>
            Ciudad
            <input
              type="text"
              value={city}
              onChange={e => setCity(e.target.value)}
              required
            />
          </label>
        </div>

        <label>
          Email
          <input
            type="email"
            value={email}
            onChange={e => setEmail(e.target.value)}
            required
          />
        </label>

        <label style={{ position: 'relative' }}>
          Contraseña
          <input
            type={showPassword ? "text" : "password"}
            value={password}
            onChange={e => setPassword(e.target.value)}
            required
          />
          <button
            type="button"
            onClick={() => setShowPassword(!showPassword)}
            aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
            style={{
              position: 'absolute',
              right: '0.75rem',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'none',
              border: 'none',
              padding: 0,
              cursor: 'pointer',
            }}
          >
            {showPassword ? <FaEyeSlash size={23} color={'#000'} style={{ marginTop: '16px' }} /> : <FaEye size={23} color={'#000'} style={{ marginTop: '16px' }} />}
          </button>
        </label>

        {error && <p style={{ color: "red", marginTop: "0.5rem" }}>{error}</p>}

        <button
          type="submit"
          disabled={loading}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          {loading ? "Registrando..." : "Registrarme"}
        </button>
      </form>
    </main>
  );
}
 
----- Archivo: index.ts ----- 
// layout
export { default as SideBar } from "./layout/SideBar";
export { default as Bubbles } from "./modals/Bubbles";
export { default as ClientAppProvider } from "../context/ClientAppProvider";

// lib
export { default as AddItem } from "./lib/addItem";
export { default as BasicField } from "./lib/basicField";
export { default as CircularImage } from './lib/circularImage';
export { default as DataNotFound } from "./lib/dataNotFound";
export { default as Display } from "./lib/display";
export { default as Entities } from "./lib/entities";
export { default as Entity } from "./lib/entity";
export { default as EntityFields } from "./lib/entityFields";
export { default as EntityForm } from "./lib/entityForm";
export { default as Field } from "./lib/field";
export { default as Form } from "./lib/form";
export { default as Loading } from "./lib/loading";
export { default as Modal } from "./lib/modal";
export { default as PageComponent } from "./lib/page";
export { default as RemoveItem } from "./lib/removeItem";
export { default as Steps } from "./lib/steps";
export { default as Title } from "./lib/title";
 
----- Archivo: index.ts ----- 
export { default as BasicDataForm } from './BasicDataForm';
export { default as PetNameForm } from './PetNameForm'; 
----- Archivo: BasicDataForm.tsx ----- 
// src/components/forms/BasicDataForm.tsx
import React, { useState, useEffect, Dispatch } from 'react';
import { InitialBasicDataType, PetStep as PetStep, PetType, type BasicDataType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import { Dates, Steps } from '@/utils/index';
import { petTypes, genders, weightUnits, breedOptions, foodOptions, weightConditionOptions, sizeOptions } from '@/data/petdata';
import { Empty } from '@/data/index';
import { useDeviceDetect } from '@/hooks/useDeviceDetect';
import { postFetch } from '@/app/api';
import StepsComponent from '../lib/steps';
import { useStorageContext } from '@/context/StorageProvider';

interface BasicDataFormProps {
  pet: PetType;
  basicData: BasicDataType;
  setBasicData: (basicData: BasicDataType) => void;
  onBack: () => void;
  onNext: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
}

export default function BasicDataForm({ pet, basicData, setBasicData, onNext, onBack, stepStates, setStepStates }: BasicDataFormProps) {
  const step = PetStep.BasicData;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  }
  const stateEq = (stepState: StepStateEnum) => {
    return stepStates.find(x => x.step == step)?.state == stepState;
  }
  const initials = (basicData: BasicDataType, fetch: boolean = false): InitialBasicDataType => {
    const initialPetType = petTypes.filter(t => t == basicData.pet_type).length > 0 || (basicData.pet_type == '' && !fetch) ? basicData.pet_type : 'Otro';
    const initialFood = foodOptions.find(t => t == basicData.main_food) != null || (basicData.main_food == '' && !fetch) ? basicData.main_food : 'Otro';
    const initialRace = (breedOptions[initialPetType] ?? []).filter(t => t == basicData.race).length > 0 || (basicData.race == '' && !fetch) ? basicData.race : 'Otro';
    const initialOtherPetType = initialPetType != 'Otro' && basicData.pet_type == 'Otro' ? '' : basicData.pet_type;
    const initialOtherFood = initialFood != 'Otro' && basicData.main_food == 'Otro' ? '' : basicData.main_food;
    const initialOtherRace = initialRace != 'Otro' && basicData.race == 'Otro' ? '' : basicData.race;
    return {
      petType: initialPetType,
      food: initialFood,
      race: initialRace,
      otherPetType: initialOtherPetType,
      otherFood: initialOtherFood,
      otherRace: initialOtherRace
    };
  };

  const initial = initials(basicData);
  const [formData, setFormData] = useState<Partial<BasicDataType>>({ ...basicData, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [weight, setWeight] = useState<number>(parseFloat(basicData.weight.split(' ')[0]) ?? 0);
  const [weightUnit, setWeightUnit] = useState<string>(basicData.weight.split(' ')[1]);
  const [otherPetType, setOtherPetType] = useState<string>(initial.otherPetType);
  const [otherFood, setOtherFood] = useState<string>(initial.otherFood);
  const [otherRace, setOtherRace] = useState<string>(initial.otherRace);
  const [loadedWithPreviusData, setLoadedWithPreviusData] = useState<boolean>(false);
  const [savedData, setSavedData] = useState<BasicDataType>(Empty.BasicData());
  const { isMobile, isDesktop, isTablet } = useDeviceDetect();
  const storage = useStorageContext();

  // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
  const sectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: isMobile
      ? "repeat(2, 1fr)"
      : "repeat(4, 1fr)"
  };
  // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
  const tabletSectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: "repeat(2, 1fr)"
  };



  useEffect(() => {
    if (JSON.stringify(savedData) != JSON.stringify(formData) && !stateEq(StepStateEnum.NotInitialize) && loadLoading == false) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData, otherPetType, otherFood, otherRace, weight, weightUnit]);

  useEffect(() => {
    const fetchData = async () => {
      setLoadLoading(true);
      if(stateEq(StepStateEnum.NotInitialize) && !basicData.pet_id)
      if (stateEq(StepStateEnum.NotInitialize)) {
        setState(StepStateEnum.Initialize);
        let basicDataSaved: BasicDataType = Empty.BasicData();
        if (!storage.storedBasicData.pet_id) {
          const petResponse = await fetch(`/api/pets/basic-data/${pet.id}`);
          if (!petResponse.ok) throw new Error("Falló fetch basic-data");
          basicDataSaved = await petResponse.json() as BasicDataType;
        }
        else if (storage.storedBasicData.pet_id == pet.id) {
          basicDataSaved = storage.storedBasicData;
        }
        if (basicDataSaved.pet_id) {
          setSavedData(basicDataSaved);
          setBasicData(basicDataSaved);
          const initial = initials(basicDataSaved, loadedWithPreviusData);
          setLoadedWithPreviusData(true);
          setFormData({ ...basicDataSaved, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
          setWeight(parseFloat(basicDataSaved.weight.split(' ')[0]));
          setWeightUnit(basicDataSaved.weight.split(' ')[1]);
          setOtherPetType(initial.otherPetType);
          setOtherRace(initial.otherRace);
          setOtherFood(initial.otherFood);
        }
      }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet.id, formData]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(false);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        const finalFood = formData.main_food === 'Otro' ? otherFood.trim() : formData.main_food;
        const finalPetType = formData.pet_type === 'Otro' ? otherPetType.trim() : formData.pet_type;
        const finalRace = formData.race === 'Otro' ? otherRace.trim() : formData.race;
        const finalWeight = `${weight ?? 0} ${weightUnit}`;
        const dataToSave: BasicDataType = {
          ...(formData as BasicDataType),
          main_food: finalFood || '',
          weight: finalWeight || '0 Kg',
          pet_type: finalPetType || '',
          race: finalRace || '',
        };
        const basicDataResponse = await postFetch(`/api/pets/basic-data/${formData.pet_id}`, undefined, dataToSave);
        if (!basicDataResponse.ok) throw new ApiError("Error actualizado datos básicos de la mascota");
        setSavedData(dataToSave);
        setBasicData(dataToSave);
        if (dataToSave.pet_id == storage.storedBasicData.pet_id) {
          storage.setStoredBasicData(dataToSave);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
      setSubmitLoading(true);
    } finally {
      setSubmitLoading(true);
    }
  };

  return (
    <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={stepStates.length} error={error}>
      {/* Sección: Información básica */}
      <fieldset>
        <legend><b>Información básica</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="pet_type">Tipo de mascota</label>
            <select
              id="pet_type"
              className="w-full"
              value={formData.pet_type}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: 'Otro', race: '' });
                } else {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: val, race: '' });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona tipo</option>
              {petTypes.map(type => <option key={type} value={type}>{type}</option>)}
            </select>
            {formData.pet_type === 'Otro' && (
              <input
                value={otherPetType}
                type="text"
                placeholder="Especifica el tipo"
                className="w-full mt-2"
                disabled={loadLoading}
                onChange={e => setOtherPetType(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="gender">Género</label>
            <select
              id="gender"
              className="w-full"
              value={formData.gender}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, gender: e.target.value })}
              required
            >
              <option value="" disabled>Selecciona género</option>
              {genders.map(g => <option key={g} value={g}>{g}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="weight">Peso</label>
            <div className="flex gap-2">
              <input
                id="weight"
                type="number"
                pattern="^\d+(?:\.\d{1,2})?$"
                min="0"
                className="w-2/3"
                disabled={loadLoading}
                value={weight ?? 0}
                onChange={e => setWeight(parseFloat(e.target.value) ?? 0)}
                required
              />
              <select
                id="weight_unit"
                className="w-1/3"
                value={weightUnit}
                disabled={loadLoading}
                onChange={e => setWeightUnit(e.target.value)}
              >
                {weightUnits.map(u => <option key={u} value={u}>{u}</option>)}
              </select>
            </div>
          </div>
          <div>
            <label htmlFor="race">Raza</label>
            <select
              id="race"
              className="w-full"
              disabled={loadLoading || !formData.pet_type}
              value={formData.race}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: 'Otro' });
                } else {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: val });
                }
              }}
              required
            >
              <option value="" disabled>{formData.pet_type ? 'Selecciona raza' : 'Selecciona primero tipo'}</option>
              {formData.pet_type && breedOptions[formData.pet_type].map(r => <option key={r} value={r}>{r}</option>)}
            </select>
            {formData.race === 'Otro' && (
              <input
                value={otherRace}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la raza"
                className="w-full mt-2"
                onChange={e => setOtherRace(e.target.value)}
              />
            )}
          </div>
        </div>
      </fieldset>

      {/* Sección: Alimentación y entorno */}
      <fieldset>
        <legend><b>Alimentación y entorno</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="main_food">Comida principal</label>
            <select
              id="main_food"
              className="w-full"
              value={formData.main_food}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: 'Otro' });
                } else {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: val });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona comida</option>
              {foodOptions.map(food => <option key={food} value={food}>{food}</option>)}
            </select>
            {formData.main_food === 'Otro' && (
              <input
                value={otherFood}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la comida"
                className="w-full mt-2"
                onChange={e => setOtherFood(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="weight_condition">Condición de peso</label>
            <select
              id="weight_condition"
              className="w-full"
              value={formData.weight_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, weight_condition: e.target.value })}
            >
              <option value="" disabled>Selecciona condición</option>
              {weightConditionOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="size">Tamaño</label>
            <select
              id="size"
              className="w-full"
              value={formData.size}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, size: e.target.value })}
            >
              <option value="" disabled>Selecciona tamaño</option>
              {sizeOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
        </div>
        <div style={sectionGridStyle}>
          <div>
            <label className="flex items-center gap-2" htmlFor="lives_with_others">
              <input
                id="lives_with_others"
                type="checkbox"
                checked={formData.lives_with_others}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, lives_with_others: e.target.checked })}
              />
              Vive con otros
            </label>
          </div>
          <div>
            <label className="flex items-center gap-2" htmlFor="has_allergies">
              <input
                id="has_allergies"
                type="checkbox"
                checked={formData.has_allergies}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_allergies: e.target.checked })}
              />
              Alergias
            </label>
          </div>
        </div>
      </fieldset>

      {/* Sección: Vacunación y procedimientos */}
      <fieldset>
        <legend><b>Vacunación y procedimientos</b></legend>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          <div style={{ gridColumn: 'span 2' }}>
            <label className="flex items-center gap-2" htmlFor="has_vaccine">
              <input
                id="has_vaccine"
                type="checkbox"
                checked={formData.has_vaccine}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_vaccine: e.target.checked })}
              />
              Tiene vacunas
            </label>
          </div>
          {isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_castrated">
                  <input
                    id="is_castrated"
                    type="checkbox"
                    checked={formData.is_castrated}
                    onChange={e => setFormData({ ...formData, is_castrated: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Castrado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
        </div>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          {formData.has_vaccine && (
            <>
              <div>
                <label htmlFor="last_vaccine_name">Nombre última vacuna</label>
                <input
                  id="last_vaccine_name"
                  type="text"
                  className="w-full"
                  value={formData.last_vaccine_name}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_name: e.target.value })}
                />
              </div>
              <div>
                <label htmlFor="last_vaccine_date">Fecha última vacuna</label>
                <input
                  id="last_vaccine_date"
                  type="date"
                  className="w-full"
                  value={formData.last_vaccine_date ? Dates.format(formData.last_vaccine_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_date: e.target.valueAsDate || undefined })}
                />
              </div>
            </>
          )}
          {!formData.has_vaccine &&
            <>
              <div style={{ gridColumn: 'span 2' }}></div>
            </>}
          {!isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_castrated">
                  <input
                    id="is_castrated"
                    type="checkbox"
                    checked={formData.is_castrated}
                    onChange={e => setFormData({ ...formData, is_castrated: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Castrado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
          <div>
            {formData.is_castrated && (
              <div>
                <label htmlFor="castration_date">Fecha de castración</label>
                <input
                  id="castration_date"
                  type="date"
                  className="w-full"
                  value={formData.castration_date ? Dates.format(formData.castration_date) : ''}
                  onChange={e => setFormData({ ...formData, castration_date: e.target.valueAsDate || undefined })}
                  disabled={loadLoading}
                />
              </div>
            )}
          </div>
          <div>
            {formData.has_anti_flea && (
              <div>
                <label htmlFor="anti_flea_date">Fecha antipulgas</label>
                <input
                  id="anti_flea_date"
                  type="date"
                  className="w-full"
                  value={formData.anti_flea_date ? Dates.format(formData.anti_flea_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, anti_flea_date: e.target.valueAsDate || undefined })}
                />
              </div>
            )}
          </div>
        </div>
      </fieldset>

      {/* Sección: Otros datos */}
      <fieldset>
        <legend><b>Otros datos</b></legend>
        <div style={sectionGridStyle}>
          <label className="flex items-center gap-2" htmlFor="uses_medicine">
            <input
              id="uses_medicine"
              type="checkbox"
              checked={formData.uses_medicine}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, uses_medicine: e.target.checked })}
            />
            Usa medicina
          </label>
          <label className="flex items-center gap-2" htmlFor="special_condition">
            <input
              id="special_condition"
              type="checkbox"
              checked={formData.special_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, special_condition: e.target.checked })}
            />
            Condición especial
          </label>
        </div>
      </fieldset>
    </StepsComponent>
  );
} 
----- Archivo: PetNameForm.tsx ----- 
// src/components/forms/PetNameForm.tsx
import React, { Dispatch, useEffect, useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { FaCloudUploadAlt } from 'react-icons/fa';
import { generateUniquePetId } from '@/utils/random';
import { PetStep, PetType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import StepsComponent from '../lib/steps';
import { Steps } from '@/utils/index';
import { Empty } from '@/data/index';
import { CircularImage } from "@/components/index";
import { getFetch, postFetch } from '@/app/api';
import { useStorageContext } from '@/context/StorageProvider';

interface PetFormProps {
  ownerId: string;
  pet: PetType;
  setPet: (pet: PetType) => void;
  onNext: () => void;
  onBack: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
}

export default function PetNameForm({
  ownerId,
  pet,
  setPet,
  onNext,
  onBack,
  stepStates,
  setStepStates,
}: PetFormProps) {
  const step = PetStep.Name;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  };
  const stateEq = (stepState: StepStateEnum) =>
    stepStates.find((x) => x.step === step)?.state === stepState;

  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [savedData, setSavedData] = useState<PetType>(Empty.Pet());
  const [preview, setPreview] = useState<string>(pet.image || '/pets/pet.jpg');
  const storage = useStorageContext();

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result as string;
      setPet({ ...pet, image: base64 });
      setPreview(base64);
    };
    reader.readAsDataURL(file);
  }, [pet, setPet]);

  const { getRootProps, getInputProps, isDragActive, open } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    multiple: false,
    noClick: true,
    noKeyboard: true,
  });

  useEffect(() => {
    const fetchData = async () => {
      if (stateEq(StepStateEnum.NotInitialize) && !pet.id) {
        setState(StepStateEnum.Initialize);
      } else if (stateEq(StepStateEnum.NotInitialize)) {
        setState(StepStateEnum.Initialize);
        let petSaved: PetType = Empty.Pet();
        if (!storage.storedPet.id) {
          const response = await getFetch(`/api/pets/${pet.id}`);
          if (!response.ok) {
            throw new ApiError('Error al obtener la mascota');
          }
          petSaved = (await response.json())[0] as PetType;
        }
        else if (storage.storedPet.id == pet.id) {
          petSaved = storage.storedPet;
        }
        if (petSaved) {
          setPet(petSaved);
          setSavedData(petSaved);
          setPreview(petSaved.image || preview);
        }
      }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  useEffect(() => {
    if (
      JSON.stringify(savedData) !== JSON.stringify(pet) &&
      !stateEq(StepStateEnum.NotInitialize)
    ) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(true);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        const newId = pet.id || (await generateUniquePetId());
        const newPet: PetType = { id: newId, name: pet.name, image: pet.image, owner_id: ownerId };
        if (JSON.stringify(newPet) != JSON.stringify(pet)) {
          const response = await postFetch('/api/pets', undefined, newPet);
          const result = await response.json();
          if (!response.ok) {
            throw new ApiError('Error al guardar mascota');
          }
          const savedPet: PetType = result[0] as PetType;
          setSavedData(savedPet);
          if (newPet.id)
            storage.setStoredPet(savedPet);
          const pets = storage.storedOwnerPets.filter((p: PetType) => p.id != savedPet.id);
          storage.setStoredOwnerPets([...pets, savedPet]);
          setPet(savedPet);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
    } finally {
      setSubmitLoading(false);
    }
  };

  return (
    <StepsComponent
      onBack={onBack}
      onNext={handleSubmit}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      step={step}
      totalSteps={stepStates.length}
      error={error}
    >
      <div style={{ display: 'grid', gap: '1rem', marginBottom: '30px' }}>
        <label>
          Nombre
          <input
            type="text"
            value={pet.name}
            disabled={loadLoading}
            onChange={(e) => setPet({ ...pet, name: e.target.value })}
            required
          />
        </label>

        {pet.image ? (
          <CircularImage
            src={preview}
            width={200}
            getRootProps={getRootProps}
            getInputProps={getInputProps}
            onClick={open}
            overlayText="Cambiar foto"
            hoverEnabled={true}
          />
        ) : (
          <div
            {...getRootProps()}
            style={{
              border: `2px dashed ${isDragActive ? '#4285f4' : '#ccc'}`,
              borderRadius: '4px',
              padding: '1.5rem',
              backgroundColor: isDragActive ? '#e8f0fe' : '#f5f5f5',
              textAlign: 'center',
              cursor: 'pointer'
            }}
            onClick={open}
          >
            <input {...getInputProps()} />
            <FaCloudUploadAlt
              style={{ fontSize: '2rem', color: isDragActive ? '#4285f4' : '#888' }}
            />
            <p style={{ marginTop: '0.5rem', fontWeight: 'bold' }}>
              <b>Selecciona o</b> arrastra y suelta la foto aquí
            </p>
          </div>
        )}
      </div>
    </StepsComponent>
  );
}
 
----- Archivo: SideBar.tsx ----- 
// app/components/modals/side-bar.tsx
"use client";
import React, { useEffect, useState } from "react";
import {
    FaBars,
    FaCloudSun,
    FaCog,
    FaCut,
    FaFlask,
    FaHome,
    FaPills,
    FaPowerOff,
    FaRocket,
    FaSyringe,
    FaUser
} from "react-icons/fa";
import Link from 'next/link';
import Image from 'next/image';
import { MenuType } from "@/types/lib";
import { v4 } from 'uuid';
import { useRouter } from "next/navigation";
import { FaPencil } from "react-icons/fa6";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { handleLogout } from "@/services/authService";
import { useSessionContext } from "@/context/SessionProvider";
import { useRoleContext } from "@/context/RoleProvider";

export default function SideBar() {
    const { isMobile, isTablet, isDesktop } = useDeviceDetect();
    const session = useSessionContext();
    const storage = useStorageContext();
    const [menuItems, setMenuItems] = useState<MenuType[]>([]);
    const router = useRouter();
    const { setShowEditPetModal } = useUI();
    const {isOwner, isVet}= useRoleContext();

    const menuData = (show: boolean): MenuType[] => [
        { label: "Inicio", icon: <FaHome />, url: "/", show: isOwner },
        { label: "Datos básicos", icon: <FaUser />, url: "/pages/pet/basic-data", show },
        { label: "Vacunas", icon: <FaSyringe />, url: "/pages/pet/vaccines", show },
        { label: "Cirugías", icon: <FaCut />, url: "/pages/pet/surgeries", show },
        { label: "Medicinas", icon: <FaPills />, url: "/pages/pet/medicines", show },
        { label: "Condiciones especiales", icon: <FaCloudSun />, url: "/pages/pet/conditions", show },
        { label: "Lab. de exámenes", icon: <FaFlask />, url: "/pages/pet/lab-tests", show },
        { label: "Mejora tu plan", icon: <FaRocket />, url: "/pages/owner/upgrade", show: isOwner },
        { label: "Configuraciones", icon: <FaCog />, url: "/pages/owner/settings", show: isOwner },
        { label: "Agregar Consulta", icon: <FaCog />, url: "/pages/vet/diagnostic", show: isVet }
    ];
    useEffect(() => {
    console.log('isOwner', isOwner);
        const menu = menuData(storage.storedPet.id != "");

        if (storage.storedPet) {
            menu.push({ label: 'Editar Mascota', icon: <FaPencil />, url: "", showModal: setShowEditPetModal, show: isOwner });
        }
        setMenuItems(menu);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedPet, storage.storedOwnerPets, session, storage.storedVetAccess, setShowEditPetModal]);

    const goToLogin = () => {
        storage.setStoredVetAccess(Empty.VetAccess());
        router.push("/login");
    }

    function item({ label, icon, url, show, showModal }: MenuType) {
        if (showModal) {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <a onClick={() => showModal(true)} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </a>
                </li>
            );
        }
        else if (!show) {
            return <div key={v4()}></div>;
        }
        else {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <Link href={url} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </Link>
                </li>
            );
        }
    }

    return (
        <>
            {/* Desktop Sidebar */}
            {isDesktop && (
                <aside
                    style={{
                        width: "300px",
                        display: "flex",
                        flexDirection: "column",
                        paddingTop: "1rem",
                        backgroundColor: "#ffffff",
                        boxShadow: "0 4px 12px rgba(0,0,0,0.05)",
                    }}
                >
                    <div style={{ padding: "0 1rem 1rem", display: 'flex', alignItems: 'center' }}>
                        <CircularImage
                            src={storage.storedPet.image || "/pets/pet.jpg"}
                            width={80}
                        />
                        <p style={{ marginLeft: '20px' }}>
                            <b>{storage.storedPet.name ?? 'Nombre de tu mascota'}</b>
                        </p>
                    </div>
                    <nav style={{ padding: "0 1rem" }}>
                        <ul>
                            {menuItems.map(item)}
                            {session && <li><a style={{ background: "none", border: "none", color: '#d32f2f' }} onClick={() => handleLogout(storage, router)}> <FaPowerOff style={{ marginRight: '1rem' }} />Cerrar sesión</a></li>}
                            {!session && <li><button onClick={goToLogin}>Iniciar sesión</button></li>}
                        </ul>
                    </nav>
                    <div style={{ display: "flow", justifyContent: "space-around", marginTop: "1rem" }}>
                        <Image src="/others/play-store.png" alt="Google Play" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                        <br /><br />
                        <Image src="/others/app-store.png" alt="App Store" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                    </div>
                </aside>
            )}

            {/* Mobile Sidebar */}
            {(isMobile || isTablet) && (
                <aside
                    style={{
                        position: "fixed",
                        top: 0,
                        bottom: 0,
                        left: 0,
                        width: "64px",
                        backgroundColor: "#ffffff",
                        boxShadow: "2px 0 8px rgba(0,0,0,0.05)",
                        zIndex: 1000,
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        paddingTop: "1rem",
                        gap: "1rem"
                    }}
                >
                    {/* Foto y nombre */}
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>
                        <CircularImage src={storage.storedPet.image || "/pets/pet.jpg"} width={50} borderSize="2px" />
                        <span style={{ fontSize: "1rem", textAlign: "center", padding: "0 4px" }}><b>{storage.storedPet.name}</b></span>
                    </div>

                    {/* Íconos con tooltip */}
                    {menuItems.filter(m => m.show).map(({ label, icon, url, showModal }) => {
                        const content = (
                            <div className="tooltip-container" style={{ fontSize: "1.75rem", cursor: "pointer" }}>
                                {icon}
                                <span className="tooltip-text">{label}</span>
                            </div>
                        );

                        if (showModal) {
                            return (
                                <button
                                    key={label}
                                    onClick={() => showModal(true)}
                                    style={{ background: "none", border: "none", color: '#02659a', padding: '0' }}
                                >
                                    {content}
                                </button>
                            );
                        } else {
                            return (
                                <Link
                                    key={label}
                                    href={url}
                                    style={{ display: "flex", justifyContent: "center", alignItems: "center", color: '#02659a' }}
                                >
                                    {content}
                                </Link>
                            );
                        }
                    })}

                    {/* Logout/Login */}
                    <div style={{ position: 'fixed', bottom: "0", marginBottom: "1rem" }}>
                        <div className="tooltip-container" style={{ cursor: "pointer" }}>
                            <button
                                onClick={session ? () => handleLogout(storage, router) : goToLogin}
                                style={{ background: "none", border: "none", fontSize: "1.75rem", color: '#d32f2f' }}
                            >
                                {session ? <FaPowerOff /> : <FaBars />}
                            </button>
                            <span className="tooltip-text tooltip-right">{session ? "Cerrar sesión" : "Iniciar sesión"}</span>
                        </div>
                    </div>
                </aside>
            )}
        </>
    );
}
 
----- Archivo: addItem.tsx ----- 
// src/components/lib/addItem.tsx

import { tooltipStyles } from "@/styles/tooltip";
import { FaInfoCircle } from "react-icons/fa";
interface AddItemProps {
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
    count: number;
}

export default function AddItemComponent({ entityName, loadLoading, handleAdd, count }: AddItemProps) {
    return (
        <>
            <style jsx global>{`
        ${tooltipStyles}

        /* Override específico para tooltip de advertencia */
        .tooltip-container.tooltip-warning .tooltip-text {
          background-color: #fff3cd !important;  /* amarillo pálido */
          color: #856404 !important;            /* texto oscuro */
          border-color: #ffeeba !important;      /* borde amarillo */

          /* Posicionar a la derecha del icono */
          top: 50%;
          left: 120%;
          right: auto;
          bottom: auto;
          transform: translateY(-50%);   
          
        }
        .tooltip-container>svg {    
            font-size: 33px;
            color: #856404;
            margin-left: 10px;
        }
      `}</style>
            <div className="flex items-center flex-wrap gap-2">
                <button
                    type="button"
                    onClick={handleAdd}
                    className="contrast"
                    disabled={loadLoading}
                >
                    Agregar {count == 0 ? '' : 'otra '} {entityName}
                </button>

                {count === 0 && (
                    <span className="tooltip-container tooltip-warning">
                        <FaInfoCircle className="ml-1 text-yellow-600" />
                        <span className="tooltip-text">
                            Puedes añadir estos datos más tarde
                        </span>
                    </span>
                )}
            </div>
        </>
    );
} 
----- Archivo: basicField.tsx ----- 
// src/components/lib/basicField.tsx
import { FieldType } from "@/types/lib";

interface BasicFieldProps {
    item: FieldType
}

export default function BasicFieldComponent(props: BasicFieldProps) {
    if (!props.item.show) {
        return <div></div>;
    }
    return (
        <div key={props.item.label} style={{ backgroundColor: "#ffffff", padding: "1rem", borderRadius: "0.5rem", boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
            <p style={{ fontSize: "0.75rem", color: "#6B7280", margin: 0 }}>{props.item.label}</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}>{props.item.value}</p>
        </div>
    );
}
 
----- Archivo: circularImage.tsx ----- 
// src/components/lib/circularImage.tsx
import React, { useState } from 'react';
import Image from 'next/image';

// Componente reutilizable para avatar circular
interface CircularImageProps {
    src: string;
    width: number;
    borderSize?: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getRootProps?: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInputProps?: any;
    onClick?: () => void;
    overlayText?: string;
    hoverEnabled?: boolean;
}

export default function CircularImageComponent({ src, width, borderSize = '5px', getRootProps, getInputProps, onClick, overlayText, hoverEnabled = false }: CircularImageProps) {
    const [hover, setHover] = useState(false);
    if (!hoverEnabled) {
        return (
            <div style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: `${borderSize} solid #02659a`,
                cursor: 'pointer'
            }}
            >
                <Image
                    loading={"lazy"}
                    src={src}
                    alt="Foto de la mascota" fill
                    style={{ objectFit: 'cover' }} />
            </div>
        );
    }
    return (
        <div
            {...getRootProps()}
            onClick={onClick}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: '5px solid #02659a',
                cursor: 'pointer'
            }}
        >
            <input {...getInputProps()} />
            <Image
                loading={"lazy"}
                src={src}
                alt="Foto de la mascota" fill
                style={{ objectFit: 'cover' }} />
            {hover && overlayText && (
                <div
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'rgba(255,255,255,0.6)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        borderRadius: '50%'
                    }}
                >
                    <span style={{ fontWeight: 'bold', color: '#333', textAlign: 'center' }}>
                        {overlayText}
                    </span>
                </div>
            )}
        </div>
    );
} 
----- Archivo: dataNotFound.tsx ----- 
// src/components/DataNotFound.tsx
import React from "react";
import { FaInbox } from "react-icons/fa";

interface DataNotFoundProps {
  message: string;
}

export default function DataNotFoundComponent({ message }: DataNotFoundProps) {
  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: "2rem",
        backgroundColor: "#F3F4F6",
        borderRadius: "0.5rem",
        color: "#6B7280",
        textAlign: "center",
        maxWidth: "400px",
        margin: "2rem auto",
        boxShadow: "0 2px 8px rgba(0,0,0,0.05)",
      }}
    >
      <FaInbox
        size={48}
        style={{ marginBottom: "1rem", color: "#D1D5DB" }}
      />
      <p style={{ fontSize: "1.25rem", lineHeight: "1.5" }}>
        {message}
      </p>
    </div>
  );
}
 
----- Archivo: display.tsx ----- 
// src/components/lib/display.tsx
import { FieldType, FormType as DisplayType } from "@/types/lib";
import { Field } from "@/components/index";
import { v4 } from "uuid";

interface DisplayProps {
    formItems: DisplayType[];
    isMobile: boolean;
}

export default function DisplayComponent(props: DisplayProps) {
    return (
        <div style={{ display: "grid", gridTemplateColumns: props.isMobile ? "1fr" : "repeat(2, 1fr)", gap: "1rem" }}>
            {props.formItems.map((item) => (
                <div key={item.id} style={{ backgroundColor: "transparent", padding: "0.1rem", borderRadius: "0.5rem", borderColor: '#000', borderWidth: '1px', border: 'groove', boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
                    {item.fields.map((field: FieldType) =>
                        <Field key={v4()} field={field} />
                    )}
                </div>
            ))}
        </div>
    );
} 
----- Archivo: entities.tsx ----- 
// src/components/entities.tsx
"use client";

import React from "react";
import { AddItem, Entity } from "@/components/index";

interface EntitiesProps {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    form: (item: any, id: number) => React.JSX.Element;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    entityList: any[];
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
}
export default function EntitiesComponent({ form, entityList, entityName, loadLoading, handleAdd }: EntitiesProps) {

    return (
        <div className="grid grid-cols-1 gap-6" style={{ display: 'flow' }}>
            {entityList.map((item, i: number) => (
                <Entity key={i.toString()} index={i} entityName={entityName} >
                    {form(item, i)}
                </Entity>
            ))}

            <AddItem entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} count={entityList.length} />
        </div>
    );
}
 
----- Archivo: entity.tsx ----- 
// src/components/lib/entity.tsx
"use client";

import { Strings } from "@/utils/index";
import React from "react";

interface EntityProps {
    key: string;
    children: React.ReactNode;
    entityName: string;
    index: number;
}

export default function EntityComponent({ children, index, entityName }: EntityProps) {
    

    return (
        <fieldset
            key={index}
            className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 border rounded"
            style={{ display: 'flex', border: '1px solid #02659a', borderRadius: '10px', padding: '1rem' }} >
            <legend className="text-lg font-semibold" >
                <b style={{paddingLeft: '1rem', paddingRight: '1rem'}}>{Strings.titleCase(entityName)} #{index + 1}</b>
            </legend>
            {children}
        </fieldset>
    );
}
 
----- Archivo: entityFields.tsx ----- 
// src/components/lib/entityFields.tsx
"use client";

import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { FieldConfig } from "@/types/lib";
import { Dates } from "@/utils/index";
import React from "react";
import RemoveItemComponent from "./removeItem";


interface EntityFieldsProps<T extends { id: string | undefined }> {
    fieldsConfig: FieldConfig<T>[];
    item: T;
    index: number;
    loadLoading: boolean;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateItem: (index: number, field: keyof T, value: any) => void;
    handleRemove: (id: string | undefined) => void;
}

export default function EntityFieldsComponent<T extends { id: string | undefined }>({
    fieldsConfig,
    item,
    index,
    loadLoading,
    updateItem,
    handleRemove
}: EntityFieldsProps<T>) {

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const setValue = (type: 'text' | 'date', item: any, name: string | number | symbol): string | number | readonly string[] | undefined => {
        if (type == 'date') {
            return item[name] ? Dates.format(item[name]) : ''
        }
        return item[name] ?? "";
    }

    const { isMobile } = useDeviceDetect();

    const gridTemplateColumnsCalculateDesktopOrTablet = (count: number) => {
        switch (count) {
            case 5: return "repeat(3, 1fr)";
            case 4: return "repeat(3, 1fr)";
            case 3: return "repeat(4, 1fr)";
            case 2:
            default: return "repeat(3, 1fr)";
        }
    }

    // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
    const sectionGridStyle: React.CSSProperties = {
        display: "grid",
        gap: "1rem",
        gridTemplateColumns: isMobile
            ? "repeat(2, 1fr)"
            : gridTemplateColumnsCalculateDesktopOrTablet(fieldsConfig.length)
    };

    return (
        <div style={sectionGridStyle}>
            {fieldsConfig.map(({ label, name, type, mandatory, className }) => (
                <label key={`${String(name)}-${index}`} className={className}>
                    {label}
                    <input
                        type={type}
                        value={setValue(type, item, name)}
                        disabled={loadLoading}
                        onChange={(e) =>
                            updateItem(
                                index,
                                name,
                                type === "date"
                                    ? (e.target as HTMLInputElement).valueAsDate
                                    : (e.target as HTMLInputElement).value
                            )
                        }
                        required={mandatory}
                        className="w-full"
                    />
                </label>
            ))}
            <RemoveItemComponent id={item.id} loadLoading={loadLoading} handleRemove={handleRemove} />
        </div>
    );
}
 
----- Archivo: entityForm.tsx ----- 
// src/components/entityForm.tsx
"use client";

import React from "react";
import type { Dispatch, SetStateAction } from "react";
import { EntityFields, Form } from "@/components/index";
import { useLoadEntities } from "@/hooks/useLoadEntities";
import { useEntityList } from "@/hooks/useEntityList";
import { useEntitySubmit } from "@/hooks/useEntitySubmit";
import type { FieldConfig, StepsStateType } from "@/types/lib";

export interface EntityFormProps<T extends { id?: string }> {
  id: string;
  storedList: T[];
  setStoredList: (list: T[]) => void;
  data: T[];
  setData: Dispatch<SetStateAction<T[]>>;
  step: number;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<SetStateAction<StepsStateType[]>>;
  entityName: string;
  emptyFactory: (id: string) => Partial<T>;
  fieldsConfig: FieldConfig<T>[];
  onNext: () => void;
  onBack: () => void;
}

export default function EntityFormComponent<T extends { id: string | undefined }>({
  id,
  storedList,
  setStoredList,
  data,
  setData,
  step,
  stepStates,
  setStepStates,
  entityName,
  emptyFactory,
  fieldsConfig,
  onNext,
  onBack,
}: EntityFormProps<T>) {
  // 1) Carga los datos guardados
  const {
    list,
    setList,
    error: loadError,
    setError: setLoadError,
    loading: loadLoading,
  } = useLoadEntities<T>(
    id,
    entityName,
    storedList,
    setStoredList,
    data,
    setData,
    step,
    stepStates,
    setStepStates
  );

  // 2) Gestión de la lista en memoria (añadir, eliminar, editar)
  const { addItem, removeItem, updateItem } = useEntityList<T>(
    emptyFactory,
    id,
    setList,
    setLoadError,
    step,
    stepStates
  );

  // 3) Envío y validación
  const {
    submit,
    loading: submitLoading,
    error: submitError,
  } = useEntitySubmit<T>(
    id,
    list,
    entityName,
    setStoredList,
    setData,
    fieldsConfig,
    step,
    stepStates,
    setStepStates,
    loadError,
    setLoadError
  );

  // 4) Renderizado de campos dinámicos
  const renderFields = (item: T, index: number) => (
    <EntityFields<T>
      fieldsConfig={fieldsConfig}
      item={item}
      index={index}
      loadLoading={loadLoading}
      updateItem={updateItem}
      handleRemove={removeItem}
    />
  );

  return (
    <Form<T>
      entityList={list}
      step={step}
      totalSteps={stepStates.length}
      entityName={entityName}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      error={loadError || submitError}
      form={renderFields}
      onBack={onBack}
      handleAdd={addItem}
      handleSubmit={() => submit(onNext)}
    />
  );
}
 
----- Archivo: field.tsx ----- 
// src/components/lib/field.tsx
import { FieldType } from "@/types/lib";
import React from "react";

interface FieldsProps {
    field: FieldType;
} 

export default function FieldComponent(props: FieldsProps) {
    if (!props.field.show) {
        return <div></div>;
    }
    return (
        <div key={props.field.label} style={{ backgroundColor: "#fff", padding: "1rem", margin: '0.5rem', borderRadius: "0.5rem", boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
            <p style={{ fontSize: "0.75rem", color: "#6B7280", margin: 0 }}>{props.field.label}:</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}> {props.field.value}</p>
        </div>
    );
} 
----- Archivo: form.tsx ----- 
// src/components/form.tsx
"use client";
import React from "react";
import StepsComponent from "./steps";
import EntitiesComponent from "@/components/lib/entities";

interface FormProps<T extends { id: string | undefined }> {
    entityList: Partial<T>[];
    step: number;
    totalSteps: number;
    entityName: string;
    submitLoading: boolean;
    loadLoading: boolean;
    error: string | null;
    form: (entity: T , i: number) => React.JSX.Element
    onBack: () => void;
    handleAdd: () => void;
    handleSubmit: () => Promise<void>;
}

export default function FormComponent<T extends { id: string | undefined }>({ entityList, step, totalSteps, entityName, submitLoading, loadLoading, error, form, onBack, handleAdd, handleSubmit }: FormProps<T> ) {
    return (
        <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={totalSteps} error={error} >
            <EntitiesComponent form={form} entityList={entityList} entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} />
        </StepsComponent >
    );
}
 
----- Archivo: loading.tsx ----- 
// src/components/loading.tsx
import React from "react";
import { FaSpinner } from "react-icons/fa";

export default function LoadingComponent() {
  return (
    <div className="loading-container">
      <FaSpinner className="spinner" size={48} />
      <p>Cargando...</p>

      <style jsx>{`
        .loading-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          padding: 2rem;
          color: #6b7280; /* gris secundario */
        }
        .spinner {
          color: #3b82f6; /* azul primario */
          margin-bottom: 1rem;
          animation: spin 1s linear infinite;
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to   { transform: rotate(360deg); }
        }
        p {
          font-size: 1rem;
        }
      `}</style>
    </div>
  );
}
 
----- Archivo: modal.tsx ----- 
// app/components/lib/modal.tsx
"use client";
import React, { Dispatch, SetStateAction } from "react";
import { FaTimes } from "react-icons/fa";

interface ModalProps {
    children: React.ReactNode;
    title: string;
    description?: string;
    setShowModal: Dispatch<SetStateAction<boolean>>;
    maxWidth?: string;
    dropdownRef?: React.RefObject<HTMLDivElement | null>;
}

export default function ModalComponent({ children, title, description, setShowModal, maxWidth = "450px", dropdownRef }: ModalProps) {
    return (
        <div
            style={{
                position: "fixed",
                inset: 0,
                backgroundColor: "rgba(0,0,0,0.5)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 2000,
            }}
        >

            <div
                ref={dropdownRef}
                style={{
                    backgroundColor: "#fff",
                    borderRadius: "1rem",
                    padding: "2rem",
                    width: "90%",
                    maxWidth: maxWidth,
                    position: "relative",
                }}
            >

                    {/* Close button */}
                    <button
                        onClick={() => setShowModal(false)}
                        style={{
                            position: "absolute",
                            top: "0.5rem",
                            right: "0.5rem",
                            background: "none",
                            border: "none",
                            fontSize: "1rem",
                            cursor: "pointer",
                            color: '#000'
                        }}
                        aria-label="Cerrar modal"
                    >
                        <FaTimes />
                    </button>
                    <h2 className="modal-title">{title}</h2>
                    <p className="description">{description}</p>
                    {children}
                </div>
        </div >
    );
}
 
----- Archivo: page.tsx ----- 
// src/components/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { v4 } from "uuid";
import { Loading, DataNotFound, Display, Title } from "@/components/index";
import { ApiError, FormType } from "@/types/lib";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useSession } from "@/hooks/useSession";
import { getFetch } from "@/app/api";

export interface PageProps<T> {
    parentId: string,
    title: string;
    icon: React.JSX.Element;
    apiUrl: string;
    storedList: T[];
    setStoredList: (value: T[]) => void;
    /** Mapea cada ítem a un array de campos para Display */
    mapItemToFields: (item: T) => { label: string; show: boolean; value: string }[];
    emptyMessage: string;
}

const PageComponent = <T,>({
    parentId,
    title,
    icon,
    apiUrl,
    storedList,
    setStoredList,
    mapItemToFields,
    emptyMessage,
}: PageProps<T>) => {
    useSession();
    const { isMobile } = useDeviceDetect();
    const [items, setItems] = useState<T[] | null>(null);

    useEffect(() => {
        if (!parentId) return;
        const fetchData = async () => {
            try {
                let data: T[] = [];
                if (storedList.length == 0) {
                    const response = await getFetch(`${apiUrl}${parentId}`);
                    if(!response.ok) throw new ApiError(`Error llamando al api: ${apiUrl}${parentId}`);
                    const data = await response.json();
                    setItems(data);
                    setStoredList(data);
                }
                else {
                    data = storedList;
                    setItems(data);
                }
            } catch (err) {
                console.error(`Error cargando ${title.toLowerCase()}:`, err);
            }
        };
        fetchData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storedList]);

    const formItems: FormType[] = (items || []).map((item) => ({
        id: v4(),
        fields: mapItemToFields(item),
    }));

    return (
        <main style={{ padding: isMobile ? "2rem 1rem" : "2rem" }}>
            <Title icon={icon} title={title} />
            {items === null ? (
                <Loading />
            ) : items.length === 0 ? (
                <DataNotFound message={emptyMessage} />
            ) : (
                <Display formItems={formItems} isMobile={isMobile} />
            )}
        </main>
    );
};

export default PageComponent;
 
----- Archivo: removeItem.tsx ----- 
// app/components/lib/removeItem.tsx
import { FaTrash } from "react-icons/fa";

interface RemoveItemProps {
    id: string | undefined;
    loadLoading: boolean;
    handleRemove: (id: string | undefined) => void;
}

export default function RemoveItemComponent({ id, loadLoading, handleRemove }: RemoveItemProps) {
    return (
        <div className="flex flex-wrap gap-2" style={{ marginTop: '26px', alignContent: 'center' }}>
            <button
                type="button"
                onClick={() => handleRemove(id)}
                className="contrast"
                disabled={loadLoading}
            >
                <FaTrash />
            </button>
        </div>
    );
} 
----- Archivo: steps.tsx ----- 
// src/components/lib/steps.tsx
import React from 'react';

interface StepsProps {
  children: React.ReactNode;
  step: number;
  totalSteps: number;
  submitLoading: boolean;
  loadLoading: boolean;
  error: string | null;
  onNext: () => void;
  onBack: () => void;
}

export default function StepsComponent({ children, submitLoading, loadLoading, step, totalSteps, error, onNext, onBack }: StepsProps) {

  return (
    <>
      <div className="space-y-4">
        <div style={{ maxHeight: '500px', overflowY: 'auto', padding: '1rem', marginBottom: '1rem' }}>
          {children}
        </div>
        {error && (
          <p className="text-error">
            {error}
          </p>
        )}
        <div className="mt-4 flex justify-between">
          {step > 0 && (
            <button
              type="button"
              onClick={onBack}
              className="btn-secondary ml-auto"
              style={{ float: 'left' }}
            >
              Atrás
            </button>
          )}
          <button
            type="button"
            onClick={onNext}
            disabled={submitLoading || loadLoading}
            className="btn-primary"
            style={{ float: 'right' }}
          >
            {submitLoading ? "Guardando…" : (totalSteps - 1 == step ? "Finalizar" : "Siguiente")}
          </button>
        </div>
      </div>
    </>
  );
}
 
----- Archivo: title.tsx ----- 
// src/components/lib/title.tsx
interface TitleProps {
    icon: React.JSX.Element;
    title: string;
}

export default function TitleComponent(props: TitleProps) {
    return (
        <h3 style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            {props.icon} {props.title}
        </h3>
    );
} 
----- Archivo: AddPetModal.tsx ----- 
// src/components/modals/AddPetModal.tsx
"use client";

import React, { useState, Dispatch, SetStateAction, useEffect } from "react";
import ModalComponent from "../lib/modal";
import { EntityForm } from "@/components/index";

import { PetNameForm, BasicDataForm } from "@/components/forms";

import {
    emptyVaccine,
    emptyMedicine,
    emptyLabTest,
    emptyCondition,
    emptySurgery,
} from "@/utils/factories";

import {
    PetStep,
    PetType,
    BasicDataType,
    VaccineDataType,
    MedicineDataType,
    LabTestDataType,
    ConditionDataType,
    SurgeryDataType
} from "@/types/index";

import type { StepsStateType, StepConfig } from "@/types/lib";
import { Empty } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";

interface AddPetModalProps {
    editPet?: PetType
}

export default function AddPetModal({ editPet }: AddPetModalProps) {
    const session = useSessionContext();
    const storage = useStorageContext();
    const [step, setStep] = useState<PetStep>(PetStep.Name);
    const { showAddPetModal, setShowAddPetModal } = useUI();

    // Estados por entidad
    const [pet, setPet] = useState<PetType>(editPet == undefined ? Empty.Pet() : editPet);
    const [basicData, setBasicData] = useState<BasicDataType>(Empty.BasicData());
    const [vaccinesData, setVaccinesData] = useState<VaccineDataType[]>([]);
    const [medicinesData, setMedicinesData] = useState<MedicineDataType[]>([]);
    const [labTestsData, setLabTestsData] = useState<LabTestDataType[]>([]);
    const [conditionsData, setConditionsData] = useState<ConditionDataType[]>([]);
    const [surgeriesData, setSurgeriesData] = useState<SurgeryDataType[]>([]);
    const [stepStates, setStepStates] = useState<StepsStateType[]>(Empty.Steps());


    useEffect(() => {
        setStepStates(Empty.Steps());
    }, [showAddPetModal])

    // Validar sesión
    if (!session?.db?.user?.id) return null;
    const ownerId = session.db.user.id;

    const totalSteps = 7;
    const next = () => setStep(s => Math.min(s + 1, totalSteps - 1));
    const back = () => setStep(s => Math.max(s - 1, 0));
    const finalize = () => {
        if (!pet.id) return;
        pet.owner_id = ownerId;
        storage.setStoredOwnerPets([...(storage.storedOwnerPets ?? []), pet]);
        setShowAddPetModal(false);
        setStepStates(Empty.Steps());
    };

    // Configuración dinámica para los pasos que usan EntityForm
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const stepConfigs: Partial<Record<PetStep, StepConfig<any>>> = {
        [PetStep.Vaccines]: {
            entityName: "vacuna",
            storedList: storage.storedVaccineData,
            setStoredList: storage.setStoredVaccineData,
            emptyFactory: emptyVaccine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Lote *", name: "batch", type: "text", mandatory: true, className: "w-full" },
                { label: "Marca *", name: "brand", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Medicines]: {
            entityName: "medicina",
            storedList: storage.storedMedicineData,
            setStoredList: storage.setStoredMedicineData,
            emptyFactory: emptyMedicine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Dosis *", name: "dosage", type: "text", mandatory: true, className: "w-full" },
                { label: "Frecuencia *", name: "frequency", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.LabTests]: {
            entityName: "prueba",
            storedList: storage.storedLabTestData,
            setStoredList: storage.setStoredLabTestData,
            emptyFactory: emptyLabTest,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Tipo *", name: "type", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Resultado", name: "result", type: "text", className: "w-full" },
            ],
        },
        [PetStep.Conditions]: {
            entityName: "condición",
            storedList: storage.storedConditionData,
            setStoredList: storage.setStoredConditionData,
            emptyFactory: emptyCondition,
            fieldsConfig: [
                { label: "Condición *", name: "condition", type: "text", mandatory: true, className: "w-full" },
                { label: "Severidad *", name: "severity", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Surgeries]: {
            entityName: "cirugía",
            storedList: storage.storedSurgeryData,
            setStoredList: storage.setStoredSurgeryData,
            emptyFactory: emptySurgery,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
            ],
        },
    };

    // Mapeo de datos y setters por paso
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dataMap: Partial<Record<PetStep, [any[], Dispatch<SetStateAction<any[]>>]>> = {
        [PetStep.Vaccines]: [vaccinesData, setVaccinesData],
        [PetStep.Medicines]: [medicinesData, setMedicinesData],
        [PetStep.LabTests]: [labTestsData, setLabTestsData],
        [PetStep.Conditions]: [conditionsData, setConditionsData],
        [PetStep.Surgeries]: [surgeriesData, setSurgeriesData],
    };

    const renderStep = () => {
        switch (step) {
            case PetStep.Name:
                return (
                    <PetNameForm
                        ownerId={ownerId}
                        pet={pet}
                        setPet={setPet}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                    />
                );

            case PetStep.BasicData:
                return (
                    <BasicDataForm
                        pet={pet}
                        basicData={basicData}
                        setBasicData={setBasicData}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                    />
                );

            default: {
                // TS: usamos Partial y ! para asegurar que cfg y data existen
                const cfg = stepConfigs[step]!;
                const [items, setItems] = dataMap[step]!;

                return (
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    <EntityForm<any>
                        key={step}
                        id={pet.id!}
                        storedList={cfg.storedList}
                        setStoredList={cfg.setStoredList}
                        data={items}
                        setData={setItems}
                        step={step}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                        entityName={cfg.entityName}
                        emptyFactory={cfg.emptyFactory}
                        fieldsConfig={cfg.fieldsConfig}
                        onNext={step === PetStep.Surgeries ? finalize : next}
                        onBack={back}
                    />
                );
            }
        }
    };

    const stepTitle = () => {
        const titles: Record<PetStep, string> = {
            [PetStep.Name]: "Agrega tu mascota",
            [PetStep.BasicData]: `Datos básicos de ${pet.name}`,
            [PetStep.Vaccines]: `Información de vacunas de ${pet.name}`,
            [PetStep.Medicines]: `Información de medicamentos de ${pet.name}`,
            [PetStep.LabTests]: `Información de exámenes de ${pet.name}`,
            [PetStep.Conditions]: `Información de condiciones especiales de ${pet.name}`,
            [PetStep.Surgeries]: `Información de cirugías de ${pet.name}`,
        };
        return titles[step] || "";
    };

    return (
        <ModalComponent title={stepTitle()} setShowModal={setShowAddPetModal} maxWidth="1000px">
            {renderStep()}
        </ModalComponent>
    );
}
 
----- Archivo: Bubbles.tsx ----- 
// app/components/modals/Bubbles.tsx
"use client"
import React, { useEffect, useState } from "react";
import { FaShareAlt, FaCommentDots, FaUserMd, FaExchangeAlt } from "react-icons/fa";
import FeedbackModal from "./FeedbackModal";
import PetCodeModal from "./PetCodeModal";
import VeterinaryModal from "./VeterinaryModal";
import ChangePetModal from "./ChangePetModal";
import AddPetModal from "./AddPetModal";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useRoleContext } from "@/context/RoleProvider";
import VeterinarianPetCodeModal from "./VeterinarianPetCodeModal";

const bubbleStyleBase: React.CSSProperties = {
  backgroundColor: "#ffffff",
  border: "1px solid rgb(1, 114, 173)",
  borderRadius: "50%",
  width: "3rem",
  height: "3rem",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  color: "rgb(1, 114, 173)",
  fontSize: "1.25rem",
  cursor: "pointer",
};

export default function Bubbles() {

  const [showChangePetBubble, setShowChangePetBubble] = useState(false);
  const { isOwner, isVet } = useRoleContext();

  const storage = useStorageContext();

  const { setShowFeedbackModal,
    showFeedbackModal,
    setShowVetModal,
    showVetModal,
    setShowCodeModal,
    showCodeModal,
    setShowChangePetModal,
    showChangePetModal,
    showAddPetModal,
    showEditPetModal,
    setShowVetPetCodeModal,
    showVetPetCodeModal
  } = useUI();

  useEffect(() => {
    const show = (storage.storedOwnerPets.length ?? 0) > 0;
    setShowChangePetBubble(show);
  }, [storage.storedOwnerPets]);

  return (
    <div
      style={{
        position: "fixed",
        right: "1rem",
        bottom: "1rem",
        display: "flex",
        flexDirection: "column",
        gap: "1rem",
        zIndex: 1500,
      }}
    >
      {/* Feedback Bubble */}
      <div className="tooltip-container" draggable>
        <button
          onClick={() => setShowFeedbackModal(true)}
          style={bubbleStyleBase}
          aria-label="Feedback"
        >
          <FaCommentDots />
        </button>
        <span className="tooltip-text tooltip-left">Enviar feedback</span>
      </div>

      {/* Vet Bubble */}
      {isOwner && !isVet &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Soy médico veterinario</span>
        </div>
      }

      {/* Vet Bubble */}
      {isVet &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetPetCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Ingresar código de una mascota</span>
        </div>
      }

      {/* Code Bubble */}
      {isOwner && !isVet &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Código único"
          >
            <FaShareAlt />
          </button>
          <span className="tooltip-text tooltip-left">Genera un código único para tu veterinario</span>
        </div>
      }

      {/* Change Pet Bubble */}
      {showChangePetBubble &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowChangePetModal(true)}
            style={bubbleStyleBase}
            aria-label="Cambia de mascota"
          >
            <FaExchangeAlt />
          </button>
          <span className="tooltip-text tooltip-left">Cambia de mascota</span>
        </div>
      }

      {/* Modals */}
      {showChangePetModal && <ChangePetModal />}
      {showVetModal && <VeterinaryModal />}
      {showCodeModal && <PetCodeModal />}
      {showFeedbackModal && <FeedbackModal />}
      {showAddPetModal && <AddPetModal />}
      {showEditPetModal && <AddPetModal editPet={storage.storedPet} />}
      {showVetPetCodeModal && <VeterinarianPetCodeModal />}
    </div>
  );
}
 
----- Archivo: ChangePetModal.tsx ----- 
// app/components/modals/ChangePetModal.tsx
"use client";
import React, {
  useState,
  useRef,
  useEffect,
} from "react";
import { FaChevronDown, FaChevronUp, FaPlus } from "react-icons/fa";
import { PetType } from "@/types/index";
import ModalComponent from "../lib/modal";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index"
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";

export default function ChangePetModal() {
  const storage = useStorageContext();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { setShowChangePetModal, setShowAddPetModal } = useUI();

  // close dropdown if you click outside
  useEffect(() => {
    const handleClickOutside = (ev: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(ev.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () =>
      document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleSelect = (pet: PetType) => {
    storage.resetPet();
    storage.setStoredPet(pet);
    setIsOpen(false);
    setShowChangePetModal(false);
    storage.setStoredVetAccess(Empty.VetAccess());
  };

  const addPet = () => {
    setShowChangePetModal(false);
    setShowAddPetModal(true);
  };

  return (
    <ModalComponent title="Selecciona la mascota" description="Visualiza la información de la mascota seleccionada" setShowModal={setShowChangePetModal} dropdownRef={dropdownRef}>
      {/* Custom dropdown */}
      <div style={{ position: "relative", marginTop: "1rem" }}>
        <button
          type="button"
          onClick={() => setIsOpen((o) => !o)}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "0.5rem 1rem",
            borderRadius: "0.5rem",
            border: "1px solid #ccc",
            background: "#fff",
          }}
        >
          <div style={{ display: "flex", alignItems: "center" }}>
            <CircularImage
              src={storage.storedPet.image || "/pets/pet.jpg"}
              width={60}
              borderSize="3px" />
            <span style={{ color: '#000', marginLeft: '10px' }}>
              {storage.storedPet.name ?? "Selecciona una mascota"}
            </span>
          </div>
          {isOpen ? <FaChevronUp /> : <FaChevronDown />}
        </button>

        {isOpen && (
          <ul
            style={{
              position: "absolute",
              top: "100%",
              left: 0,
              right: 0,
              background: "#fff",
              border: "1px solid #ccc",
              borderRadius: "0.5rem",
              maxHeight: 200,
              overflowY: "auto",
              marginTop: "0.25rem",
              zIndex: 2010,
              padding: 0,
              listStyle: "none",
            }}
          >
            {storage.storedOwnerPets.map((pet: PetType) => (
              <li
                className="pet-selection"
                key={pet.id}
                onClick={() => handleSelect(pet)}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "0.5rem 1rem",
                  cursor: "pointer",
                }}
              >
                <CircularImage
                  src={pet.image || "/pets/pet.jpg"}
                  width={50}
                  borderSize="3px" />
                <span style={{ color: '#000', marginLeft: '8px' }}>{pet.name}</span>
              </li>
            ))}
            <li
              className="pet-selection"
              onClick={addPet}
              style={{
                display: "flex",
                alignItems: "center",
                padding: "0.5rem 1rem",
                cursor: "pointer",
              }}>
              <FaPlus />
              <span style={{ color: '#000', marginLeft: '20px' }}>Agregar mascota</span>
            </li>
          </ul>
        )}

      </div>
    </ModalComponent>
  );
}
 
----- Archivo: FeedbackModal.tsx ----- 
// app/components/modals/FeedbackModal.tsx
"use client";
import React, { useState } from "react";
import ModalComponent from "../lib/modal";
import { postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";


export default function FeedbackModal() {
  const [feedback, setFeedback] = useState("");
  const [sending, setSending] = useState(false);
  const [isAnonymous, setIsAnonymous] = useState(false);
  const session = useSessionContext();
  const { setShowFeedbackModal } = useUI();

  const sendFeedback = async (anonymous: boolean) => {
    if (!feedback.trim()) return;
    setSending(true);

    try {
      const res = await postFetch(`/api/feedback`, undefined, { feedback, anonymous, userEmail: session?.db?.user.email });
      if (!res.ok) throw new Error("Error en el servidor");
      alert("¡Gracias por tu opinión!");
      setShowFeedbackModal(false);
    } catch (err) {
      console.error(err);
      alert("Ocurrió un error al enviar tu mensaje.");
      setSending(false);
    }
  };

  return (
    <ModalComponent title="Queremos leerte" description="Cuéntanos tu experiencia con Lampo o sobre tu mascota" setShowModal={setShowFeedbackModal}>
      <textarea
        value={feedback}
        onChange={(e) => setFeedback(e.target.value)}
        style={{
          width: "100%",
          minHeight: "4rem",
          padding: "0.5rem",
          borderRadius: "0.5rem",
          border: "1px solid #ccc",
          marginTop: "0.75rem",
        }}
        disabled={sending}
      />

      {/* Checkbox para envío anónimo */}
      <label style={{ display: "flex", alignItems: "center", marginTop: "0.75rem" }}>
        <input
          type="checkbox"
          checked={isAnonymous}
          onChange={(e) => setIsAnonymous(e.target.checked)}
          disabled={sending}
          style={{ marginRight: "0.5rem" }}
        />
        Enviar de forma anónima
      </label>

      <div style={{ display: "flex", gap: "0.5rem", marginTop: "1rem" }}>
        <button
          onClick={() => sendFeedback(isAnonymous)}
          style={{ flex: 1 }}
          disabled={sending || !feedback.trim()}
        >
          {sending ? "Enviando..." : "Enviar"}
        </button>
      </div>
    </ModalComponent>
  );
}
 
----- Archivo: PetCodeModal.tsx ----- 
// app/components/modals/PetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { FaShareAlt, FaCopy } from "react-icons/fa";
import ModalComponent from "../lib/modal";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { postFetch } from "@/app/api";
import { useUI } from "@/context/UIProvider";

export default function PetCodeModal() {
  const [code, setCode] = useState("");
  const [show, setShow] = useState(false);
  const [error, setError] = useState("");
  const [copied, setCopied] = useState(false);
  const session = useSessionContext();
  const storage = useStorageContext();
  const { setShowCodeModal } = useUI();

  async function generar() {
    setError("");
    try {
      const res = await postFetch('/api/pets/me/code', undefined, { owner_id: session?.db?.user.id, pet_id: storage.storedPet.id });

      if (res.status === 404) {
        setError("No se encontró la mascota.");
        return;
      }
      if (!res.ok) {
        setError("Error al generar el código.");
        return;
      }

      const json = await res.json();
      if (json.code) {
        setCode(json.code);
        setShow(true);
        setCopied(false);
      } else {
        setError("Respuesta inválida del servidor.");
      }
    } catch (e) {
      console.error(e);
      setError("Ocurrió un error al generar el código.");
    }
  }

  const handleCopy = () => {
    navigator.clipboard.writeText(code).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
  };

  return (
    <ModalComponent title="Generar código" setShowModal={setShowCodeModal}>

      {!show &&
        <p style={{ fontSize: "0.8rem" }}>
          Este es un código dinámico de acesso para que tu veterinario pueda editar la información clínica de tu mascota.
        </p>
      }

      {error && (
        <p style={{ color: "red", marginBottom: "0.5rem", fontSize: "0.9rem" }}>
          {error}
        </p>
      )}

      {show && (
        <>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              marginBottom: "0.5rem",
            }}
          >
            {code.split("").map((char, idx) => (
              <span
                key={idx}
                style={{
                  display: "inline-block",
                  width: "2rem",
                  padding: "0.5rem 0",
                  border: "1px solid #ccc",
                  borderRadius: "0.25rem",
                  color: "#007BFF",
                  fontWeight: "bold",
                  textAlign: "center",
                  fontFamily: "monospace",
                }}
              >
                {char}
              </span>
            ))}

            <button
              onClick={handleCopy}
              style={{
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: "0.5rem",
              }}
              title="Copiar código"
            >
              <FaCopy size={20} color={copied ? "green" : "#007BFF"} />
            </button>
          </div>

          {copied && (
            <p style={{ color: "green", marginBottom: "0.5rem", fontSize: "0.8rem" }}>
              ¡Código copiado!
            </p>
          )}

          <p style={{ fontSize: "0.8rem" }}>
            Este código es único para cada mascota. Compártelo con tu médico veterinario para brindarle acceso al historial.
          </p>

        </>
      )}

      {!show &&
        <button
          onClick={generar}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "0.5rem",
            marginTop: "1rem",
          }}
        >
          <FaShareAlt size={20} /> Generar
        </button>
      }
    </ModalComponent>
  );
}
 
----- Archivo: VeterinarianPetCodeModal.tsx ----- 
// src/components/modals/VeterinarianPetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { useRouter } from "next/navigation";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { useVetContext } from "@/context/VetContext";
import { useUI } from "@/context/UIProvider";

export default function VeterinarianPetCodeModal() {
    const router = useRouter();
    const { vet } = useVetContext();
    const { setShowVetPetCodeModal } = useUI();

    const storage = useStorageContext();

    const [code, setCode] = useState("");
    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    if (!vet) {
        return;
    }

    const handleSubmit = async () => {
        setError("");
        const sanitizedCode = code.trim().toUpperCase();
        if (!sanitizedCode) {
            setError("Por favor ingresa el código de la mascota.");
            return;
        }
        setLoading(true);

        try {
            // Envío de código junto con datos ocultos del veterinario
            const vetPayload = {
                code: sanitizedCode,
                firstName: vet.first_name,
                lastName: vet.last_name,
                registration: vet.registration,
                clinicName: vet.clinic_name,
                city: vet.city
            };
            const res = await postFetch("/api/vet/use-code", undefined, vetPayload);
            const data = await res.json();

            if (!res.ok || data.error) {
                setError(data.error || "Código inválido o expirado.");
            } else {
                // Obtener datos de la mascota y almacenar
                const petRes = await getFetch(`/api/pets/${data.pet_id}`);
                if (!petRes.ok) {
                    setError("No se encontró la mascota.");
                } else {
                    const petData = await petRes.json();
                    storage.setStoredPet(petData);
                    storage.setStoredOwnerPets([]);
                    storage.setStoredVetAccess({
                        id: data.vet_access,
                        pet_id: petData.id,
                        pet_code_id: data.pet_code,
                        vet_first_name: vet.first_name,
                        vet_last_name: vet.last_name,
                        professional_registration: vet.registration,
                        clinic_name: vet.clinic_name,
                        city: vet.city
                    });
                    setShowVetPetCodeModal(false);
                    router.push(`/pages/vet/${sanitizedCode}`);
                }
            }
        } catch {
            setError("Ocurrió un error inesperado.");
        } finally {
            setLoading(false);
        }
    };

    return (
        <ModalComponent
            title="Acceder a mascota"
            description="Solo ingresa el código de la mascota para acceder a su historial"
            setShowModal={setShowVetPetCodeModal}
        >
            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    handleSubmit();
                }}
            >
                {/* Inputs ocultos con datos del veterinario */}
                <input type="hidden" name="firstName" value={vet.first_name} />
                <input type="hidden" name="lastName" value={vet.last_name} />
                <input type="hidden" name="registration" value={vet.registration} />
                <input type="hidden" name="clinicName" value={vet.clinic_name} />
                <input type="hidden" name="city" value={vet.city} />

                {/* Input visible para el código */}
                <label className="label">
                    Código de la mascota
                    <input
                        type="text"
                        className="input"
                        value={code}
                        onChange={(e) => setCode(e.target.value)}
                        placeholder="e.g. U8Y499"
                        required
                    />
                </label>

                {error && <p className="error">{error}</p>}

                <button
                    type="submit"
                    className="submit-btn"
                    disabled={loading}
                >
                    {loading ? "Validando..." : "Acceder"}
                </button>
            </form>
        </ModalComponent>
    );
}
 
----- Archivo: VeterinaryModal.tsx ----- 
// app/components/modals/VeterinaryModal.tsx
"use client";
import React, { useState } from "react";
import { useRouter } from "next/navigation";
import { veterinaryStyles } from "../../styles/veterinary";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";


export default function VeterinaryModal() {
  const [code, setCode] = useState("");
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const storage = useStorageContext();
  const { setShowVetModal } = useUI();

  const handleSubmit = async () => {
    setError("");
    const sanitizedCode = code.replaceAll(" ", "").toUpperCase();
    if (![sanitizedCode, firstName, lastName, registration, clinicName, city].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }
    setLoading(true);

    try {
      const codeResponse = await postFetch(
        '/api/vet/use-code',
        undefined,
        {
          code: sanitizedCode,
          firstName,
          lastName,
          registration,
          clinicName,
          city
        }
      );
      const codeData = await codeResponse.json();

      if (!codeResponse.ok || codeData.error) {
        setError(codeData.error || "Código inválido o expirado.");
      } else {
        const petResponse = await getFetch(`/api/pets/${codeData.pet_id}`);

        if (!petResponse.ok) {
          setError("No se encontró la mascota.");
        }
        const petData = await petResponse.json();
        storage.setStoredPet(petData);
        storage.setStoredOwnerPets([]);

        storage.setStoredVetAccess({
          id: codeData.vet_access,
          pet_id: petData.id,
          pet_code_id: codeData.pet_code,
          vet_first_name: codeData.firstName,
          vet_last_name: codeData.lastName,
          professional_registration: codeData.registration,
          clinic_name: codeData.clinicName,
          city: codeData.city
        });
        setShowVetModal(false);
        router.push(`/pages/vet/${sanitizedCode}`);
      }
    } catch {
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <ModalComponent title="Soy médico veterinario" description="Aquí puedes revisar el historial completo, modificarlo y agregar entradas
        a la historia de la mascota" setShowModal={setShowVetModal} maxWidth="1000px">

      <div className="form-grid" style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
        <div>
          <h4 className="label">Nombre</h4>
          <input
            className="input"
            type="text"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Nombre"
          />
        </div>

        <div>
          <h4 className="label">Apellido</h4>
          <input
            className="input"
            type="text"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Apellido"
          />
        </div>

        <div>
          <h4 className="label">Registro profesional</h4>
          <input
            className="input"
            type="text"
            value={registration}
            onChange={(e) => setRegistration(e.target.value)}
            placeholder="Número de registro"
          />
        </div>

        <div>
          <h4 className="label">Clínica / Laboratorio</h4>
          <input
            className="input"
            type="text"
            value={clinicName}
            onChange={(e) => setClinicName(e.target.value)}
            placeholder="Nombre de la clínica"
          />
        </div>

        <div>
          <h4 className="label">Ciudad</h4>
          <input
            className="input"
            type="text"
            value={city}
            onChange={(e) => setCity(e.target.value)}
            placeholder="Ciudad"
          />
        </div>

        <div>
          <h4 className="label">Código de la mascota</h4>
          <input
            className="input-code"
            type="text"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            placeholder="e.g. U8Y499"
          />
        </div>
      </div>

      {error && <p className="error">{error}</p>}

      <button
        className="submit-btn"
        onClick={handleSubmit}
        disabled={loading}
      >
        {loading ? "Guardando..." : "Acceder"}
      </button>

      <style jsx>{veterinaryStyles}</style>
    </ModalComponent>
  );
}
 
----- Archivo: StorageContextType.ts ----- 
// src/context/storageType.ts
 
----- Archivo: AppContextProvider.tsx ----- 
// src/context/AppContext.tsx

import { StorageProvider } from "./StorageProvider";
import { UIProvider } from "./UIProvider";
import { OwnerSessionProvider } from "./OwnerSessionProvider";
import { SessionProvider } from "./SessionProvider";
import { RoleProvider } from "./RoleProvider";
import { VetProvider } from "./VetContext";

export function AppContextProvider({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      <UIProvider>
        <StorageProvider>
          <RoleProvider>
            <OwnerSessionProvider>
              <VetProvider>
                {children}
              </VetProvider>
            </OwnerSessionProvider>
          </RoleProvider>
        </StorageProvider>
      </UIProvider>
    </SessionProvider>
  );
}
 
----- Archivo: ClientAppProvider.tsx ----- 
// components/layout/ClientAppProvider.tsx
"use client";
import React from "react";
import { AppContextProvider } from "@/context/AppContextProvider";
import { Bubbles, SideBar } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { isVetWithoutUserSession } from "@/utils/roles";
import LoadingComponent from "@/components/lib/loading";
import { usePathname } from "next/navigation";
import { useStorageContext } from "./StorageProvider";
import useAuthRedirect from "@/hooks/useAuthRedirect";
import { useSessionContext } from "./SessionProvider";

interface Props {
    children: React.ReactNode;
}

export default function ClientAppProvider({ children }: Props) {
    useAuthRedirect();

    const { isMobile, isDesktop } = useDeviceDetect();
    const session = useSessionContext();                      // undefined | null | AppSession
    const { storedVetAccess } = useStorageContext();
    const pathname = usePathname();

    const isLoginRoute = pathname === "/login" || pathname.endsWith("/login");
    const isVetRoute = pathname.startsWith("/vet-access");

    // No envolver con sidebar en login o vet-access
    if (isLoginRoute || isVetRoute) {
        return <>{children}</>;
    }

    // Mostrar loader mientras carga la sesión
    if (session === undefined) {
        return <LoadingComponent />;
    }

    // Si no hay sesión, bloquear render hasta redirect
    if (session === null) {
        return null;
    }

    // Si es vet-user con sesión y no está en vet-access, bloquear hasta redirect
    const isVetUserNow = isVetWithoutUserSession(session, storedVetAccess);
    if (isVetUserNow) {
        return null;
    }

    const gridCols = isMobile ? "1fr" : "300px 1fr";


    return (
        <AppContextProvider>
            <div
                className="container grid"
                style={{
                    gridTemplateColumns: gridCols,
                    minHeight: "100vh",
                    transition: "grid-template-columns 0.3s ease",
                    backgroundColor: "#F9FAFB",
                    fontFamily: "'Inter', sans-serif",
                    marginLeft: '2%',
                }}
            >
                <SideBar />
                <Bubbles />
                <main
                    style={{
                        padding: "3rem",
                        marginLeft: isMobile ? "1rem" : isDesktop ? "5rem" : "2rem",
                        width: isMobile ? "100%" : isDesktop ? "107%" : "247%",
                    }}
                >
                    {children}
                </main>
            </div>
        </AppContextProvider>
    );
}
 
----- Archivo: OwnerSessionProvider.tsx ----- 
// context/OwnerSessionProvider.tsx
"use client";
import React, { useEffect } from "react";
import { Empty } from "@/data/index";
import { ApiError } from "@/types/lib";
import type { PetType } from "@/types/index";
import { getFetch } from "@/app/api";
import { useStorageContext } from "./StorageProvider";
import { useSessionContext } from "./SessionProvider";
import { useUI } from "./UIProvider";
import { useRoleContext } from "./RoleProvider";

export const OwnerSessionProvider = ({ children }: { children: React.ReactNode }) => {
    const session = useSessionContext();
    const storage = useStorageContext();
    const { setShowAddPetModal } = useUI();
    const { isOwner } = useRoleContext();
    const ownerId = session?.db?.user?.id;

    useEffect(() => {
        if (!session.db || !ownerId) return;

        (async () => {
            if (isOwner) {
                if (storage.storedOwnerPets.length === 0) {
                    const response = await getFetch(`/api/owners/pets/${ownerId}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener las mascotas del dueño: ${ownerId}`);
                    const data = await response.json();
                    storage.setStoredOwnerPets(data as PetType[]);
                }
            }

        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session, ownerId]);

    useEffect(() => {
        let initialPet = Empty.Pet();
        if (storage.storedOwnerPets.length > 0) initialPet = storage.storedOwnerPets[0];
        if (storage.storedPet.id) initialPet = storage.storedPet;
        if (JSON.stringify(initialPet) !== JSON.stringify(storage.storedPet)) {
            storage.setStoredPet(initialPet);
        }
        if (!initialPet.id) {
            setShowAddPetModal(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedOwnerPets])

    return <>{children}</>;
} 
----- Archivo: RoleProvider.tsx ----- 
// src/context/RoleProvider.tsx
"use client";
import { useRole } from "@/hooks/useRole";
import { createContext, useContext } from "react";

export const Role = createContext({} as ReturnType<typeof useRole>);
export const useRoleContext = () => useContext(Role);

export function RoleProvider({ children }: { children: React.ReactNode }) {
    const storage = useRole();
    return <Role.Provider value={storage}>{children}</Role.Provider>;
} 
----- Archivo: SessionProvider.tsx ----- 
// src/context/SessionProvider.tsx
"use client";
import { createContext, useContext } from "react";
import { useSession } from "@/hooks/useSession";
import { AppSession } from "@/types/lib";

const SessionContext = createContext({} as AppSession);

export const useSessionContext = () => useContext(SessionContext);

export function SessionProvider({ children }: { children: React.ReactNode }) {
    const session = useSession();
    return (
        <SessionContext.Provider value={{ db: session }}>
            {children}
        </SessionContext.Provider>
    );
} 
----- Archivo: StorageProvider.tsx ----- 
// src/context/PetStorageProvider.tsx
"use client";
import { useAppStorage } from "@/hooks/useAppStorage";
import { createContext, useContext } from "react";

export const Petstorage = createContext({} as ReturnType<typeof useAppStorage>);
export const useStorageContext = () => useContext(Petstorage);

export function StorageProvider({ children }: { children: React.ReactNode }) {
    const storage = useAppStorage();
    return <Petstorage.Provider value={storage}>{children}</Petstorage.Provider>;
} 
----- Archivo: UIProvider.tsx ----- 
// src/context/UIProvider.tsx
"use client";
import { useState, createContext, useContext } from "react";

export interface UIState {
    showVetModal: boolean;
    setShowVetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showCodeModal: boolean;
    setShowCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
    showFeedbackModal: boolean;
    setShowFeedbackModal: React.Dispatch<React.SetStateAction<boolean>>;
    showChangePetModal: boolean;
    setShowChangePetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showAddPetModal: boolean;
    setShowAddPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showEditPetModal: boolean;
    setShowEditPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showVetPetCodeModal: boolean;
    setShowVetPetCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
}

const UIContext = createContext({} as UIState);
export const useUI = () => useContext(UIContext);

export function UIProvider({ children }: { children: React.ReactNode }) {
    const [showVetModal, setShowVetModal] = useState(false);
    const [showCodeModal, setShowCodeModal] = useState(false);
    const [showFeedbackModal, setShowFeedbackModal] = useState(false);
    const [showChangePetModal, setShowChangePetModal] = useState(false);
    const [showAddPetModal, setShowAddPetModal] = useState(false);
    const [showEditPetModal, setShowEditPetModal] = useState(false);
    const [showVetPetCodeModal, setShowVetPetCodeModal] = useState(false);

    return (
        <UIContext.Provider value={{
            showVetModal,
            setShowVetModal,
            showCodeModal,
            setShowCodeModal,
            showFeedbackModal,
            setShowFeedbackModal,
            showChangePetModal,
            setShowChangePetModal,
            showAddPetModal,
            setShowAddPetModal,
            showEditPetModal,
            setShowEditPetModal,
            showVetPetCodeModal,
            setShowVetPetCodeModal
        }}>
            {children}
        </UIContext.Provider>
    );
}
 
----- Archivo: VetContext.tsx ----- 
// src/context/VetContext.tsx
"use client";
import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { getFetch } from "@/app/api";
import type { VeterinarianType } from "@/types/index";
import { useSessionContext } from "./SessionProvider";
import { useRoleContext } from "./RoleProvider";
import { useUI } from "./UIProvider";
import { useStorageContext } from "./StorageProvider";

interface VetContextType {
    vet: VeterinarianType | null;
    loading: boolean;
    refresh: () => Promise<void>;
}

// Contexto para proveer datos del veterinario autenticado
export const VetContext = createContext<VetContextType | undefined>(undefined);

interface VetProviderProps {
    children: ReactNode;
}

export function VetProvider({ children }: VetProviderProps) {
    const session = useSessionContext();
    const [vet, setVet] = useState<VeterinarianType | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const { isVetWithSession } = useRoleContext();
    const { setShowVetPetCodeModal } = useUI();
    const storage = useStorageContext();

    // Función para obtener datos del veterinario desde API
    const fetchVet = async () => {
        setLoading(true);
        try {
            if (isVetWithSession) {
                if (!session?.db?.user?.id) {
                    setVet(null);
                    return;
                }
                const res = await getFetch(`/api/vet/${session.db?.user.id}`);
                if (!res.ok) {
                    console.error("Error fetching veterinarian profile");
                    setVet(null);
                } else {
                    const data: VeterinarianType = await res.json();
                    storage.setStoredVetData(data);
                    setVet(data);
                }
                if (!storage.storedVetAccess.id) {
                    setShowVetPetCodeModal(true);
                }
            }
        } catch (error) {
            console.error(error);
            setVet(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchVet();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session]);

    return (
        <VetContext.Provider value={{ vet, loading, refresh: fetchVet }}>
            {children}
        </VetContext.Provider>
    );
}

// Hook para consumir el contexto de veterinario
export function useVetContext(): VetContextType {
    const context = useContext(VetContext);
    if (!context) {
        throw new Error("useVetContext debe usarse dentro de un VetProvider");
    }
    return context;
} 
----- Archivo: empty.ts ----- 
import { StepsStateType, StepStateEnum } from "@/types/lib";
import { PetType, PetCodeType, OwnerDataType, BasicDataType, VaccineDataType, SurgeryDataType, MedicineDataType, ConditionDataType, LabTestDataType, VeterinaryAccessType, FeatureType, PlanType, PlanVersionType, SubscriptionType, PetStep, VeterinarianType } from "@/types/index";
import { ConditionRepository, LabTestRepository, MedicineRepository, SurgeryRepository, VaccineRepository } from "../repositories";
import { BasicDataTypeSchema, ConditionDataTypeSchema, LabTestDataTypeSchema, MedicineDataTypeSchema, PetTypeSchema, SurgeryDataTypeSchema, VaccineDataTypeSchema } from "@/schemas/validationSchemas";

export function Pet(): PetType { return { id: '', name: '', image: '', owner_id: '' } };

export function PetCode(): PetCodeType { return { id: '', pet_id: '', code: '', used: false, expires_at: '' } };

export function OwnerData(): OwnerDataType {
    return {
        owner_id: '',
        name: '',
        last_name: '',
        phone: '',
        address: '',
        city: '',
        country: '',
        email: ''
    }
};
export function BasicData(): BasicDataType {
    return {
        pet_id: '',
        pet_type: '',
        gender: '',
        weight: '0 Kg',
        race: '',
        has_allergies: false,
        weight_condition: '',
        size: '',
        lives_with_others: false,
        main_food: '',
        has_vaccine: false,
        last_vaccine_name: undefined,
        last_vaccine_date: undefined,
        is_castrated: false,
        castration_date: undefined,
        has_anti_flea: false,
        anti_flea_date: undefined,
        uses_medicine: false,
        special_condition: false
    }
};
export function VaccineData(): VaccineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        description: undefined,
        date: undefined,
        batch: '',
        brand: ''
    }
};
export function SurgeryData(): SurgeryDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        date: undefined,
        description: undefined
    }
};
export function MedicineData(): MedicineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        dosage: '',
        frequency: ''
    }
};
export function ConditionData(): ConditionDataType {
    return {
        id: '',
        pet_id: '',
        condition: '',
        severity: ''
    }
};
export function LabTestData(): LabTestDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        type: '',
        date: undefined,
        result: undefined
    }
};
export function VeterinaryAccess(): VeterinaryAccessType {
    return {
        id: '',
        pet_id: '',
        pet_code_id: '',
        vet_first_name: '',
        vet_last_name: '',
        professional_registration: '',
        clinic_name: '',
        city: '',
        created_at: ''
    }
};
export function Feature(): FeatureType {
    return {
        text: '',
        badge: ''
    }
};
export function Plan(): PlanType {
    return {
        id: 0,
        slug: ''
    }
};
export function PlanVersion(): PlanVersionType {
    return {
        id: 0,
        plan_id: 0,
        slug: '',
        version: 0,
        title: '',
        description: '',
        price_month: 0,
        price_year: 0,
        discount_month: 0,
        discount_year: 0,
        features: [],
        effective_from: '',
        effective_to: null,
        plans: {
            id: 0,
            slug: ''
        }
    }
};
export function Subscription(): SubscriptionType {
    return {
        id: 0,
        owner_id: '',
        plan_version_id: 0,
        cycle: 'monthly',
        status: 'pending',
        external_id: null,
        price_at_purchase: 0,
        discount_applied: 0,
        started_at: '',
        expires_at: null,
        updated_at: ''
    }
};

export function VetAccess(): VeterinaryAccessType {
    return {
        id: '',
        pet_id: '',
        pet_code_id: '',
        vet_first_name: '',
        vet_last_name: '',
        professional_registration: '',
        clinic_name: '',
        city: '',
        created_at: ''
    }
}

export function VetData(): VeterinarianType {
    return {
        vet_id: '',
        first_name: '',
        last_name: '',
        email: '',
        registration: '',
        clinic_name: '',
        city: ''
    }
}

export function Steps(): StepsStateType[] {
    return [
        { step: PetStep.Name, state: StepStateEnum.NotInitialize, schema: PetTypeSchema },
        { step: PetStep.BasicData, state: StepStateEnum.NotInitialize, schema: BasicDataTypeSchema },
        { step: PetStep.Vaccines, state: StepStateEnum.NotInitialize, schema: VaccineDataTypeSchema, url: '/api/pets/list/vaccines/', repository: new VaccineRepository() },
        { step: PetStep.Medicines, state: StepStateEnum.NotInitialize, schema: MedicineDataTypeSchema, url: '/api/pets/list/medicines/', repository: new MedicineRepository() },
        { step: PetStep.LabTests, state: StepStateEnum.NotInitialize, schema: LabTestDataTypeSchema, url: '/api/pets/list/lab-tests/', repository: new LabTestRepository() },
        { step: PetStep.Conditions, state: StepStateEnum.NotInitialize, schema: ConditionDataTypeSchema, url: '/api/pets/list/conditions/', repository: new ConditionRepository() },
        { step: PetStep.Surgeries, state: StepStateEnum.NotInitialize, schema: SurgeryDataTypeSchema, url: '/api/pets/list/surgeries/', repository: new SurgeryRepository() }
    ];
}

import { Empty } from "../data";

export function emptyStorage() {
    return {
        resetSession: () => { },
        resetPet: () => { },
        storedPet: Empty.Pet(),
        setStoredPet: () => { },
        storedBasicData: Empty.BasicData(),
        setStoredBasicData: () => { },
        storedOwnerData: Empty.OwnerData(),
        setStoredOwnerData: () => { },
        storedVetData: Empty.VetData(),
        setStoredVetData: () => { },
        storedVetAccess: Empty.VetAccess(),
        setStoredVetAccess: () => { },
        storedPetCode: Empty.PetCode(),
        setStoredPetCode: () => { },
        storedOwnerPets: [],
        setStoredOwnerPets: () => { },
        storedVaccineData: [],
        setStoredVaccineData: () => { },
        storedConditionData: [],
        setStoredConditionData: () => { },
        storedLabTestData: [],
        setStoredLabTestData: () => { },
        storedMedicineData: [],
        setStoredMedicineData: () => { },
        storedSurgeryData: [],
        setStoredSurgeryData: () => { }
    }
} 
----- Archivo: entityFieldData.ts ----- 
import { ConditionDataType, LabTestDataType, SurgeryDataType, VaccineDataType } from "@/types/index";
import { Dates } from "@/utils/index";

export function ForConditions(condition: ConditionDataType) {
    return [
        { label: "Condición", show: true, value: condition.condition },
        { label: "Severidad", show: true, value: condition.severity },
    ];
}

export function ForLabTests(labTest: LabTestDataType) {
    return [
        { label: "Prueba", show: true, value: labTest.name },
        { label: "Tipo", show: true, value: labTest.type },
        {
            label: "Fecha",
            show: labTest.date != null,
            value: Dates.format(labTest.date),
        },
        {
            label: "Resultado",
            show: labTest.result != null,
            value: labTest.result ?? "",
        },
    ];
}

export function ForMedicines(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForSurgeries(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForVaccines(vaccine: VaccineDataType) {
    return [
        { label: "Vacuna", show: true, value: vaccine.name },
        {
            label: "Descripción",
            show: vaccine.description != null,
            value: vaccine.description ?? "",
        },
        {
            label: "Fecha",
            show: vaccine.date != null,
            value: Dates.format(vaccine.date),
        },
        { label: "Lote", show: true, value: vaccine.batch },
        { label: "Marca", show: true, value: vaccine.brand },
    ];
} 
----- Archivo: index.ts ----- 
export * as Empty from "./empty";
export * as FieldData from "./entityFieldData"; 
----- Archivo: petdata.ts ----- 
// app/data/petdata.tsx
import { v4 } from "uuid";
import { Metadata } from "next";
import {
  BasicDataType,
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  OwnerDataType,
  PetType,
  SurgeryDataType,
  VaccineDataType
} from "@/types/index";

export const metadata: Metadata = {
  title: "Lampo",
  description: "Lampo es una herramienta para que ayudará a TU MASCOTA en sus proceso clínicos y veterinarios",
};

export const andresData: OwnerDataType = {
  owner_id: '8933eed8-daea-4e6c-b4db-44906b9f44f9',
  name: 'Andrés',
  last_name: 'Aulestia',
  phone: '+57 3146061490',
  address: 'Cra. 74 #152b-70 Torre 3 Apto. 1704',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'a.aulestia@exe.com.co'
}

export const johnnyData: OwnerDataType = {
  owner_id: '41095adf-27a6-48f8-ada1-d8c7d3dd265a',
  name: 'Johnnatan',
  last_name: 'Ruiz',
  phone: '+57 3112849616',
  address: 'Calle 82 #19A-29 Apt 401',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'excellent.exeqtion@gmail.com'
}

export const ownersData: OwnerDataType[] = [
  andresData,
  johnnyData
];

export const PetsData: PetType[] = [
  { id: 'A001', name: 'Camus', image: '/pets/camus.png', owner_id: andresData.owner_id },
  { id: 'A002', name: 'Polar', image: '/pets/polar.png', owner_id: johnnyData.owner_id },
  { id: 'A003', name: 'Toby', image: '/pets/toby.png', owner_id: johnnyData.owner_id }
];

export const camusData: BasicDataType =
{
  pet_id: 'A001', pet_type: 'Gato', gender: 'Macho', weight: '5.5 Kg', race: 'Mestizo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: false,
  main_food: 'Taste the Wild', has_vaccine: true, last_vaccine_name: 'Parvigen', last_vaccine_date: new Date('2024-07-25'),
  is_castrated: true, castration_date: new Date('2023-12-02'), has_anti_flea: true, anti_flea_date: new Date('2023-12-15'),
  uses_medicine: false, special_condition: false
}

export const polarData: BasicDataType =
{
  pet_id: 'A002', pet_type: 'Perro', gender: 'Macho', weight: '7 Kg', race: 'Criollo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true,
  main_food: 'Pro Plan', has_vaccine: false,
  is_castrated: true, castration_date: new Date('2023-06-30'), has_anti_flea: false,
  uses_medicine: false, special_condition: false
};

export const tobyData: BasicDataType =
{
  pet_id: 'A003', pet_type: 'Perro', gender: 'Macho', weight: '9 Kg', race: 'Criollo', has_allergies: true,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true,
  main_food: 'Vet Life', has_vaccine: false,
  is_castrated: true, castration_date: new Date('2019-05-03'), has_anti_flea: false,
  uses_medicine: false, special_condition: true
};

export const petsData: BasicDataType[] =
  [
    camusData,
    polarData,
    tobyData
  ];


export const vaccinesMock: VaccineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Rabia", description: "Vacuna contra la rabia", date: new Date('2025-03-15'), batch: "RAB12345", brand: "Nobivac" },
  { id: v4(), pet_id: 'A001', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
  { id: v4(), pet_id: 'A002', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
];

export const surgeriesMock: SurgeryDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Castración", date: new Date("2024-11-20"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A001', name: "Extracción dental", date: new Date("2024-12-05"), description: "Tooth extraction" },
  { id: v4(), pet_id: 'A002', name: "Castración", date: new Date("2023-06-30"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A003', name: "Castración", date: new Date("2019-05-03"), description: "Castración preventiva" },
];

export const medicinesMock: MedicineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Antibiótico X", dosage: "250mg", frequency: "Cada 12 horas" },
  { id: v4(), pet_id: 'A001', name: "Vitamina C", dosage: "100mg", frequency: "Diaria" },
];

export const conditionsMock: ConditionDataType[] = [
  { id: v4(), pet_id: 'A001', condition: "Esterilidad aórtica", severity: "Moderada" },
  { id: v4(), pet_id: 'A001', condition: "Alergia alimentaria", severity: "Leve" },
  { id: v4(), pet_id: 'A003', condition: "Insuficiencia renal", severity: "Leve" },
];

export const labTestsMock: LabTestDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Hemograma completo", type: "Blood", date: new Date("2025-01-10"), result: "Normal" },
  { id: v4(), pet_id: 'A001', name: "Ultrasonido abdominal", type: "Ultrasound", date: new Date("2024-12-22"), result: "Sin hallazgos" },
];

export const petTypes = ['Perro', 'Gato', 'Ave', 'Reptil', 'Otro'];
export const genders = ['Macho', 'Hembra'];
export const weightUnits = ['Kg', 'Lb'];
export const breedOptions: Record<string, string[]> = {
  Perro: ['Labrador', 'Pastor Alemán', 'Bulldog', 'Otro'],
  Gato: ['Siamés', 'Persa', 'Maine Coon', 'Otro'],
  Ave: ['Loro', 'Canario', 'Periquito', 'Otro'],
  Reptil: ['Iguana', 'Tortuga', 'Otro'],
  Otro: ['Otro'],
};
export const foodOptions = [
  'Royal Canin',
  'Purina Pro Plan',
  'Whiskas',
  'Dog Chow',
  'Eukanuba',
  'Nutra Nuggets',
  'Pedigree',
  'Otro'
];
export const weightConditionOptions = ['Bajo peso', 'Peso ideal', 'Sobrepeso'];
export const sizeOptions = ['Pequeño', 'Mediano', 'Grande', 'Extra Grande']; 
----- Archivo: useAppStorage.ts ----- 
// hooks/useAppStorage.ts
import { useLocalStorage } from "@/hooks/useLocalStorage";
import { PetType, PetCodeType, VeterinaryAccessType, BasicDataType, OwnerDataType, VaccineDataType, ConditionDataType, LabTestDataType, MedicineDataType, SurgeryDataType, VeterinarianType } from "@/types/index";
import { Empty } from "@/data/index";
export interface StorageContextType {
    resetSession: () => void;
    resetPet: () => void;
    storedPet: PetType;
    setStoredPet: (value: PetType) => void;
    storedBasicData: BasicDataType;
    setStoredBasicData: (value: BasicDataType) => void;
    storedOwnerData: OwnerDataType;
    setStoredOwnerData: (value: OwnerDataType) => void;
    storedVetData: VeterinarianType;
    setStoredVetData: (value: VeterinarianType) => void;
    storedVetAccess: VeterinaryAccessType;
    setStoredVetAccess: (value: VeterinaryAccessType) => void;
    storedPetCode: PetCodeType;
    setStoredPetCode: (value: PetCodeType) => void;
    storedOwnerPets: PetType[];
    setStoredOwnerPets: (value: PetType[]) => void;
    storedVaccineData: VaccineDataType[],
    setStoredVaccineData: (value: VaccineDataType[]) => void,
    storedConditionData: ConditionDataType[],
    setStoredConditionData: (value: ConditionDataType[]) => void,
    storedLabTestData: LabTestDataType[],
    setStoredLabTestData: (value: LabTestDataType[]) => void,
    storedMedicineData: MedicineDataType[],
    setStoredMedicineData: (value: MedicineDataType[]) => void,
    storedSurgeryData: SurgeryDataType[],
    setStoredSurgeryData: (value: SurgeryDataType[]) => void,
}

export function useAppStorage() {
  const [storedPet, setStoredPet] = useLocalStorage<PetType>(
    "selectedPet",
    Empty.Pet()
  );

  const [storedBasicData, setStoredBasicData] = useLocalStorage<BasicDataType>(
    "petBasicData",
    Empty.BasicData()
  );

  const [storedOwnerData, setStoredOwnerData] = useLocalStorage<OwnerDataType>(
    "petOwnerData",
    Empty.OwnerData()
  );

  const [storedOwnerPets, setStoredOwnerPets] = useLocalStorage<PetType[]>(
    "ownerPets",
    []
  );

  const [storedVaccineData, setStoredVaccineData] = useLocalStorage<VaccineDataType[]>(
    "petVaccineData",
    []
  );

  const [storedConditionData, setStoredConditionData] = useLocalStorage<ConditionDataType[]>(
    "petConditionData",
    []
  );

  const [storedLabTestData, setStoredLabTestData] = useLocalStorage<LabTestDataType[]>(
    "petLabTestData",
    []
  );

  const [storedMedicineData, setStoredMedicineData] = useLocalStorage<MedicineDataType[]>(
    "petMedicineData",
    []
  );

  const [storedSurgeryData, setStoredSurgeryData] = useLocalStorage<SurgeryDataType[]>(
    "petSurgeryData",
    []
  );

  const [storedVetAccess, setStoredVetAccess] = useLocalStorage<VeterinaryAccessType>(
    "vetAccess",
    Empty.VetAccess()
  );

  const [storedPetCode, setStoredPetCode] = useLocalStorage<PetCodeType>(
    "petCode",
    Empty.PetCode()
  );

  const [storedVetData, setStoredVetData] = useLocalStorage<VeterinarianType>(
    "vetData",
    Empty.VetData()
  );

  const resetPet = () => {
    setStoredBasicData(Empty.BasicData());
    setStoredConditionData([]);
    setStoredLabTestData([]);
    setStoredMedicineData([]);
    setStoredSurgeryData([]);
    setStoredVaccineData([]);
  }

  const resetSession = () =>{
    resetPet();
    setStoredPetCode(Empty.PetCode());
    setStoredVetAccess(Empty.VetAccess());
    setStoredOwnerData(Empty.OwnerData());
    setStoredOwnerPets([]);
    setStoredPet(Empty.Pet());
  }

  return {
    resetSession,
    resetPet,
    storedPet,
    setStoredPet,
    storedBasicData,
    setStoredBasicData,
    storedOwnerData,
    setStoredOwnerData,
    storedVetData,
    setStoredVetData,
    storedOwnerPets,
    setStoredOwnerPets,
    storedVaccineData,
    setStoredVaccineData,
    storedConditionData,
    setStoredConditionData,
    storedLabTestData,
    setStoredLabTestData,
    storedMedicineData,
    setStoredMedicineData,
    storedSurgeryData,
    setStoredSurgeryData,
    storedVetAccess,
    setStoredVetAccess,
    storedPetCode,
    setStoredPetCode,
  } as StorageContextType;
} 
----- Archivo: useAuthRedirect.ts ----- 
// src/hooks/useAuthRedirect.ts
"use client";

import { useEffect } from "react";
import { usePathname, useRouter } from "next/navigation";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useRoleContext } from "@/context/RoleProvider";

export default function useAuthRedirect() {
    const router = useRouter();
    const pathname = usePathname();
    const session = useSessionContext();                      // undefined | null | AppSession
    const { storedVetAccess } = useStorageContext();
    const { isVetWithoutUserSession } = useRoleContext();

    useEffect(() => {
        // 1) Espera a que la sesión esté cargada
        if (session === undefined) return;

        // 2) Detectores de ruta
        const isLoginRoute = pathname === "/login" || pathname.endsWith("/login");
        const isVetRoute = pathname.startsWith("/vet-access");
        const isRoot = pathname === "/";

        // 3) Redirigir a /login sólo desde la raíz si no hay sesión
        if (session === null && isRoot) {
            router.replace("/login");
            return;
        }

        // 4) Redirigir a vet-access si es vet-user
        if (isVetWithoutUserSession && !isVetRoute && !isLoginRoute) {
            router.replace("/vet-access");
            return;
        }

        // 5) Redirigir a /login desde otras rutas si no hay sesión
        if (session === null && !isLoginRoute && !isVetRoute && !isRoot) {
            router.replace("/login");
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session, storedVetAccess, pathname, router]);
} 
----- Archivo: useDeviceDetect.ts ----- 
// hooks/useDeviceDetect.ts
import { useState, useEffect } from 'react'

export function useDeviceDetect() {
  const [isMobile, setIsMobile] = useState(false)
  const [isTablet, setIsTablet] = useState(false)
  const [isDesktop, setIsDesktop] = useState(false)

  useEffect(() => {
    const onResize = () => {
      const w = window.innerWidth
      setIsMobile(w <= 767)
      setIsTablet(w > 767 && w <= 1024)
      setIsDesktop(w > 1024)
    }

    onResize() // run once on mount
    window.addEventListener('resize', onResize)
    return () => window.removeEventListener('resize', onResize)
  }, [])

  return { isMobile, isTablet, isDesktop }
}
 
----- Archivo: useEffectDebugger.ts ----- 
/* eslint-disable @typescript-eslint/no-explicit-any */

import { useRef, useEffect } from "react";

const usePrevious = (value: any, initialValue: any) => {
    const ref = useRef(initialValue);
    useEffect(() => {
        ref.current = value;
    });
    return ref.current;
};

export const useEffectDebugger = (processName: string, effectHook: any, dependencies: any, dependencyNames = []) => {
    const previousDeps = usePrevious(dependencies, []);

    const changedDeps = dependencies.reduce((accum: any, dependency: any, index: any) => {
        if (dependency !== previousDeps[index]) {
            const keyName = dependencyNames[index] || index;
            return {
                ...accum,
                [keyName]: {
                    before: previousDeps[index],
                    after: dependency
                }
            };
        }

        return accum;
    }, {});

    if (Object.keys(changedDeps).length) {
        console.log(`[use-effect-debugger] ${processName}:`, changedDeps);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(effectHook, dependencies);
};

 
----- Archivo: useEntityList.ts ----- 
// src/hooks/useEntityList.ts
"use client";

import { deleteFetch } from '@/app/api';
import { ApiError, StepsStateType } from '@/types/lib';
import { Dispatch, SetStateAction } from 'react';

export function useEntityList<T extends { id: string | undefined }>(
    emptyFactory: (id: string) => Partial<T>,
    id: string,
    setList: Dispatch<SetStateAction<Partial<T>[]>>,
    setError: Dispatch<SetStateAction<string | null>>,
    stepNumber: number,
    stepStates: StepsStateType[]
) {
    const addItem = () => setList(prev => [...prev, emptyFactory(id)]);
    const removeItem = (id?: string) => {
        const getUrl = () =>
            stepStates.find(x => x.step == stepNumber)?.url;
        if (id) {
            try {
                deleteFetch(`${getUrl()}${id}`);
            }
            catch {
                throw new ApiError("Error al consumir la api de delete");
            }
        }
        setList(prev => {
            const items = prev.filter(item => item.id !== id);
            if (items.length == 0) {
                setError('');
            }
            return items;
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateItem = (index: number, field: keyof T, value: any) =>
        setList(prev => prev.map((item, idx) => (idx === index ? { ...item, [field]: value } : item)));

    return { addItem, removeItem, updateItem };
}
 
----- Archivo: useEntitySubmit.ts ----- 
// src/hooks/useEntitySubmit.ts
"use client";

import { Dispatch, SetStateAction, useState } from 'react';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { Steps, Validations } from '@/utils/index';
import { FieldConfig } from '../types/lib/index';
import { postFetch } from '@/app/api';

export function useEntitySubmit<T>(
    id: string,
    entities: Partial<T>[],
    entityName: string,
    setStoredList: (list: T[]) => void,
    setDataCallback: (data: T[]) => void,
    fieldConfig: FieldConfig<T>[],
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: React.Dispatch<React.SetStateAction<StepsStateType[]>>,
    error: string | null,
    setError: Dispatch<SetStateAction<string | null>>
) {
    const [submitting, setSubmitting] = useState(false);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x => x.step === stepNumber)?.url;

    const submit = async (onNext: () => void) => {
        setSubmitting(false);
        const validationError = Validations.forFields(entities, entityName, fieldConfig);
        if (validationError) {
            setError(validationError);
            return;
        }
        setError(null);
        try {
            if (stateEq(StepStateEnum.Modified)) {
                if (entities.length > 0) {
                    const basicDataResponse = await postFetch(`${getUrl()}${id}`, undefined, entities);
                    if (!basicDataResponse.ok) throw new ApiError(`Error actualizado ${entityName}.`);
                    setDataCallback(entities as T[]);
                    setStoredList(entities as T[]);
                }
                setState(StepStateEnum.Saved);
            }
            onNext();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (err: any) {
            setError(err.message);
            setState(StepStateEnum.Error, err.message);
        } finally {
            setSubmitting(true);
        }
    };

    return { submit, loading: submitting, error };
} 
----- Archivo: useLoadEntities.ts ----- 

// src/hooks/useLoadEntities.ts
"use client";

import { useState, useEffect, Dispatch, SetStateAction } from 'react';
import { Steps } from '@/utils/index';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { getFetch } from '@/app/api';

export function useLoadEntities<T>(
    id: string,
    entityName: string,
    storedList: T[],
    setStoredList: (list: T[]) => void,
    initialData: T[],
    setDataCallback: (data: T[]) => void,
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: Dispatch<SetStateAction<StepsStateType[]>>
) {
    const [list, setList] = useState<Partial<T>[]>(initialData);
    const [savedData, setSavedData] = useState<T[]>(initialData);
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(true);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x=> x.step == stepNumber)?.url;

    useEffect(() => {
        const fetch = async () => {
            if (stateEq(StepStateEnum.NotInitialize)) {
                setState(StepStateEnum.Initialize);
                let saved: T[] = [];
                if (storedList.length == 0) {
                    const response = await getFetch(`${getUrl()}}${id}`);
                    if(!response.ok) throw new ApiError(`Fallo al obtener información de ${entityName}`);
                    setStoredList(saved);
                }
                else {
                    saved = storedList;
                }
                if (saved) {
                    setSavedData(saved);
                    setDataCallback(saved);
                    setList(saved);
                }
            }
            setLoading(false);
        }
        fetch();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [id]);

    useEffect(() => {
        if (JSON.stringify(savedData) !== JSON.stringify(list) && !stateEq(StepStateEnum.NotInitialize) && loading == false) {
            setState(StepStateEnum.Modified);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [list]);

    return { list, setList, error, setError, loading, setState, stateEq };
}
 
----- Archivo: useRole.ts ----- 
// src/hooks/useRole.ts
import { useMemo } from "react";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";

export function useRole() {
    const session = useSessionContext();
    const storage = useStorageContext();

    const isOwner = useMemo(
        () => session?.db?.user?.user_metadata?.role === "owner",
        [session]
    );

    const isVetWithSession = useMemo(
        () => session?.db?.user?.user_metadata?.role === "veterinarian",
        [session]
    );

    const hasVetAccessWithoutSession = useMemo(
        () => !session && storage.storedVetAccess?.id !== "",
        [session, storage.storedVetAccess]
    );

    const isVetWithUserSession = useMemo(
        () => storage.storedVetAccess?.id !== "" && isOwner,
        [storage.storedVetAccess, isOwner]
    );

    const isVetWithoutUserSession = useMemo(
        () =>
            (isVetWithSession || hasVetAccessWithoutSession) &&
            !isVetWithUserSession,
        [isVetWithSession, hasVetAccessWithoutSession, isVetWithUserSession]
    );

    const isVet = useMemo(
        () =>
            isVetWithSession ||
            isVetWithoutUserSession ||
            isVetWithUserSession,
        [isVetWithSession, isVetWithoutUserSession, isVetWithUserSession]
    );

    return {
        isOwner,
        isVet,
        isVetWithSession,
        isVetWithoutSession: hasVetAccessWithoutSession,
        isVetWithUserSession,
        isVetWithoutUserSession,
    } as const;
}
 
----- Archivo: useLocalStorage.tsx ----- 
// app/lib/db/hooks/useLocalStorage.tsx
import { useState, useEffect } from "react";
import CryptoJS from "crypto-js";

/**
 * Hook para manejar un valor en localStorage con encriptación opcional y hash de clave,
 * implementando hidratación para evitar lectura antes del montaje.
 * @param key Clave original para identificar item en storage.
 * @param initialValue Valor inicial si no existe valor en storage.
 * @param options.secret Secreto para encriptar/hashear clave y valor.
 * @returns [valor, setter] donde setter actualiza estado y storage.
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T,
  options?: { secret?: string }
): [T, (value: T | null) => void] {
  const secret = options?.secret || (process.env.NEXT_PUBLIC_ENABLE_ENCRYPTION == 'false' ? '' : process.env.NEXT_PUBLIC_STORAGE_SECRET!);
  // Generar clave de storage hasheada si hay secreto
  const storageKey = secret
    ? CryptoJS.SHA256(key + secret).toString()
    : key;

  // Estado del valor almacenado
  const [storedValue, setStoredValue] = useState<T>(initialValue);

  // Al hidratar, leer de localStorage
  useEffect(() => {
    try {
      const item = window.localStorage.getItem(storageKey);
      if (item === null) {
        setStoredValue(initialValue);
      } else {
        const raw = secret
          ? CryptoJS.AES.decrypt(item, secret).toString(CryptoJS.enc.Utf8)
          : item;
        setStoredValue(JSON.parse(raw) as T);
      }
    } catch {
      setStoredValue(initialValue);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storageKey, secret]);

  /**
   * Setter que guarda en estado y en localStorage (o elimina si value es null).
   */
  const setValue = (value: T | null) => {
    if (typeof window === "undefined") {
      setStoredValue(value as T);
      return;
    }
    try {
      if (value === null) {
        window.localStorage.removeItem(storageKey);
        setStoredValue(initialValue);
      } else {
        const stringValue = JSON.stringify(value);
        const encrypted = secret
          ? CryptoJS.AES.encrypt(stringValue, secret).toString()
          : stringValue;
        window.localStorage.setItem(storageKey, encrypted);
        setStoredValue(value);
      }
    } catch {
      // Ignorar errores de storage
    }
  };

  return [storedValue, setValue];
}
 
----- Archivo: useSession.tsx ----- 
// app/hooks/useSession.tsx
"use client";

import { useState, useEffect } from "react";
import type { Session } from "@supabase/supabase-js";
import { onAuthStateChange } from "@/services/authService";

export function useSession(): Session | undefined {
  const [session, setSession] = useState<Session | undefined>(undefined);
  useEffect(() => {
    const getCurrentSession = async () => {
      const res = await fetch("/api/auth/session");
      const json = await res.json();
      setSession(json.session || undefined);
    };

    // 1. Obtiene sesión inicial
    getCurrentSession();

    // 2) Nos suscribimos a cambios
    const subscription = onAuthStateChange((_event, newSession) => {
      if (newSession) setSession(newSession);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);


  return session;
}
 
----- Archivo: supabase.tsx ----- 
// app/lib/client/supabase.tsx
import { createClient } from "@supabase/supabase-js";

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);
 
----- Archivo: basicData.repository.ts ----- 
// src/repositories/basicData.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { BasicDataType } from '@/types/index';

export default class BasicDataRepository {
  static async upsert(basicData: BasicDataType) {
    const { data, error } = await supabase.from('basic_data')
      .upsert(basicData, { onConflict: 'pet_id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  static async findByPetId(pet_id: string): Promise<BasicDataType | null> {
    const { data, error } = await supabase.from('basic_data').select('*').eq('pet_id', pet_id);
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  static async update(data: BasicDataType) {
    return supabase.from('basic_data').update(data).eq('pet_id', data.pet_id);
  }
}
 
----- Archivo: condition.repository.ts ----- 
// src/repositories/condition.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { ConditionDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class ConditionRepository implements FormRepository<ConditionDataType> {
    async createAll(conditions: ConditionDataType[]) {
        const { data, error } = await supabase
            .from('conditions')
            .upsert(conditions, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<ConditionDataType[] | null> {
        const { data, error } = await supabase.from('conditions').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('conditions').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch(err) {
            console.log(err);
            return false;
        }
    }
}
 
----- Archivo: index.ts ----- 
export { default as BasicDataRepository } from './basicData.repository';
export { default as ConditionRepository } from './condition.repository';
export { default as LabTestRepository } from './labTest.repository';
export { default as MedicineRepository } from './medicine.repository';
export { default as OwnerRepository } from './owner.repository';
export { default as PetRepository } from './pet.repository';
export { default as PetCodeRepository } from './petCode.repository';
export { default as PlanRepository } from './plan.repository';
export { default as SubscriptionRepository } from './subscription.repository';
export { default as SurgeryRepository } from './surgery.repository';
export { default as VaccineRepository } from './vaccine.repository';
export { default as VeterinaryAccessRepository } from './veterinaryAccess.repository'; 
----- Archivo: labTest.repository.ts ----- 
// src/repositories/labTest.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { LabTestDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class LabTestRepository implements FormRepository<LabTestDataType> {
    async createAll(tests: LabTestDataType[]) {
        const { data, error } = await supabase
            .from('lab_tests')
            .upsert(tests, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<LabTestDataType[] | null> {
        const { data, error } = await supabase.from('lab_tests').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('lab_tests').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: medicine.repository.ts ----- 
// src/repositories/medicine.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { MedicineDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class MedicineRepository implements FormRepository<MedicineDataType> {
    async createAll(medicines: MedicineDataType[]) {
        const { data, error } = await supabase
            .from('medicines')
            .upsert(medicines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<MedicineDataType[] | null> {
        const { data, error } = await supabase.from('medicines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('medicines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: owner.repository.ts ----- 
// src/repositories/owner.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { OwnerDataType } from '@/types/index';

export default class OwnerRepository {
    static async create(owner: OwnerDataType) {
        return supabase.from('owners').insert(owner);
    }

    static async findById(owner_id: string): Promise<OwnerDataType | null> {
        if(owner_id == undefined){
            return null;
        }
        const { data, error } = await supabase.from('owners').select('*').eq('owner_id', owner_id);
        if (error) throw new Error(error.message);
        if (!data || data.length === 0) return null;
        return data[0];
    }

    static async update(owner: OwnerDataType) {
        return supabase.from('owners').update(owner).eq('owner_id', owner.owner_id);
    }

    static async delete(owner_id: string) {
        return supabase.from('owners').delete().eq('owner_id', owner_id);
    }
}
 
----- Archivo: pet.repository.ts ----- 
// src/repositories/pet.repository.ts
import { supabase } from "@/lib/client/supabase";
import { PetType } from "@/types/index";

export default class PetRepository {
  static async upsert(pet: PetType) {
    const { data, error } = await supabase.from('pets')
      .upsert(pet, { onConflict: 'id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  /** Busca la mascota por ID */
  static async findById(id: string): Promise<PetType> {
    const { data, error } = await supabase
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("id", id)
      .single();
    if (error) throw new Error(error.message);
    return data;
  }
  /** Busca la mascota por ID */
  static async existsById(id: string): Promise<boolean> {
    const { data, error } = await supabase
      .from("pets")
      .select("*", { count: 'exact', head: true })
      .eq("deleted", false)
      .eq("id", id);
    if (error) throw new Error(error.message);
    return data != null;
  }

  /** Actualiza campos de la mascota */
  static async updateById(
    id: string,
    updates: Partial<Pick<PetType, "image" | "name">>
  ): Promise<boolean> {
    const { data, error } = await supabase
      .from("pets")
      .update(updates)
      .eq("id", id);
    if (error) throw new Error(error.message);
    if (!data) return false;
    return true;
  }

  /** Verifica que el usuario loggeado y la mascota seleccionada se encuentren en la base de datos  */
  static async findByOwnerIdAndPetId(ownerId: string, pet_id: string): Promise<{ id: string } | null> {
    const { data, error } = await supabase
      .from("pets")
      .select("id")
      .eq("deleted", false)
      .eq("owner_id", ownerId)
      .eq("id", pet_id);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data[0];
  }

  /** Retorna la primera mascota del owner, o null */
  static async findByOwnerId(ownerId: string): Promise<PetType[]> {
    const { data, error } = await supabase
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("owner_id", ownerId);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return [];

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data ?? [];
  }

  /**
   * Marca una mascota como eliminada (soft delete).
   * @param id ID de la mascota a borrar
   * @returns true si la operación no falló
   */
  static async deleteById(id: string): Promise<boolean> {
    const now = new Date().toISOString();
    try {
      const { error } = await supabase
        .from("pets")
        .update({ deleted: true, deleted_at: now })
        .eq("id", id);

      if (error) {
        console.error("Error al eliminar mascota:", error);
        throw new Error(error.message);
      }
      return true;
    }
    catch {
      return false;
    }
  }
} 
----- Archivo: petCode.repository.ts ----- 
// src/repositories/petCode.repository.ts

import { supabase } from "@/lib/client/supabase";
import { PetCodeType } from "@/types/index";
import { Random } from "@/utils/index";

export default class PetCodeRepository {
  /** Busca un código activo */
  static async find(code: string): Promise<PetCodeType | null> {
    const { data, error } = await supabase
      .from("pet_codes")
      .select("*")
      .eq("code", code)
      .overrideTypes<PetCodeType[], { merge: false }>();
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  /** Invalida (marca used=true) todos los códigos previos de una mascota */
  static async invalidateAll(petId: string): Promise<void> {
    const { error } = await supabase
      .from("pet_codes")
      .delete()
      .eq("pet_id", petId);
    if (error) throw new Error(error.message);
  }

  /** Genera e inserta un nuevo código, devolviéndolo */
  static async create(
    petId: string,
    ttlMinutes: number
  ): Promise<string> {
    const code = Random.generateCode();
    const expiresAt = new Date(Date.now() + ttlMinutes * 60_000).toISOString();
    const { error } = await supabase
      .from("pet_codes")
      .insert({ pet_id: petId, code, expires_at: expiresAt });
    if (error) throw new Error(error.message);
    return code;
  }

  /** Marca un código como usado */
  static async markUsed(code: string): Promise<void> {
    const { error } = await supabase
      .from("pet_codes")
      .update({ used: true })
      .eq("code", code);
    if (error) throw new Error(error.message);
  }
}
 
----- Archivo: plan.repository.ts ----- 
// src/repositories/plan.repository.ts
import { supabase } from '@/lib/client/supabase';
import { PlanVersionType } from '../types/index';

export default class PlanRepository {
  /**
   * Trae todas las versiones vigentes (effective_to IS NULL)
   */
  static async getAllCurrent(): Promise<PlanVersionType[]> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)

    if (error) throw error
    // Mapear para llevar slug al root
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return data.map((row: any) => ({
      ...row,
      slug: row.plans.slug
    }))
  }

  /**
   * Busca la versión actual de un plan por su slug
   */
  static async getBySlug(slug: string): Promise<PlanVersionType | null> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)
      .eq('plans.slug', slug)
      .overrideTypes<PlanVersionType[], { merge: false }>()

    if (error) {
      if (error.code === 'PGRST116') return null // sin datos
      throw error
    }

    return {
      ...data[0],
      slug: data[0].plans.slug
    }
  }

  /**
   * Trae todas las versiones históricas de un plan
   */
  static async getVersions(planId: number): Promise<PlanVersionType[]> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select('*')
      .eq('plan_id', planId)
      .order('version', { ascending: false })

    if (error) throw error
    return data
  }
}
 
----- Archivo: subscription.repository.ts ----- 
// src/repositories/subscription.repository.ts
import { supabase } from '@/lib/client/supabase';
import { CreateSubscriptionType, SubscriptionType } from '@/types/index';


export default class SubscriptionRepository {
    /**
     * Crea una suscripción en estado pending
     */
    static async create(params: CreateSubscriptionType): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .insert([{
                owner_id: params.ownerId,
                plan_version_id: params.planVersionId,
                cycle: params.cycle,
                status: 'pending',
                price_at_purchase: params.priceAtPurchase,
                discount_applied: params.discountApplied
            }])
            .select()

        if (error) throw error
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Obtiene la suscripción activa de un owner
     */
    static async getActiveByOwner(ownerId: string): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .select('*')
            .eq('owner_id', ownerId)
            .eq('status', 'active')

        if (error) {
            if (error.code === 'PGRST116') return null
            throw error
        }
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Lista todas las suscripciones de un owner
     */
    static async getByOwner(ownerId: string): Promise<SubscriptionType[] | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .select('*')
            .eq('owner_id', ownerId)
            .order('started_at', { ascending: false })

        if (error) throw error
        if (!data || data.length === 0) return null;
        return data
    }

    /**
     * Actualiza el estado y fechas de una suscripción
     */
    static async updateStatus(params: {
        subscriptionId: number
        status: 'active' | 'canceled' | 'expired'
        externalId?: string
        expiresAt?: string
    }): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .update({
                status: params.status,
                external_id: params.externalId,
                expires_at: params.expiresAt,
                updated_at: new Date().toISOString()
            })
            .eq('id', params.subscriptionId)
            .select()

        if (error) throw error

        if (!data || data.length === 0) return null;
        return data[0]
    }
}
 
----- Archivo: surgery.repository.ts ----- 
// src/repositories/surgery.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { SurgeryDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class SurgeryRepository implements FormRepository<SurgeryDataType> {
    async createAll(surgeries: SurgeryDataType[]) {
        const { data, error } = await supabase
            .from('surgeries')
            .upsert(surgeries, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<SurgeryDataType[] | null> {
        const { data, error } = await supabase.from('surgeries').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('surgeries').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: vaccine.repository.ts ----- 
// src/repositories/vaccine.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { VaccineDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class VaccineRepository implements FormRepository<VaccineDataType> {
    async createAll(vaccines: VaccineDataType[]) {
        const { data, error } = await supabase
            .from('vaccines')
            .upsert(vaccines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<VaccineDataType[] | null> {
        const { data, error } = await supabase.from('vaccines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('vaccines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: veterinarian.repository.ts ----- 
// src/repositories/veterinarian.repository.ts
import { supabase } from '@/lib/client/supabase';
import type { VeterinarianType } from '@/types/index';

export default class VeterinarianRepository {
    /** Inserta un nuevo veterinario */
    static async create(vet: VeterinarianType) {
        return supabase.from('veterinarians').insert(vet);
    }

    /** Busca un veterinario por su ID */
    static async findById(vet_id: string): Promise<VeterinarianType | null> {
        if (!vet_id) return null;
        const { data, error } = await supabase
            .from('veterinarians')
            .select('*')
            .eq('vet_id', vet_id);
        if (error) throw new Error(error.message);
        return data && data.length > 0 ? data[0] : null;
    }

    /** Actualiza todos los campos de un veterinario */
    static async update(vet: VeterinarianType) {
        return supabase
            .from('veterinarians')
            .update(vet)
            .eq('vet_id', vet.vet_id);
    }

    /** Elimina un veterinario por su ID */
    static async delete(vet_id: string) {
        return supabase
            .from('veterinarians')
            .delete()
            .eq('vet_id', vet_id);
    }
}
 
----- Archivo: veterinaryAccess.repository.ts ----- 
// src/repositories/veterinaryAccess.repository.ts
import { supabase } from "@/lib/client/supabase";
import { VeterinaryAccessType } from "../types";
import PetCodeRepository from "./petCode.repository";

export default class VeterinaryAccessRepository {
    /** Registra un nuevo acceso de veterinario */
    static async create(access: Omit<
        VeterinaryAccessType,
        "id" | "created_at"
    >): Promise<VeterinaryAccessType> {
        const { data, error } = await supabase
            .from("veterinary_accesses")
            .insert(access)
            .select("*")
            .single();  

        if (error) throw new Error(error.message);
        return data;
    }

    /** Obtiene datos de acceso por código (para validaciones o historial) */
    static async findByCodeAndByPetId(
        code: string,
        pet_id: string
    ): Promise<VeterinaryAccessType | null> {
        try {
            const petCode = await PetCodeRepository.find(code);
            if (!petCode) return null;
            const { data, error } = await supabase
                .from("veterinary_accesses")
                .select("*")
                .eq("pet_code_id", petCode.id)
                .eq("pet_id", pet_id)


            if (error) throw new Error(error.message);
            if (!data || data.length === 0) return null;
            return data[0];
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        catch (errCode: any) {
            if (errCode) throw new Error(errCode.message);
            return null;
        }

    }
}
 
----- Archivo: validationSchemas.ts ----- 
// src/schemas/validationSchemas.ts
import { z } from 'zod';

// PetType
export const PetTypeSchema = z.object({
  id: z.string(),
  name: z.string(),
  image: z.string().nullable().optional(),
  owner_id: z.string(),
});

// PetCodeType
export const PetCodeTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  code: z.string(),
  used: z.boolean(),
  expires_at: z.string(),
});

// OwnerDataType
export const OwnerDataTypeSchema = z.object({
  owner_id: z.string(),
  name: z.string(),
  last_name: z.string(),
  phone: z.string(),
  address: z.string(),
  city: z.string(),
  country: z.string(),
  email: z.string(),
});

// BasicDataType
export const BasicDataTypeSchema = z.object({
  pet_id: z.string(),
  pet_type: z.string(),
  gender: z.string(),
  weight: z.string(),
  race: z.string(),
  has_allergies: z.boolean(),
  weight_condition: z.string(),
  size: z.string(),
  lives_with_others: z.boolean(),
  main_food: z.string(),
  has_vaccine: z.boolean(),
  last_vaccine_name: z.string().optional().nullable(),
  last_vaccine_date: z.string().optional().nullable(),
  is_castrated: z.boolean(),
  castration_date: z.string().optional().nullable(),
  has_anti_flea: z.boolean(),
  anti_flea_date: z.string().optional().nullable(),
  uses_medicine: z.boolean(),
  special_condition: z.boolean(),
});

// InitialBasicDataType
export const InitialBasicDataTypeSchema = z.object({
  petType: z.string(),
  food: z.string(),
  race: z.string(),
  otherPetType: z.string(),
  otherFood: z.string(),
  otherRace: z.string(),
});

// VaccineDataType
export const VaccineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  name: z.string(),
  description: z.string().optional().nullable(),
  date: z.string().optional().nullable(),
  batch: z.string(),
  brand: z.string(),
});

// SurgeryDataType
export const SurgeryDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  name: z.string(),
  date: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
});

// MedicineDataType
export const MedicineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  name: z.string(),
  dosage: z.string(),
  frequency: z.string(),
});

// ConditionDataType
export const ConditionDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  condition: z.string(),
  severity: z.string(),
});

// LabTestDataType
export const LabTestDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  name: z.string(),
  type: z.string(),
  date: z.string().optional().nullable(),
  result: z.string().optional().nullable(),
});

// VeterinaryAccessType
export const VeterinaryAccessTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  pet_code_id: z.string(),
  vet_first_name: z.string(),
  vet_last_name: z.string(),
  professional_registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
  created_at: z.string(),
});

//Veterinarian
export const VeterinarianTypeSchema = z.object({
  vet_id: z.string().uuid(),
  first_name: z.string(),
  last_name: z.string(),
  email: z.string().email(),
  registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
});

// FeatureType
export const FeatureTypeSchema = z.object({
  text: z.string(),
  badge: z.string().optional(),
});

// PlanType
export const PlanTypeSchema = z.object({
  id: z.number(),
  slug: z.string(),
});

// PlanVersionType
export const PlanVersionTypeSchema = z.object({
  id: z.number(),
  plan_id: z.number(),
  slug: z.string(),
  version: z.number(),
  title: z.string(),
  description: z.string(),
  price_month: z.number(),
  price_year: z.number(),
  discount_month: z.number(),
  discount_year: z.number(),
  features: z.array(FeatureTypeSchema),
  effective_from: z.string(),
  effective_to: z.string().nullable(),
  plans: PlanTypeSchema,
});

// SubscriptionType
export const SubscriptionTypeSchema = z.object({
  id: z.number(),
  owner_id: z.string(),
  plan_version_id: z.number(),
  cycle: z.enum(['monthly', 'annual']),
  status: z.enum(['pending', 'active', 'canceled', 'expired']),
  external_id: z.string().nullable(),
  price_at_purchase: z.number(),
  discount_applied: z.number(),
  started_at: z.string(),
  expires_at: z.string().nullable(),
  updated_at: z.string(),
});
 
----- Archivo: apiService.ts ----- 
import { QueryParamError, StepStateError, RepositoryError, ValidationResult } from "@/types/lib";
import { NextRequest, NextResponse } from "next/server";
import { ZodSchema, ZodError } from "zod";

/** 
 * Envuelve la ejecución de un handler de API, capturando cualquier excepción
 * y devolviendo un 500 en caso de error interno.
 *
 * @param req    – el NextRequest que llega
 * @param handler– Función que ejecuta la lógica de negocio y devuelve un NextResponse
 */
export async function getWithErrorHandling(
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        return await handler()
    } catch (err: unknown) {
        console.error(`[GET] Error en ${req.url} —`, err);
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        return NextResponse.json(
            { success: false, message: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * Extrae un parámetro de query y lanza QueryParamError si no existe.
 */
export function getRequiredQueryParam(req: NextRequest, name: string): string {
    const value = req.nextUrl.searchParams.get(name)
    if (!value) {
        throw new QueryParamError(`${name} es requerido`)
    }
    return value
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withErrorHandling(
    method: string,
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 2) Lógica de negocio con body ya parseado
        return await handler();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }

        // 6) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withValidationAndErrorHandling<T>(
    method: string,
    req: NextRequest,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schema: ZodSchema<any>,
    handler: (data: T) => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 1) Validación del body
        const { data, error } = await validateBody(req, schema);
        if (error) {
            return error;
        }

        // 2) Lógica de negocio con body ya parseado
        return await handler(data);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }

        // 6) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Valida y parsea el body de la request según el esquema.
 * @param req NextRequest
 * @param schema ZodSchema que define la forma esperada
 * @returns Un objeto { data } si parseó bien, o { error } con NextResponse si falló.
 */
async function validateBody<T>(
    req: NextRequest,
    schema: ZodSchema<T>
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
): Promise<ValidationResult<any>> {
    try {
        const body = await req.json();
        if (Array.isArray(body)) {
            body.forEach((e: T) => {
                const parsed = schema.safeParse(e);
                if (!parsed.success) {
                    // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                    return {
                        error: NextResponse.json(
                            {
                                success: false,
                                message: "Payload inválido",
                                errors: (parsed.error as ZodError).format(),
                            },
                            { status: 400 }
                        ),
                    };
                }
            });
        }
        else {
            const parsed = schema.safeParse(body);
            if (!parsed.success) {
                // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                return {
                    error: NextResponse.json(
                        {
                            success: false,
                            message: "Payload inválido",
                            errors: (parsed.error as ZodError).format(),
                        },
                        { status: 400 }
                    ),
                };
            }
        }
        return { data: body };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        // JSON inválido u otro error de lectura
        return {
            error: NextResponse.json(
                { success: false, message: err.message || "No se pudo leer el body" },
                { status: 400 }
            ),
        };
    }
} 
----- Archivo: authService.ts ----- 
// src/services/authService.ts
import { supabase } from "@/lib/client/supabase";
import type { Session, User, AuthError, AuthChangeEvent } from "@supabase/supabase-js";
import { StorageContextType } from "@/hooks/useAppStorage";
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";

export const signIn = async (
  email: string,
  password: string
): Promise<{ data: { session: Session | null; user: User | null }; error: AuthError | null }> => {
  return supabase.auth.signInWithPassword({ email, password });
};

export const ownerSignUp = async (
  email: string,
  password: string,
  role: string = 'owner'
): Promise<{ data: { user: User | null }; error: AuthError | null }> => {
  return supabase.auth.signUp({
    email, password,
    options: {
      data: { role: role }
    }
  });
};

export const resetPassword = async (
  email: string
): Promise<{ data: object | null; error: AuthError | null }> => {
  return supabase.auth.resetPasswordForEmail(email);
};
export const signOut = () => supabase.auth.signOut();

export const getSession = () => supabase.auth.getSession();

export const onAuthStateChange = (
  cb: (event: AuthChangeEvent, session: Session | null) => void
) => supabase.auth.onAuthStateChange(cb).data.subscription;

export const setSession = (session: {
  access_token: string;
  refresh_token: string;
}) => supabase.auth.setSession(session);

export const handleLogout = async (storage: StorageContextType, router: AppRouterInstance) => {
  try {
    const response = await fetch("/api/auth/sign-out", { method: "POST" });
    const result = await response.json();

    if (!response.ok || !result.success) {
      console.error("Error cerrando sesión:", result.message || "Unknown error");
    }
  } catch (err) {
    console.error("Error en logout:", err);
  }
  await signOut();
  storage.resetSession();
  router.replace("/login");
}; 
----- Archivo: emailService.ts ----- 
// src/services/emailService.ts

export interface SendEmailOptions {
  subject: string;
  text: string;
  from?: string;
  to?: string;
}

export async function sendEmail({ subject, text, from, to }: SendEmailOptions) {
  const MAILTRAP_URL = process.env.MAILTRAP_URL;
  const MAILTRAP_TOKEN = process.env.MAILTRAP_TOKEN;
  const MAILTRAP_FROM = from || process.env.MAILTRAP_FROM;
  const MAILTRAP_TO = to || process.env.MAILTRAP_TO;

  // Validación de configuración
  if (!MAILTRAP_URL || !MAILTRAP_TOKEN || !MAILTRAP_FROM || !MAILTRAP_TO) {
    throw new Error('Configuración de email incompleta');
  }

  // Envío de correo vía API
  const response = await fetch(MAILTRAP_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${MAILTRAP_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from: { email: MAILTRAP_FROM },
      to: [{ email: MAILTRAP_TO }],
      subject,
      text,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Error al enviar correo: ${response.status} - ${errorText}`);
  }
} 
----- Archivo: geist.ts ----- 
import { Geist, Geist_Mono } from "next/font/google";

export const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
export const geistMono = Geist_Mono({ variable: "--font-geist-mono", subsets: ["latin"] }); 
----- Archivo: tooltip.ts ----- 
// app/css/tooltip.tsx
export const tooltipStyles =
  `
        .tooltip-container {
          position: relative;
          display: inline-block; }
        .tooltip-container .tooltip-text {
          visibility: hidden;
          width: max-content;
          background-color: white;
          color:rgb(1, 114, 173);
          border: 1px solid rgb(1, 114, 173);
          text-align: center;
          padding: 4px 8px;
          border-radius: 4px;
          position: absolute;
          font-size: 0.75rem;
          white-space: nowrap;
          z-index: 1600;
          font-weight: bold;
          opacity: 0;
        }
        .tooltip-container .tooltip-text .tooltip-left {
          bottom: 29%;
          right: 57px;
          transition: opacity 0.2s;
        }
        .tooltip-container .tooltip-text .tooltip-right {
          left: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-left: 12px;
        }
        .tooltip-container:hover .tooltip-text {
          visibility: visible;
          opacity: 1;
        }
      `; 
----- Archivo: veterinary.ts ----- 
// app/css/veterinary.tsx
export const veterinaryStyles =
`
        .overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2000;
        }
        .modal {
          background: #fff;
          border-radius: 1rem;
          padding: 2rem;
          width: 90%;
          max-width: 400px;
          position: relative;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .close-btn {
          position: absolute;
          top: 0.5rem;
          right: 0.5rem;
          background: none;
          border: none;
          font-size: 1.25rem;
          color: #333;
          cursor: pointer;
        }
        .label {
          font-size: 1.1rem;
          margin-bottom: 0.5rem;
          color: #333;
        }
        .input-code {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          border: 1px solid #ccc;
          border-radius: 0.25rem;
          text-transform: uppercase;
          margin-bottom: 1rem;
          transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-code:focus {
          outline: none;
          border-color: #007bff;
          box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2);
        }
        .error {
          color: #dc3545;
          font-size: 0.875rem;
          margin-bottom: 1rem;
        }
        .submit-btn {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          background-color: #007bff;
          color: #fff;
          border: none;
          border-radius: 0.25rem;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        .submit-btn:disabled {
          background-color: #6c757d;
          cursor: not-allowed;
        }
        .submit-btn:not(:disabled):hover {
          background-color: #0056b3;
        }
      `; 
----- Archivo: index.ts ----- 
export interface PetType {
    id: string;
    name: string;
    image?: string | null;
    owner_id: string;
}
export interface PetCodeType {
    id: string;
    pet_id: string;
    code: string;
    used: boolean;
    expires_at: string;
}
export interface OwnerDataType {
    owner_id: string;
    name: string;
    last_name: string;
    phone: string;
    address: string;
    city: string;
    country: string;
    email: string;
}
export interface BasicDataType {
    pet_id: string;
    pet_type: string;
    gender: string;
    weight: string;
    race: string;
    has_allergies: boolean;
    weight_condition: string;
    size: string;
    lives_with_others: boolean;
    main_food: string;
    has_vaccine: boolean;
    last_vaccine_name?: string;
    last_vaccine_date?: Date;
    is_castrated: boolean;
    castration_date?: Date;
    has_anti_flea: boolean;
    anti_flea_date?: Date;
    uses_medicine: boolean;
    special_condition: boolean;
}
export interface InitialBasicDataType {
    petType: string,
    food: string,
    race: string,
    otherPetType: string,
    otherFood: string,
    otherRace: string
}
export interface VaccineDataType {
    id: string;
    pet_id: string;
    name: string;
    description?: string;
    date?: Date;
    batch: string;
    brand: string;
}
export interface SurgeryDataType {
    id: string;
    pet_id: string;
    name: string;
    date?: Date;
    description?: string;
}
export interface MedicineDataType {
    id: string;
    pet_id: string;
    name: string;
    dosage: string;
    frequency: string;
}
export interface ConditionDataType {
    id: string;
    pet_id: string;
    condition: string;
    severity: string;
}
export interface LabTestDataType {
    id: string;
    pet_id: string;
    name: string;
    type: string;
    date?: Date;
    result?: string;
}
export interface VeterinaryAccessType {
    id: string;
    pet_id: string;
    pet_code_id: string;
    vet_first_name: string;
    vet_last_name: string;
    professional_registration: string;
    clinic_name: string;
    city: string;
}

export interface VeterinarianType {
  vet_id: string;
  first_name: string;
  last_name: string;
  email: string;
  registration: string;
  clinic_name: string;
  city: string;
}

export interface FeatureType {
    text: string;
    badge?: string;
}
export interface PlanType {
    id: number;
    slug: string;
}
export interface PlanVersionType {
    id: number;
    plan_id: number;
    slug: string;
    version: number;
    title: string;
    description: string;
    price_month: number;
    price_year: number;
    discount_month: number;
    discount_year: number;
    features: FeatureType[];
    effective_from: string;
    effective_to: string | null;
    plans: PlanType;
}
export interface SubscriptionType {
    id: number;
    owner_id: string;
    plan_version_id: number;
    cycle: 'monthly' | 'annual';
    status: 'pending' | 'active' | 'canceled' | 'expired';
    external_id: string | null;
    price_at_purchase: number;
    discount_applied: number;
    started_at: string;
    expires_at: string | null;
    updated_at: string;
}

export interface CreateSubscriptionType {
    ownerId: string;
    planVersionId: number;
    cycle: 'monthly' | 'annual';
    priceAtPurchase: number;
    discountApplied: number;
}

export enum PetStep {
    Name = 0,
    BasicData = 1,
    Vaccines = 2,
    Medicines = 3,
    LabTests = 4,
    Conditions = 5,
    Surgeries = 6
} 
----- Archivo: index.ts ----- 
import { StorageContextType } from "@/hooks/useAppStorage";
import { PostgrestError, Session } from "@supabase/supabase-js";
import { NextResponse } from "next/server";
import { Dispatch, SetStateAction } from "react";
import { ZodObject } from "zod";

export interface AppContextType {
  session: AppSession | null;
  logout: () => object;
  storage: StorageContextType;
  showEditPetModal: boolean;
}

export interface AppSession {
  db: Session | undefined;
}

export interface FormType {
  id: string,
  fields: FieldType[]
}

export interface FieldType {
  label: string;
  show: boolean;
  value?: string;
}

export interface MenuType {
  label: string;
  icon: React.JSX.Element,
  url: string;
  showModal?: Dispatch<SetStateAction<boolean>>,
  show: boolean;
}

export interface StepsStateType {
  step: number;
  state: StepStateEnum;
  url?: string;
  error?: string | null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  schema: ZodObject<any>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  repository?: FormRepository<any>
}

export enum StepStateEnum {
  NotInitialize = 0,
  Initialize = 1,
  Saved = 2,
  Modified = 3,
  Skipped = 4,
  Error = 5,
}

export type StepConfig<T> = {
  entityName: string;
  storedList: T[];
  setStoredList: (list: T[]) => void;
  emptyFactory: (petId: string) => T;
  fieldsConfig: FieldConfig<T>[];
};

export interface FieldConfig<T> {
  label: string;
  name: keyof T;
  type: "text" | "date";
  mandatory?: boolean;
  className?: string;
}

export interface FormRepository<T> {
  createAll: (list: T[]) => Promise<{
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    data: any[] | null;
    error: PostgrestError | null;
  }>;
  findByParentId: (parent_id: string) => Promise<T[] | null>;
  delete: (id: string) => Promise<boolean>
}

export interface LogInType {
  email: string;
  password?: string;
  role: 'owner' | 'veterinarian';
}
export interface SetSesionType {
  access_token: string;
  refresh_token: string;
}

export interface ApiParams {
  params: Record<string, string>;
};

export type ApiResponse = Promise<NextResponse<{ message: string; success: boolean }>>;

export type ValidationResult<T> =
  | { data: T; error?: undefined }
  | { data?: undefined; error: NextResponse };


/**
 * Excepción que lanzamos cuando falta un parámetro obligatorio en la query.
 */
export class QueryParamError extends Error { }

/**
 * Excepción que lanzamos cuando falta alguna configuración en los steps.
 */
export class StepStateError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema en el repositorio.
 */
export class RepositoryError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema consumiendo un api.
 */
export class ApiError extends Error { } 
----- Archivo: dates.ts ----- 
export function format(date: string | Date | undefined | null): string {
    if (date == undefined || date == null) {
        return '';
    }
    if(typeof(date) == typeof("")){
        return (date as string).split('T')[0];
    }
    return (date as Date).toISOString().split('T')[0];
} 
----- Archivo: factories.ts ----- 
// src/utils/factories.ts
"use client";

import { v4 } from 'uuid';
import type {
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  SurgeryDataType,
  VaccineDataType
} from '@/types/index';

export const emptyVaccine = (petId: string): Partial<VaccineDataType> => ({
    pet_id: petId,
    id: v4(),
    name: "",
    description: "",
    date: undefined,
    batch: "",
    brand: "",
});

export const emptyCondition = (petId: string): Partial<ConditionDataType> => ({
  id: v4(),
  pet_id: petId,
  condition: '',
  severity: '',
});

export const emptyLabTest = (petId: string): Partial<LabTestDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  type: '',
  date: undefined,
  result: '',
});

export const emptyMedicine = (petId: string): Partial<MedicineDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  dosage: '',
  frequency: '',
});

export const emptySurgery = (petId: string): Partial<SurgeryDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  date: undefined,
  description: '',
}); 
----- Archivo: index.ts ----- 
export * as Dates from "@/utils/dates";
export * as Factores from "@/utils/factories";
export * as Random from "@/utils/random";
export * as Roles from "@/utils/roles";
export * as Steps from "@/utils/steps";
export * as Strings from "@/utils/strings";
export * as Validations from "@/utils/validations"; 
----- Archivo: random.ts ----- 
// src/utils/random.tsx
import { customAlphabet } from "nanoid";

// Define un alfabeto con dígitos y letras (mayúsculas + minúsculas)
const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

// Crea un generador de IDs de 6 caracteres
export const generateCode = customAlphabet(ALPHABET, 6);


/**
 * Genera un ID aleatorio que cumple el patrón: letra + 3 dígitos (e.g. A012, z999).
 */
function randomPetId(): string {
  const letter = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
  const number = Math.floor(Math.random() * 1000)
    .toString()
    .padStart(3, '0');
  return `${letter}${number}`;
}

/**
 * Genera un ID único para mascota, repitiendo hasta que no exista en la base de datos.
 */
export async function generateUniquePetId(): Promise<string> {
  let candidate: string;
  let exists: boolean;

  do {
    candidate = randomPetId();

    const res = await fetch(`/api/pets/exists?id=${candidate}`);
    const data = await res.json();
    exists = data.exists;
  } while (exists);

  return candidate;
} 
----- Archivo: roles.ts ----- 
// src/utils/role.ts
import { AppSession } from "@/types/lib";
import { VeterinaryAccessType } from "../types";

export function isVet(appSession: AppSession | null | undefined, vetAccess: VeterinaryAccessType): boolean {
    return isVetWithSession(appSession) || isVetWithoutSession(appSession, vetAccess) || isVetWithUserSession(appSession, vetAccess);
}

export function isVetWithoutUserSession(appSession: AppSession | null | undefined, vetAccess: VeterinaryAccessType): boolean {
    return (isVetWithSession(appSession) || isVetWithoutSession(appSession, vetAccess)) && !isVetWithUserSession(appSession, vetAccess) ;
}

export function isVetWithSession(appSession: AppSession | null | undefined): boolean {
    return appSession?.db?.user?.user_metadata?.role === "veterinarian";
}

export function isVetWithoutSession(appSession: AppSession | null | undefined, vetAccess: VeterinaryAccessType): boolean {
    return (appSession == null || appSession == undefined) && vetAccess?.id != "";
}

//TODO: This should be a hook depending on the appSession and the vetaccess
export function isVetWithUserSession(appSession: AppSession | null | undefined, vetAccess: VeterinaryAccessType): boolean {
    return vetAccess?.id != "" && isOwner(appSession);
}

//TODO: This should be a hook depending on the appSession
export function isOwner(appSession: AppSession | null | undefined) {
    return appSession?.db?.user?.user_metadata?.role === "owner";
}
 
----- Archivo: steps.ts ----- 
// src/utils/steps.ts
import { StepsStateType, StepStateEnum } from '@/types/lib';
import { Dispatch } from 'react';

export function ChangeState(stepStates: StepsStateType[], setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>, stepNumber: number, stepState: StepStateEnum, stepError: string | null = null) {
    const step = stepStates.find(s => s.step == stepNumber);
    if (step) {
        step.state = stepState;
        step.error = stepError;
    }
    setStepStates(stepStates);
} 
----- Archivo: strings.ts ----- 
// src/utils/string.ts
import { ApiParams } from "@/types/lib";

export function titleCase(word: string) {
    if (!word) return word;
    return word[0].toUpperCase() + word.substr(1).toLowerCase();
}

/**
 * Convierte un objeto en un query string para URL.
 * Omite claves con valor undefined o null.
 *
 * @example
 * paramsToString({ a: 1, b: 'hola mundo', c: undefined }) 
 * // devuelve "?a=1&b=hola%20mundo"
 *
 * @param params Objeto cuyas claves/valores se desean serializar.
 * @returns Query string (incluye '?' si hay al menos un parámetro).
 */
export function fromParams(params: ApiParams): string {
  const entries = Object.entries(params)
    .filter(([, value]) => value !== undefined && value !== null)
    .map(([key, value]) => {
      // Si es array, repetimos key=valor por cada elemento
      if (Array.isArray(value)) {
        return value
          .map(v => `${encodeURIComponent(key)}=${encodeURIComponent(String(v))}`)
          .join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
    });

  if (entries.length === 0) {
    return '';
  }
  return `?${entries.join('&')}`;
} 
----- Archivo: validations.ts ----- 
// src/utils/validations.ts

import { FieldConfig } from "@/types/lib";

/**
 * Valida un array de entidades genericas contra su configuracion de campos.
 * Devuelve null si todo pasa, o un mensaje con los campos obligatorios faltantes.
 */
export function forFields<T>(
  items: Partial<T>[],
  entityName: string,
  fieldsConfig: FieldConfig<T>[]
): string | null {
  const missing: string[] = [];

  items.forEach((item, idx) => {
    fieldsConfig
      .filter(field => field.mandatory)
      .forEach(field => {
        if (!item[field.name]) {
          missing.push(`${field.label} en ${entityName} #${idx + 1}`);
        }
      });
  });

  if (missing.length > 0) {
    return `Faltan los campos obligatorios: ${missing.join(', ')}`;
  }
  return null;
}
 
