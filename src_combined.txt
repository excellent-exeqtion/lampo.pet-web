----- Archivo: middleware.ts ----- 
// middleware.ts
import { type NextRequest } from 'next/server';
import { updateSession } from './lib/auth'; // O la ruta correcta a tu index.ts de lib/auth

export async function middleware(request: NextRequest) {
  // updateSession se encargará de refrescar la cookie de sesión de Supabase
  // y también puede manejar redirecciones si no hay usuario (como lo tienes configurado)
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}; 
----- Archivo: layout.tsx ----- 
// app/layout.tsx
"use client";
import React from "react";
import "./globals.css";
import "@picocss/pico";
import { tooltipStyles } from "@/styles/tooltip";
import { geistMono, geistSans } from "@/styles/geist";
import { ClientAppProvider } from "../components";
import { usePathname } from "next/navigation";
import { SessionProvider } from "@/context/SessionProvider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const noClientAppProviderRoutes = ["/testing-supabase", "/test-supabase", "/minimal-test", "/login", "/auth/callback", "/pages/auth/verify"];
  const shouldUseClientAppProvider = !noClientAppProviderRoutes.includes(pathname);
  return (
    <html lang="es" data-theme="light">
      <head>
        <title>Lampo</title>
      </head>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <style>{tooltipStyles}</style>
        <SessionProvider>
          {shouldUseClientAppProvider ? (
            <ClientAppProvider>
              {children}
            </ClientAppProvider>
          ) : (
            <>
              {children}
            </>
          )}
        </SessionProvider>
      </body>
    </html >
  );
}
 
----- Archivo: page.tsx ----- 
"use client";
import React from "react";
import "@picocss/pico";
import CalendarModule from "./pages/pet/calendar/page";

export default function Home() {
  return (
    <CalendarModule />
  );
}

 
----- Archivo: globals.css ----- 
/**
 * Custom theme
*/
/* Red Light scheme (Default) */
/* Can be forced with data-theme="light" */
[data-theme="light"],
:root:not([data-theme="dark"]) {
  --primary: #e53935;
  --primary-hover: #d32f2f;
  --primary-focus: rgba(229, 57, 53, 0.125);
  --primary-inverse: #FFF;
}

/* Red Dark scheme (Auto) */
/* Automatically enabled if user has Dark mode enabled */
@media only screen and (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --primary: #e53935;
    --primary-hover: #f44336;
    --primary-focus: rgba(229, 57, 53, 0.25);
    --primary-inverse: #FFF;
  }
}

/* Red Dark scheme (Forced) */
/* Enabled if forced with data-theme="dark" */
[data-theme="dark"] {
  --primary: #e53935;
  --primary-hover: #f44336;
  --primary-focus: rgba(229, 57, 53, 0.25);
  --primary-inverse: #FFF;
}

/* Red (Common styles) */
:root {
  --form-element-active-border-color: var(--primary);
  --form-element-focus-color: var(--primary-focus);
  --switch-color: var(--primary-inverse);
  --switch-checked-background-color: var(--primary);
}

.pet-dropdown {
  --pico-box-shadow: 'none' !important;
}

.pet-selection:hover {
  background-color: gray;
}

body {
  -webkit-touch-callout: none;
  /* iOS Safari */
  -webkit-user-select: none;
  /* Safari */
  -khtml-user-select: none;
  /* Konqueror HTML */
  -moz-user-select: none;
  /* Old versions of Firefox */
  -ms-user-select: none;
  /* Internet Explorer/Edge */
  user-select: none;
  /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.modal-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #02659a !important;
}

.modal-description {
  font-size: 0.9rem;
  color: #555;
  margin-bottom: 1.5rem;
}

.text-error {
  color: #d32f2f;
}

main {
  background-color: rgb(249, 250, 251);
} 
----- Archivo: page.module.css ----- 
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  background-color: rgb(249, 250, 251);
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer Image {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    background-color: rgb(249, 250, 251);
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
} 
----- Archivo: index.ts ----- 
import { ApiParams } from "@/types/lib";
import { Strings } from "@/utils/index";

export async function getFetch(url: string, params: ApiParams | undefined = undefined) {
    return await methodFetch("GET", url, params);
}

export async function putFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PUT", url, params, payload);
}

export async function postFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("POST", url, params, payload);
}

export async function patchFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PATCH", url, params, payload);
}

export async function deleteFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("DELETE", url, params, payload);
}

async function methodFetch(method: string, url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    let parameters = "";
    if (params) {
        parameters = Strings.fromParams(params);
    }
    let body = undefined;
    if (payload) {
        body = JSON.stringify(payload);
    }
    return await fetch(`${process.env.PROTOCOL}://${process.env.PRODUCTION_URL}${url}${parameters}`, {
        method: method,
        headers: method == "GET" ? undefined : { 'Content-Type': 'application/json' },
        body: body
    })
} 
----- Archivo: route.ts ----- 
// src/app/api/auth/session/route.ts
import { NextResponse } from "next/server";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
// Importa el helper de Next.js, no uses req.cookies
import { cookies } from "next/headers";

export async function GET() {
  // Cookies es una función que devuelve ReadonlyRequestCookies
  const supabase = createServerComponentClient({ cookies });

  const {
    data: { session },
    error,
  } = await supabase.auth.getSession();

  if (error) {
    return NextResponse.json(
      { success: false, message: error.message },
      { status: 401 }
    );
  }

  return NextResponse.json({ success: true, session });
}
 
----- Archivo: route.ts ----- 
// src/app/api/auth/set-session/route.ts
import { NextRequest, NextResponse } from "next/server";
import { withValidationAndErrorHandling } from "@/services/apiService";
import { z } from "zod";
import { SetSesionType } from "@/types/lib";
import { setSession } from "@/services/authService";

const SessionSchema = z.object({
    access_token: z.string(),
    refresh_token: z.string(),
});

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling("POST", req, SessionSchema, async (data: SetSesionType) => {

        try {
            await setSession(data);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        catch (error: any) {
            if (error) {
                return NextResponse.json({ success: false, message: error.message }, { status: 401 });
            }
        }
        return NextResponse.json({ success: true, message: "Sesión establecida" });
    });
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationRepository } from '@/repos/index';
import { getRequiredQueryParam, getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { CreateConsultationPayloadSchema } from '@/schemas/validationSchemas';
import type { CreateConsultationPayload } from '@/types/index';
import { RepositoryError } from '@/types/lib';
import { type CookieOptions, createServerClient } from '@supabase/ssr'; // Importar createServerClient y CookieOptions
import { cookies } from 'next/headers';
import { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';

const supabase = (cookieStore: ReadonlyRequestCookies) => createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
        cookies: {
            get(name: string) {
                return cookieStore.get(name)?.value;
            },
            set(name: string, value: string, options: CookieOptions) {
                // Cuando Supabase llama a esto en una Route Handler,
                // está indicando que una cookie necesita ser establecida en la RESPUESTA.
                // La instancia de `cookieStore` aquí puede ser usada para esto.
                try {
                    cookieStore.set(name, value, options); // Correcto para la respuesta
                    // O si la API de cookieStore requiere un objeto:
                    // cookieStore.set({ name, value, ...options });
                } catch (error) {
                    console.error(`SSR Error (Route Handler): Failed to set cookie ${name}`, error);
                }
            },
            remove(name: string, options: CookieOptions) {
                try {
                    // Para eliminar, establece el valor a vacío y usa las opciones para expirar.
                    cookieStore.set(name, '', options); // Correcto para la respuesta
                    // O si la API de cookieStore requiere un objeto:
                    // cookieStore.set({ name, value: '', ...options });
                } catch (error) {
                    console.error(`SSR Error (Route Handler): Failed to remove cookie ${name}`, error);
                }
            },
        },
    }
);

// POST /api/consultations : Crear una nueva consulta
export async function POST(req: NextRequest) {

    const cookieStore = await cookies(); // De next/headers

    return withValidationAndErrorHandling(
        'POST',
        req,
        CreateConsultationPayloadSchema,
        async (payload: CreateConsultationPayload) => {
            const { data: { session }, error: sessionError } = await supabase(cookieStore).auth.getSession();

            if (sessionError) {
                console.error("Error obteniendo sesión en API:", sessionError);
                return NextResponse.json({ success: false, message: 'Error de autenticación al obtener sesión.' }, { status: 401 });
            }

            if (!payload.veterinarian_id && !payload.veterinary_access_id) {
                if (session?.user?.user_metadata?.role === 'veterinarian') {
                    payload.veterinarian_id = session.user.id;
                } else {
                    console.warn("Intento de crear consulta sin vet_id o vet_access_id, y sin sesión de veterinario.");
                    return NextResponse.json(
                        { success: false, message: 'Se requiere veterinarian_id o veterinary_access_id válido.' },
                        { status: 403 }
                    );
                }
            }

            const { data, error } = await ConsultationRepository.create(payload);
            if (error || !data) {
                console.error(`Error creando consulta desde API: ${error?.message || 'No data returned'}`);
                throw new RepositoryError(`Error creando consulta: ${error?.message || 'No data returned'}`);
            }
            return NextResponse.json({ success: true, consultation: data }, { status: 201 });
        }
    );
}

// GET /api/consultations?petId=mascota123 : Listar consultas de una mascota
export async function GET(req: NextRequest) {

    return getWithErrorHandling(
        req,
        async () => {
            // Ejemplo de protección de ruta GET:
            // const { data: { session } } = await supabase.auth.getSession();
            // if (!session) {
            //     return NextResponse.json({ success: false, message: 'No autenticado para ver consultas.' }, { status: 401 });
            // }

            const petId = getRequiredQueryParam(req, 'petId');
            const { data, error } = await ConsultationRepository.findByPetId(petId);

            if (error) {
                throw new RepositoryError(`Error obteniendo consultas para la mascota ${petId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, consultations: data || [] });
        }
    );
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/[consultationId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';

// GET /api/consultations/{consultationId} : Obtener una consulta específica
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { consultationId } = await params;
            if (!consultationId) {
                return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
            }

            const { data, error } = await ConsultationRepository.findById(consultationId);

            if (error) {
                throw new RepositoryError(`Error obteniendo consulta ${consultationId}: ${error.message}`);
            }
            if (!data) {
                return NextResponse.json({ success: false, message: `Consulta ${consultationId} no encontrada` }, { status: 404 });
            }
            return NextResponse.json({ success: true, consultation: data });
        }
    );
}

// TODO: PATCH /api/consultations/{consultationId} : Actualizar una consulta (más complejo)
// export async function PATCH(req: NextRequest, { params }: { params: { consultationId: string } }) { ... }

// TODO: DELETE /api/consultations/{consultationId} : Eliminar una consulta (considerar RLS)
// export async function DELETE(req: NextRequest, { params }: { params: { consultationId: string } }) { ... } 
----- Archivo: route.ts ----- 
// src/app/api/consultations/[consultationId]/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationFileRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB
const ALLOWED_FILE_TYPES = ['image/jpeg', 'image/png', 'application/pdf', 'image/webp', 'image/gif'];

// POST /api/consultations/{consultationId}/files : Subir un archivo a una consulta
export async function POST(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    return getWithErrorHandling(req, async () => {
        const { consultationId } = await params;
        if (!consultationId) {
            return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
        }

        const formData = await req.formData();
        const file = formData.get('file') as File | null;
        const petId = formData.get('petId') as string | null; // Necesario para la ruta del archivo

        if (!file) {
            return NextResponse.json({ success: false, message: 'Archivo no proporcionado' }, { status: 400 });
        }
        if (!petId) {
            return NextResponse.json({ success: false, message: 'petId no proporcionado en el FormData' }, { status: 400 });
        }

        if (file.size > MAX_FILE_SIZE) {
            return NextResponse.json({ success: false, message: `El archivo excede el tamaño máximo de ${MAX_FILE_SIZE / (1024 * 1024)}MB` }, { status: 413 });
        }
        if (!ALLOWED_FILE_TYPES.includes(file.type)) {
            return NextResponse.json({ success: false, message: `Tipo de archivo no permitido. Permitidos: ${ALLOWED_FILE_TYPES.join(', ')}` }, { status: 415 });
        }

        const supabase = createServerComponentClient({ cookies });
        const { data: { user } } = await supabase.auth.getUser();
        const uploadedByUserId = user?.id;

        const { data, error } = await ConsultationFileRepository.uploadAndCreateRecord(
            consultationId,
            petId,
            file,
            uploadedByUserId
        );

        if (error || !data) {
            console.log(`Error subiendo archivo: ${error?.message || 'No data returned'}`)
            if (error?.message.includes("new row violates row-level security policy")) {
                throw new Error("No tienes permisos para cargar el archivo");
            }
            throw new RepositoryError("Error subiendo archivo: ");
        }
        return NextResponse.json({ success: true, file: data }, { status: 201 });
    });
}

// GET /api/consultations/{consultationId}/files : Listar archivos de una consulta
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { consultationId } = await params;
            if (!consultationId) {
                return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
            }

            const { data, error } = await ConsultationFileRepository.findByConsultationId(consultationId);

            if (error) {
                throw new RepositoryError(`Error obteniendo archivos para consulta ${consultationId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, files: data || [] });
        }
    );
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/files/[fileId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationFileRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { supabase } from '@/lib/auth/supabase/browserClient';

// GET /api/consultations/files/{fileId}/download : Obtener URL firmada para descargar
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ fileId: string }> }
) {
    return getWithErrorHandling(req, async () => {
        const { fileId } = await params;
        if (!fileId) {
            return NextResponse.json({ success: false, message: 'fileId es requerido' }, { status: 400 });
        }

        // Primero, necesitamos el filePath del registro del archivo
        const { data: fileRecord, error: findError } = await supabase
            .from('consultation_files')
            .select('file_path')
            .eq('id', fileId)
            .single();

        if (findError || !fileRecord) {
            throw new RepositoryError(`Archivo con ID ${fileId} no encontrado o error al buscarlo: ${findError?.message}`);
        }

        const { signedURL, error: urlError } = await ConsultationFileRepository.getSignedUrl(fileRecord.file_path);

        if (urlError || !signedURL) {
            throw new RepositoryError(`Error generando URL firmada para archivo ${fileId}: ${urlError?.message || 'No URL returned'}`);
        }
        // Opción 1: Devolver la URL para que el cliente la use
        return NextResponse.json({ success: true, downloadUrl: signedURL });

        // Opción 2: Redirigir directamente a la URL firmada (el cliente descargará el archivo)
        // return NextResponse.redirect(signedURL);
    });
}


// DELETE /api/consultations/files/{fileId} : Eliminar un archivo
export async function DELETE(
    req: NextRequest,
    { params }: { params: Promise<{ fileId: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { fileId } = await params;
            if (!fileId) {
                return NextResponse.json({ success: false, message: 'fileId es requerido' }, { status: 400 });
            }

            // Aquí deberías verificar permisos (RLS debería manejar esto también)
            // Por ejemplo, solo el veterinario que subió el archivo o el dueño de la mascota
            // pueden eliminarlo, o solo dentro de un tiempo límite.

            const { error } = await ConsultationFileRepository.delete(fileId);

            if (error) {
                throw new RepositoryError(`Error eliminando archivo ${fileId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, message: 'Archivo eliminado correctamente' });
        }
    );
} 
----- Archivo: route.ts ----- 

// src/app/api/feedback/route.ts
import { NextResponse } from 'next/server';
import { sendEmail } from '@/services/emailService';

export const runtime = 'nodejs';

export async function POST(req: Request) {
  try {
    const { feedback, anonymous, userEmail } = await req.json();
    if (!feedback || typeof feedback !== 'string') {
      return NextResponse.json({ error: 'Falta el texto del feedback' }, { status: 400 });
    }

    const subjectBase = process.env.MAILTRAP_SUBJECT || 'Feedback de Lampo';
    const subject = anonymous
      ? `${subjectBase} (Anonymous)`
      : `${subjectBase} (From ${userEmail})`;

    // Llamada al servicio de email
    await sendEmail({ subject, text: feedback });

    return NextResponse.json({ ok: true }, { status: 200 });
  } catch (err) {
    console.error('Error interno en /api/feedback:', err);
    const message = err instanceof Error ? err.message : 'Error interno del servidor';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
 
----- Archivo: route.ts ----- 
// app/api/owners/route.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { OwnerRepository } from '@/repos/index';
import type { OwnerDataType } from '@/types/index';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { OwnerDataTypeSchema } from '@/schemas/validationSchemas';
import { RepositoryError } from '@/types/lib';

// PUT /api/owner : crea o actualiza datos del dueño
export async function PUT(request: NextRequest) {
    try {
        const payload: OwnerDataType = await request.json();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const ownerId = (payload as any).owner_id;
        if (!ownerId) {
            return NextResponse.json({ error: 'El campo owner_id es requerido' }, { status: 400 });
        }

        const existing = await OwnerRepository.findById(ownerId);
        if (existing) {
            await OwnerRepository.update(payload);
        } else {
            await OwnerRepository.create(payload);
        }

        const saved = await OwnerRepository.findById(ownerId);
        return NextResponse.json({ owner: saved });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
        console.error('Error upserting owner:', error);
        return NextResponse.json({ error: error.message || 'Error interno del servidor' }, { status: 500 });
    }
}



export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        OwnerDataTypeSchema,
        async (ownerData: OwnerDataType) => {
            try {
                const { data, error } = await OwnerRepository.create(ownerData);
                if (error) {
                    throw new RepositoryError(`Error creating record: ${JSON.stringify(ownerData)}`);
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error creating record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { PetRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            try {
                const data = await PetRepository.findByOwnerId(id);
                return NextResponse.json(data);
            }
            catch {
                throw new RepositoryError("Error getting pets");
            }
        });
}
 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { OwnerRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError(`Falta parámetro OwnerId`);
            }

            const ownerData = await OwnerRepository.findById(id);
            if (!ownerData) {
                throw new RepositoryError(`Owner no encontrado: ${id}`);
            }
            return NextResponse.json(ownerData);
        }
    );
}
 
----- Archivo: route.ts ----- 
// app/api/pets/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getRequiredQueryParam, withValidationAndErrorHandling, getWithErrorHandling } from '@/services/apiService'
import PetRepository from '@/repos/pet.repository'
import { z } from 'zod'
import { PetType } from '@/types/index'

const petSchema = z.object({
    id: z.string().optional(),
    name: z.string(),
    image: z.string().optional(),
    owner_id: z.string(),
})

export async function GET(req: NextRequest) {
    return getWithErrorHandling(
        req,
        async () => {
            // ahora delegamos la validación del ownerId
            const ownerId = getRequiredQueryParam(req, 'ownerId')
            const pets = await PetRepository.findByOwnerId(ownerId)
            return NextResponse.json(pets, { status: 200 })
        });
}

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        petSchema,
        async (pet) => {
            const { data, error } = await PetRepository.upsert(pet as PetType)
            if (error) {
                return NextResponse.json(
                    { success: false, message: error.message },
                    { status: 500 }
                )
            }
            return NextResponse.json(data, { status: 201 })
        }
    )
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { BasicDataRepository } from '@/repos/index'
import { getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { BasicDataTypeSchema } from '@/schemas/validationSchemas';
import { BasicDataType } from '@/types/index';
import { RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ petId: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { petId } = await params;
            const data = await BasicDataRepository.findByPetId(petId);
            return NextResponse.json(data);
        });
}

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        BasicDataTypeSchema,
        async (basicData) => {
            try {
                const { data, error } = await BasicDataRepository.upsert(basicData as BasicDataType);
                if (error) {
                    return NextResponse.json(
                        { success: false, message: `Error upserting record: ${error.message}` },
                        { status: 500 }
                    )
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error upserting record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/pets/exists/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const id = getRequiredQueryParam(req, "id");

    const exists = await PetRepository.existsById(id);
    return NextResponse.json({ success: true, exists });
  });
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getWithErrorHandling, withErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { Empty } from '@/data/index';
import { RepositoryError, StepsStateType, StepStateError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            const step = getStep(req);
            if (step.repository) {
                try {
                    const data = await step.repository.findByParentId(id);
                    return NextResponse.json(data);
                }
                catch {
                    throw new RepositoryError("Error getting records");
                }
            }
            throw new StepStateError("Missing repository");
        });
}

export async function POST(req: NextRequest) {
    const step = getStep(req);
    return withValidationAndErrorHandling(
        'POST',
        req,
        step.schema,
        async (list) => {
            if (step.repository) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const { data, error } = await step.repository.createAll(list as any[])
                    if (error) {
                        throw new RepositoryError(error.message);
                    }
                    return NextResponse.json(data, { status: 201 });
                }
                catch {
                    throw new RepositoryError("Error upserting records");
                }
            }
            throw new StepStateError("Missing repository");
        }
    );
}

export async function DELETE(req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }) {
    const step = getStep(req);
    return withErrorHandling(
        'DELETE',
        req,
        async () => {
            const { id } = await params;
            if (step.repository) {
                const response = await step.repository.delete(id);
                if (!response) {
                    throw new RepositoryError("Error deleting record");
                }
                return NextResponse.json({ success: true, message: "Se eliminó correctamente el registro" }, { status: 200 });
            }
            throw new StepStateError("Missing repository");
        }
    )
}

function getStep(req: NextRequest): StepsStateType {
    const filter = Empty.Steps().filter(s => req.url.includes(s.url || "") && s.repository);
    if (filter.length == 0) {
        throw new StepStateError("Missing step");
    }
    else if (filter.length > 1) {
        throw new StepStateError("Too many steps");
    }
    else {
        return filter[0];
    }
} 
----- Archivo: route.tsx ----- 
// app/api/pets/me/code/route.ts
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";

export async function POST(req: Request) {
  try {
    const { owner_id, pet_id } = await req.json();

    // 1) Mascota del owner
    const pet = await PetRepository.findByOwnerIdAndPetId(owner_id, pet_id);
    if (!pet) {
      return NextResponse.json(
        { error: "Mascota no encontrada" },
        { status: 404 }
      );
    }

    // 2) Invalida códigos anteriores
    await PetCodeRepository.invalidateAll(pet_id);

    // 3) Crea nuevo código
    const ttl = parseInt(process.env.CODE_EXPIRE_AT!);
    const code = await PetCodeRepository.create(pet_id, ttl);

    return NextResponse.json({ code });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    const msg = err.message.includes("No autorizado")
      ? { error: "No autorizado" }
      : { error: err.message || "Error interno" };
    const status = msg.error === "No autorizado" ? 401 : 500;
    return NextResponse.json(msg, { status });
  }
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.ts (resumiendo lo anterior)
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { PetRepository } from "@/repos/index";
import { getWithErrorHandling, withValidationAndErrorHandling } from "@/services/apiService";
import { PetType } from "@/types/index";
import { RepositoryError } from "@/types/lib";

const updatePetSchema = z.object({
  name: z.string().optional(),
  image: z.string().url().optional(),
});

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  return getWithErrorHandling(
    req,
    async () => {
      const { id } = await params;
      const pets = await PetRepository.findById(id)
      return NextResponse.json(pets, { status: 200 })
    });
}

export async function PATCH(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  return withValidationAndErrorHandling(
    "PATCH",
    req,
    updatePetSchema,
    async (updates) => {
      const { id } = await params;
      const updated = await PetRepository.updateById(id, updates as Partial<PetType>);
      if (!updated) {
        return NextResponse.json(
          { success: false, message: "Mascota no encontrada" },
          { status: 404 }
        );
      }
      return NextResponse.json(
        { success: true, message: "Actualizado correctamente" },
        { status: 200 }
      );
    }
  );
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  return getWithErrorHandling(req, async () => {
    const { id } = await params;
    const deleted = await PetRepository.deleteById(id);
    if (!deleted) {
      throw new RepositoryError("Mascota no encontrada");
    }
    return NextResponse.json(
      { success: true, message: "Eliminado correctamente" },
      { status: 200 }
    );
  });
} 
----- Archivo: route.ts ----- 
// src/app/api/plans/current/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PlanRepository } from "@/repos/index";
import { getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const plans = await PlanRepository.getAllCurrent();
    return NextResponse.json({ success: true, plans });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/plans/subscriptions/route.ts
import { NextRequest, NextResponse } from "next/server";
import { SubscriptionRepository } from "@/repos/index";
import { withValidationAndErrorHandling } from "@/services/apiService";
import { z } from "zod";
import { CreateSubscriptionType } from "@/types/index";

const SubscriptionSchema = z.object({
  ownerId: z.string(),
  planVersionId: z.string(),
  cycle: z.enum(["monthly", "annual"]),
  priceAtPurchase: z.number(),
  discountApplied: z.number()
});

export async function POST(req: NextRequest) {
  return withValidationAndErrorHandling("POST", req, SubscriptionSchema, async (data: CreateSubscriptionType) => {
    const result = await SubscriptionRepository.create(data);
    return NextResponse.json({ success: true, subscription: result });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/plans/subscription/[ownerId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { SubscriptionRepository } from "@/repos/index";
import { getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest, { params }: { params: Promise<{ ownerId: string }> }) {
    return getWithErrorHandling(req, async () => {
        const { ownerId } = await params;
        const subscription = await SubscriptionRepository.getActiveByOwner(ownerId);
        return NextResponse.json({ success: true, data: subscription });
    });
}
 
----- Archivo: route.ts ----- 
// src/app/api/veterinarians/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import type { VeterinarianType } from '@/types/index';
import { VeterinarianTypeSchema } from '@/schemas/validationSchemas';
import VeterinarianRepository from '@/repos/veterinarian.repository';

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        VeterinarianTypeSchema,
        async (vetData: VeterinarianType) => {
            try {
                const { data, error } = await VeterinarianRepository.create(vetData);
                if (error) {
                    console.log(error);
                    throw new RepositoryError(
                        `Error creating veterinarian: ${JSON.stringify(vetData)}`
                    );
                }
                return NextResponse.json(data, { status: 201 });
            } catch(err) {
                console.log(err);
                throw new RepositoryError('Error creating veterinarian');
            }
        }
    );
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.tsx
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";

interface UpdateBody {
    code: string;
    name?: string;
    image?: string;
}
export async function PUT(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { code, ...updates } = (await req.json()) as UpdateBody;
    if (!code) {
      return NextResponse.json({ error: "Código requerido." }, { status: 400 });
    }

    // 1) Validar código
    const codeData = await PetCodeRepository.find(code);
    if (!codeData) {
      return NextResponse.json({ error: "Código inválido." }, { status: 401 });
    }
    if (new Date(codeData.expires_at) < new Date()) {
      return NextResponse.json(
        { error: "Código expirado." },
        { status: 410 }
      );
    }
    if (codeData.pet_id !== id) {
      return NextResponse.json(
        { error: "Código no corresponde a esta mascota." },
        { status: 403 }
      );
    }

    // 2) Actualizar pet
    await PetRepository.updateById(id, updates);
    return NextResponse.json({ success: true });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
} 
----- Archivo: route.tsx ----- 
// app/api/vet/use-code/route.ts
import { NextResponse } from "next/server";
import { PetCodeRepository, VeterinaryAccessRepository } from "@/repos/index";

export async function POST(req: Request) {
  try {
    const {
      code,
      firstName,
      lastName,
      registration,
      clinicName,
      city,
    } = await req.json();

    // 1) Obtener y validar código
    const data = await PetCodeRepository.find(code);
    if (!data) {
      return NextResponse.json({ error: "Código inválido" }, { status: 404 });
    }
    const now = new Date().toISOString();
    if (data.used) {
      return NextResponse.json({ error: "Código ya utilizado" }, { status: 410 });
    }
    if (data.expires_at < now) {
      return NextResponse.json({ error: "Código expirado" }, { status: 410 });
    }

    // 2) Marcar como usado
    await PetCodeRepository.markUsed(code);

    // 3) Registrar acceso veterinario
    const vetAccess = await VeterinaryAccessRepository.create({
      pet_id: data.pet_id,
      pet_code_id: data.id,
      vet_first_name: firstName,
      vet_last_name: lastName,
      professional_registration: registration,
      clinic_name: clinicName,
      city,
    });

    // 4) Devolver petId
    return NextResponse.json({ success: true, pet_id: data.pet_id, pet_code: data.id, vet_access: vetAccess.id });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
}
 
----- Archivo: route.ts ----- 
// src/app/api/vet-access/validate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetCodeRepository, PetRepository, VeterinaryAccessRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";

export async function GET(req: NextRequest) {
  return getWithErrorHandling(req, async () => {
    const code = getRequiredQueryParam(req, "code");

    // 1. Validar código
    const codeRecord = await PetCodeRepository.find(code);
    if (!codeRecord) {
      return NextResponse.json({ success: false, message: "Código inválido." }, { status: 404 });
    }

    // 2. Validar expiración
    if (new Date(codeRecord.expires_at) < new Date()) {
      return NextResponse.json({ success: false, message: "Código expirado." }, { status: 403 });
    }

    // 3. Buscar mascota
    const pet = await PetRepository.findById(codeRecord.pet_id);
    if (!pet) {
      return NextResponse.json({ success: false, message: "Mascota no encontrada." }, { status: 404 });
    }

    // 4. Buscar acceso del veterinario (si existe)
    const vetAccess = await VeterinaryAccessRepository.findByCodeAndByPetId(code, pet.id);

    return NextResponse.json({
      success: true,
      pet,
      codeRecord,
      vetAccess
    });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/veterinarians/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import VeterinarianRepository from '@/repos/veterinarian.repository';
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError('Falta parámetro VeterinarianId');
            }

            const vetData = await VeterinarianRepository.findById(id);
            if (!vetData) {
                throw new RepositoryError(`Veterinario no encontrado: ${id}`);
            }
            return NextResponse.json(vetData);
        }
    );
}
 
----- Archivo: layout.tsx ----- 
// app/pages/auth/verify/layout.tsx
export default function AuthVerifyLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/pages/auth/verify/page.tsx
"use client";
import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { authClient } from "@/lib/auth"; // Importar authClient directamente
import LoadingComponent from "@/components/lib/loading"; // Un componente de carga

export default function VerifyEmailPage() { // Renombrado para claridad
  const router = useRouter();
  const searchParams = useSearchParams(); // Hook para leer query params en App Router

  const [message, setMessage] = useState("Verificando tu correo… Por favor espera.");
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const access_token = searchParams.get("access_token");
    const refresh_token = searchParams.get("refresh_token");
    //const type = searchParams.get("type"); // ej. 'signup', 'recovery', 'magiclink'
    const error_description = searchParams.get("error_description");

    if (error_description) {
      setMessage(`Error: ${error_description}`);
      setIsLoading(false);
      setTimeout(() => router.replace("/login"), 5000); // Redirigir al login después de un error
      return;
    }

    const handleSessionFromURL = async () => {
      if (access_token && refresh_token) {
        try {
          // Llama directamente a authClient.setSession o a tu wrapper en authService
          await authClient.setSession({ access_token, refresh_token });
          // Después de setSession, Supabase JS SDK debería actualizar su estado interno.
          // onAuthStateChange debería dispararse.
          // Redirigir a la página post-verificación/login
          router.replace("/pages/owner/register"); // O al dashboard principal
        } catch (err) {
          console.error("Error al establecer sesión desde URL:", err);
          setMessage("Hubo un problema al verificar tu sesión. Serás redirigido al login.");
          setTimeout(() => router.replace("/login"), 3000);
        } finally {
          setIsLoading(false);
        }
      } else {
        // Si no hay tokens en la URL, podría ser una visita directa o un error.
        // Intentar obtener la sesión actual para ver si ya está autenticado.
        checkExistingSession();
      }
    };

    const checkExistingSession = async () => {
      try {
        const session = await authClient.getSession();
        if (session) {
          // Ya hay una sesión, quizás el usuario ya verificó y volvió.
          // No es necesario llamar a setAuthSession si getAuthSession ya la devuelve.
          router.replace("/pages/owner/register"); // O al dashboard
        } else {
          // No hay tokens en URL y no hay sesión activa
          setMessage("No se pudo verificar la sesión. Es posible que el enlace haya expirado o ya haya sido utilizado. Serás redirigido al login.");
          setTimeout(() => router.replace("/login"), 5000);
        }
      } catch (err) {
        console.error("Error al verificar sesión existente:", err);
        setMessage("Error al verificar tu estado. Serás redirigido al login.");
        setTimeout(() => router.replace("/login"), 3000);
      } finally {
        setIsLoading(false);
      }
    };

    // Flujo principal:
    // Supabase Auth Helpers y onAuthStateChange deberían manejar la sesión
    // automáticamente cuando el usuario es redirigido de vuelta a la app
    // después de hacer clic en el enlace de verificación, si los tokens están en el hash (#)
    // y no en los query params (?).
    // Si los tokens SÍ vienen como query params (access_token, refresh_token),
    // entonces la lógica de handleSessionFromURL es necesaria.

    // Supabase por defecto ahora usa fragmentos (#) para los tokens de recuperación de sesión.
    // El SDK de Supabase JS (browserClient) debería detectar estos fragmentos automáticamente
    // al cargar la página y disparar onAuthStateChange.

    // Verificamos si hay un evento de 'SIGNED_IN' pendiente debido a un hash.
    // Si no, procedemos con la lógica de query params.
    const { data: authListener } = authClient.onAuthStateChange(
      async (event, session) => {
        if (event === "SIGNED_IN" && session) {
          setIsLoading(false);
          // La sesión se estableció por el SDK a través del hash.
          router.replace("/pages/owner/register"); // O al dashboard
          authListener?.unsubscribe(); // Limpiar el listener una vez usado
        } else if (event === "INITIAL_SESSION") {
          // Si hay una sesión inicial pero no fue por SIGNED_IN (hash),
          // puede que los tokens vengan por query params.
          authListener?.unsubscribe(); // Ya no necesitamos este listener específico.
          handleSessionFromURL();
        } else if (event === 'USER_UPDATED' && session) {
          // Podría ser el caso después de un reset de contraseña exitoso
          setIsLoading(false);
          router.replace("/"); // O al dashboard
          authListener?.unsubscribe();
        }
      }
    );

    // Si después de un breve tiempo no hubo evento SIGNED_IN (por hash),
    // y no estamos ya manejando query_params, procedemos con query_params.
    // Esto es un fallback por si el listener no captura el hash a tiempo.
    const fallbackTimer = setTimeout(() => {
      if (isLoading) { // Solo si todavía estamos cargando (el listener no resolvió)
        authListener?.unsubscribe();
        console.log("Fallback: onAuthStateChange no capturó SIGNED_IN por hash, intentando con query params.");
        handleSessionFromURL();
      }
    }, 1500); // Esperar 1.5 segundos

    return () => {
      authListener?.unsubscribe();
      clearTimeout(fallbackTimer);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [router, searchParams]); // searchParams como dependencia

  if (isLoading) {
    return <LoadingComponent />;
  }

  return (
    <div style={{ padding: "2rem", textAlign: "center", maxWidth: '500px', margin: 'auto' }}>
      <h1>Verificación</h1>
      <p>{message}</p>
      {!isLoading && <button onClick={() => router.push('/login')}>Ir a Iniciar Sesión</button>}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
'use client'
export default function ErrorPage() {
  return <p>Sorry, something went wrong</p>
} 
----- Archivo: layout.tsx ----- 
// app/login/layout.tsx
export default function LoginLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/login/page.tsx
"use client";
import React, { FormEvent, useState, useEffect } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import Image from "next/image";

import type { OwnerDataType } from "@/types/index";
import { FaEye, FaEyeSlash } from "react-icons/fa";
import ModalComponent from "@/components/lib/modal";
import { authClient } from "@/lib/auth";
import { useSessionContext } from "@/context/SessionProvider";

export default function LoginPage() {
  const router = useRouter();
  const { db: session, setSession } = useSessionContext();

  // Estados comunes
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isRegistering, setIsRegistering] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [infoMessage, setInfoMessage] = useState(""); // Para mensajes como "Revisa tu correo"
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  // Estados adicionales para registro
  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "",
    country: "",
    email: "" // Se llenará desde el campo de email común
  });

  // Redirigir si ya hay sesión
  useEffect(() => {
    if (session) {
      router.replace("/"); // O a la página de dashboard
    }
  }, [session, router]);


  const handleAuth = async (e: FormEvent) => {
    e.preventDefault();
    setError("");
    setInfoMessage("");
    setLoading(true);

    try {
      if (isRegistering) {
        // 1) Registro vía authClient
        const { data: signUpData, error: signUpError } = await authClient.signUp(email, password, 'owner');

        if (signUpError || !signUpData?.user) {
          console.error("Signup error:", signUpError);
          setError(signUpError?.message || "Error al registrar el usuario. Inténtalo de nuevo.");
          setLoading(false);
          return;
        }

        const ownerId = signUpData.user.id;

        // 2) Guardar datos del owner (esto SÍ requiere tu API `api/owners`)
        if (ownerId) {
          // Usar fetch directamente o tu wrapper `postFetch` si aún lo tienes para otras APIs
          const response = await fetch('/api/owners', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              ...ownerInfo,
              owner_id: ownerId,
              email // Asegúrate que el email del owner sea el mismo del auth
            }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            setError(errorData.message || "Error creando el perfil del dueño.");
            // Considerar un rollback o manejo de error si el perfil no se crea después del auth.
            setLoading(false);
            return;
          }
        }
        // Si el registro en Supabase requiere confirmación por email, mostrar el modal.
        // Si no (auto-confirm está habilitado), Supabase podría devolver una sesión directamente.
        if (signUpData.user && !signUpData.user.email_confirmed_at) { // O si Supabase devuelve una sesión nula aquí
          setShowConfirmModal(true);
        } else if (signUpData.user?.email_confirmed_at) { // Auto-confirmado o ya confirmado
          // Supabase client JS debería manejar la sesión. Redirigir.
          router.push('/pages/owner/register'); // O al dashboard/ruta post-login
        }

      } else {
        // Inicio de sesión
        const { data: signInData, error: signInError } = await authClient.signIn(email, password);

        if (signInError || !signInData?.session) {
          console.error("LOGIN FAILED:", signInError);
          setError(signInError?.message || "Email o contraseña incorrectos.");
          setLoading(false);
          return;
        }
        setSession(signInData.session);

        router.replace('/');
      }
    } catch (err) {
      console.error("Auth CATCH block error:", err);
      setError("Ocurrió un error inesperado. Por favor, inténtalo de nuevo.");
    }
    setLoading(false);
  };

  const handleResetPassword = async () => {
    setError("");
    setInfoMessage("");
    if (!email) {
      setError("Ingresa tu correo para restablecer la contraseña.");
      return;
    }
    setLoading(true);
    try {
      const { error: resetError } = await authClient.resetPassword(email);
      if (resetError) {
        setError(resetError.message || "Error al enviar el correo de recuperación.");
      } else {
        setInfoMessage("Revisa tu correo para restablecer la contraseña.");
      }
    } catch {
      setError("Ocurrió un error inesperado.");
    }
    setLoading(false);
  };

  const goToVetPage = () => {
    router.push("/vet-access"); // Usar router.push
  }

  const handleModalContinue = async () => {
    // Si el usuario hace clic en "Ya confirmé", intentamos obtener la sesión actual.
    // Si Supabase ya procesó la confirmación (el usuario hizo clic en el enlace del email),
    // debería haber una sesión.
    setShowConfirmModal(false);
    setLoading(true);
    // Podríamos intentar forzar un re-fetch de la sesión o simplemente redirigir
    // y dejar que useAuthRedirect maneje la lógica si la sesión existe.
    // router.refresh(); // Podría ayudar a que onAuthStateChange se dispare si hubo cambios

    // Si el usuario ya está logueado (quizás confirmó en otra pestaña y volvió)
    // o si la sesión se estableció de alguna manera.
    const currentSession = await authClient.getSession();
    if (currentSession) {
      router.push("/pages/owner/register"); // O al dashboard
    } else {
      // Si aún no hay sesión, puede que el usuario no haya confirmado realmente
      // o haya un retraso. Podríamos mostrar un mensaje o simplemente volver al login.
      // Por ahora, lo mantenemos simple, el usuario puede intentar loguearse.
      setInfoMessage("Si ya confirmaste tu correo, intenta iniciar sesión.");
    }
    setLoading(false);
  }

  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal} // Permite cerrar el modal
      >
        <button
          className="contrast"
          onClick={handleModalContinue}
          style={{ width: "100%", marginTop: "1rem" }}
          aria-busy={loading}
          disabled={loading}
        >
          {loading ? "Verificando..." : "Ya confirmé, continuar"}
        </button>
      </ModalComponent>
    );
  }

  // Renderizar el formulario de login/registro
  return (
    <main
      style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        minHeight: "100vh", // Asegurar que ocupe toda la altura
        background: "#F9FAFB",
        padding: "1rem", // Espacio por si el form es muy grande en móviles
      }}
    >
      <article // Cambiado de form a article para que PicoCSS no aplique estilos de form globales aquí si no queremos
        style={{
          background: "#fff",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
          width: "100%",
          maxWidth: "550px",
        }}
      >
        <form onSubmit={handleAuth}> {/* Formulario interno */}
          <div style={{ textAlign: "center", marginBottom: "1.5rem" }}>
            <Image loading={"lazy"} src="/logo.png" alt="Lampo" width="150" height="48" style={{ width: "auto", height: "auto", marginBottom: '10px' }} />
            <h1>{isRegistering ? "Regístrate" : "Inicia sesión"}</h1>
          </div>

          {isRegistering && (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
              {/* Campos de OwnerInfo */}
              <label htmlFor="name">
                Nombre
                <input id="name" type="text" autoComplete="given-name" value={ownerInfo.name || ""} onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })} required />
              </label>
              <label htmlFor="lastname">
                Apellido
                <input id="lastname" type="text" autoComplete="family-name" value={ownerInfo.last_name || ""} onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })} required />
              </label>
              <label htmlFor="phone">
                Teléfono
                <input id="phone" type="tel" autoComplete="tel" value={ownerInfo.phone || ""} onChange={e => setOwnerInfo({ ...ownerInfo, phone: e.target.value })} required />
              </label>
              <label htmlFor="address">
                Dirección
                <input id="address" type="text" autoComplete="address-line1" value={ownerInfo.address || ""} onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })} required />
              </label>
              <label htmlFor="city">
                Ciudad
                <input id="city" type="text" autoComplete="address-level2" value={ownerInfo.city || ""} onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })} required />
              </label>
              <label htmlFor="country">
                País
                <input id="country" type="text" autoComplete="country-name" value={ownerInfo.country || ""} onChange={e => setOwnerInfo({ ...ownerInfo, country: e.target.value })} required />
              </label>
            </div>
          )}

          <label htmlFor="email">
            Email
            <input id="email" type="email" autoComplete="email" value={email} onChange={(e) => setEmail(e.target.value)} required />
          </label>

          <label htmlFor="password" style={{ position: 'relative', display: 'block', marginBottom: '1rem' }}>
            Contraseña
            <input
              id="password"
              type={showPassword ? "text" : "password"}
              autoComplete={isRegistering ? 'new-password' : 'current-password'}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              style={{ paddingRight: '3rem' }} // Espacio para el ícono
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
              style={{
                position: 'absolute',
                right: '0.5rem', // Ajuste para que no esté tan pegado al borde del input
                top: 'calc(50% + 8px)', // Ajustar para centrarlo verticalmente respecto al input
                transform: 'translateY(-50%)',
                background: 'none',
                border: 'none',
                padding: '0.25rem',
                cursor: 'pointer',
                color: '#555' // Color del ícono
              }}
            >
              {showPassword ? <FaEyeSlash size={20} /> : <FaEye size={20} />}
            </button>
          </label>

          {error && <p role="alert" style={{ color: "var(--pico-form-element-invalid-active-border-color, red)", marginTop: "0.5rem" }}>{error}</p>}
          {infoMessage && <p role="status" style={{ color: "var(--pico-primary)", marginTop: "0.5rem" }}>{infoMessage}</p>}


          <button type="submit" disabled={loading} aria-busy={loading} style={{ width: "100%", marginTop: "1rem" }}>
            {loading ? (isRegistering ? "Registrando..." : "Accediendo...") : (isRegistering ? "Registrarse" : "Entrar")}
          </button>
        </form>

        {!isRegistering && (
          <p style={{ textAlign: "right", marginTop: "0.5rem" }}>
            <button type="button" onClick={handleResetPassword} className="contrast" disabled={loading} style={{ background: "none", border: "none", padding: 0, cursor: "pointer", color: "var(--pico-primary-focus)" }}>
              ¿Olvidaste tu contraseña?
            </button>
          </p>
        )}

        <p style={{ textAlign: "center", marginTop: "1rem" }}>
          {isRegistering ? "¿Ya tienes cuenta?" : "¿No tienes cuenta?"}
          <button type="button" onClick={() => { setIsRegistering(!isRegistering); setError(""); setInfoMessage(""); }} disabled={loading} style={{ background: "none", border: "none", color: "var(--pico-primary)", cursor: "pointer", marginLeft: "0.25rem", textDecoration: "underline" }}>
            {isRegistering ? "Inicia sesión" : "Regístrate"}
          </button>
        </p>

        {!isRegistering && (
          <p style={{ textAlign: "center", marginTop: "1rem" }}>
            <button type="button" onClick={goToVetPage} disabled={loading} style={{ background: "none", border: "none", color: "var(--pico-primary)", cursor: "pointer", textDecoration: "underline" }}>
              Soy médico veterinario sin registro
            </button>
          </p>
        )}
      </article>
    </main>
  );
} 
----- Archivo: index.ts ----- 
// app/pages/index.tsx
export { default as BasicDataPage } from "./pet/basic-data/page";
export { default as CalendarPage } from "./pet/calendar/page";
export { default as ConditionsPage } from "./pet/conditions/page";
export { default as LabTestsPage } from "./pet/lab-tests/page";
export { default as LoginPage } from "../login/page";
export { default as MedicinesPage } from "./pet/medicines/page";
export { default as SettingsPage } from "./owner/settings/page";
export { default as UpgradePage } from "./owner/upgrade/page";
export { default as VaccinesPage } from "./pet/vaccines/page";
export { default as VetPage } from "./vet/[code]/page";
export { default as OwnerSettings } from "./owner/settings/page"; 
----- Archivo: page.tsx ----- 
// app/pages/owner/register/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { FaCheck } from "react-icons/fa";
import { PlanVersionType } from "@/types/index";
import { useRouter } from "next/navigation";
import { useSession } from "@/hooks/useSession";
import { getFetch, postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";

export default function RegisterPage() {
    useSession();
    const router = useRouter();
    const [plans, setPlans] = useState<PlanVersionType[]>([]);
    const [cycles, setCycles] = useState<Record<string, "monthly" | "annual">>(
        {}
    );
    const [loading, setLoading] = useState<boolean>(false);
    const session = useSessionContext();

    useEffect(() => {
        async function load() {
            try {
                const response = await getFetch("/api/plans/current");
                const json = await response.json();
                if (json.success) {
                    const data = json.plans;
                    setPlans(data);

                    const initialCycles: Record<string, "monthly" | "annual"> = {};
                    data.forEach((p: PlanVersionType) => {
                        initialCycles[p.id.toString()] = "monthly";
                    });
                    setCycles(initialCycles);
                } else {
                    console.error("Error obteniendo planes:", json.message);
                }
            } catch (err) {
                console.error("Error en petición de planes:", err);
            }
        }
        load();
    }, []);

    // Validar sesión
    if (!session?.db?.user?.id) {
        console.error("No hay sesión activa o falta el user.id");
        return null;
    }

    const ownerId = session?.db?.user?.id;

    const handleCycle = (planId: string, cycle: "monthly" | "annual") => {
        setCycles((prev) => ({ ...prev, [planId]: cycle }));
    };

    const formatPrice = (cents: number) =>
        new Intl.NumberFormat("es-CO", {
            style: "currency",
            currency: "USD",
            minimumFractionDigits: 2,
        }).format(cents / 100);

    const handleSelect = async (plan: PlanVersionType) => {
        setLoading(true);
        try {
            const cycle = cycles[plan.id.toString()];
            const priceAtPurchase = cycle === "annual" ? plan.price_year : plan.price_month;
            const discountApplied = cycle === "annual" ? plan.discount_year : plan.discount_month;

            const response = await postFetch("/api/plans/subscriptions", undefined, {
                ownerId,
                planVersionId: plan.id.toString(),
                cycle,
                priceAtPurchase,
                discountApplied
            });
            const json = await response.json();

            if (!response.ok || !json.success) {
                throw new Error(json.message || "Error al crear suscripción");
            }

            router.replace("/pages/pet/register");
        } catch (e) {
            console.error("Error creando suscripción:", e);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main style={{ padding: "2rem", background: "#F9FAFB" }}>
            <div
                style={{
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(260px, 1fr))",
                    gap: "1.5rem",
                }}
            >
                {plans.map((plan) => {
                    const key = plan.id.toString();
                    const cycle = cycles[key] || "monthly";
                    const isStandard = plan.slug === "standard";
                    const borderColor = "#3B82F6";
                    const darkBg = isStandard;
                    const cardStyle: React.CSSProperties = darkBg
                        ? { background: "#0B1446", color: "#fff", borderRadius: "8px" }
                        : { border: `2px solid ${borderColor}`, background: "#fff", borderRadius: "8px" };

                    const discountMonthlyLabel =
                        plan.discount_month > 0 ? `${plan.discount_month}% Descuento` : undefined;
                    const discountYearLabel =
                        plan.discount_year > 0 ? `${plan.discount_year}% Descuento` : undefined;

                    return (
                        <article
                            key={plan.id}
                            style={{ ...cardStyle, padding: "2rem", position: "relative" }}
                        >
                            {plan.slug === "standard" && (
                                <span
                                    style={{
                                        position: "absolute",
                                        top: "1rem",
                                        left: "1rem",
                                        background: borderColor,
                                        color: "#fff",
                                        fontSize: "0.75rem",
                                        padding: "0.25rem 0.75rem",
                                        borderRadius: "4px",
                                        textTransform: "uppercase",
                                    }}
                                >
                                    Popular
                                </span>
                            )}
                            {(plan.slug === "standard" || plan.slug === "advanced") && (
                                <div
                                    style={{
                                        display: "flex",
                                        border: darkBg ? "none" : `1px solid ${borderColor}`,
                                        borderRadius: "4px",
                                        overflow: "hidden",
                                        marginBottom: "1rem",
                                        background: darkBg ? "rgba(255,255,255,0.1)" : undefined,
                                    }}
                                >
                                    <button
                                        onClick={() => handleCycle(key, "monthly")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "monthly" ? "#fff" : "transparent",
                                            color: darkBg ? "#fff" : "#111",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                        }}
                                    >
                                        Mensual
                                        {cycle === "monthly" && discountMonthlyLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "#FBBF24",
                                                    color: "#111827",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {discountMonthlyLabel}
                                            </span>
                                        )}
                                    </button>
                                    <button
                                        onClick={() => handleCycle(key, "annual")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "annual" ? "#fff" : "transparent",
                                            color: darkBg ? "#fff" : "#111",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                            position: "relative",
                                        }}
                                    >
                                        Anual
                                        {cycle === "annual" && discountYearLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "#FBBF24",
                                                    color: "#111827",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {discountYearLabel}
                                            </span>
                                        )}
                                    </button>
                                </div>
                            )}

                            <h3 style={{ marginTop: isStandard ? "2rem" : 0, marginBottom: "0.5rem" }}>
                                {plan.title}
                            </h3>
                            <p
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1rem",
                                    opacity: darkBg ? 0.75 : 1,
                                }}
                            >
                                {plan.description}
                            </p>

                            <div style={{ fontSize: "2rem", fontWeight: 700, marginBottom: "0.25rem" }}>
                                {cycle === "annual"
                                    ? formatPrice(plan.price_year)
                                    : formatPrice(plan.price_month)}
                            </div>
                            <div
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1.5rem",
                                    opacity: 0.75,
                                }}
                            >
                                {cycle === "annual"
                                    ? "Por usuario, por año"
                                    : "Por usuario, por mes"}
                            </div>

                            <ul style={{ listStyle: "none", padding: 0, marginBottom: "1.5rem" }}>
                                {plan.features.map((feat, idx) => (
                                    <li
                                        key={idx}
                                        style={{ display: "flex", alignItems: "center", marginBottom: "0.5rem" }}
                                    >
                                        <FaCheck
                                            style={{
                                                marginRight: "0.5rem",
                                                color: darkBg ? "#FBBF24" : borderColor,
                                            }}
                                        />
                                        <span style={{ fontSize: "0.875rem" }}>{feat.text}</span>
                                        {feat.badge && (
                                            <span
                                                style={{
                                                    marginLeft: "0.5rem",
                                                    background: "#10B981",
                                                    color: "#fff",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {feat.badge}
                                            </span>
                                        )}
                                    </li>
                                ))}
                            </ul>

                            <button
                                onClick={() => handleSelect(plan)}
                                className="contrast"
                                style={{
                                    width: "100%",
                                    padding: "0.75rem",
                                    fontWeight: 600,
                                    fontSize: "1rem",
                                    opacity: loading ? 0.6 : 1,
                                    cursor: loading ? "not-allowed" : "pointer",
                                }}
                                disabled={loading}
                            >
                                {plan.slug === "free" ? "Selecciona este plan GRATIS" : "Continuar al pago"}
                            </button>
                        </article>
                    );
                })}
            </div>
        </main>
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/settings/page.tsx

"use client";
import { Title } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch, putFetch } from "@/app/api";
import type { OwnerDataType, PetType } from "@/types/index";
import React, { FormEvent, useEffect, useState } from "react";
import { FaCog, FaExclamationTriangle } from "react-icons/fa";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { Empty } from "@/data/index";
import { useRouter } from "next/navigation";

export default function SettingsPage() {
  const { isMobile } = useDeviceDetect();
  const router = useRouter();
  const session = useSessionContext();
  const storage = useStorageContext();
  const userId = session?.db?.user.id;
  const userEmail = session?.db?.user.email;

  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "",
    country: "",
    email: ""
  });

  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [confirmText, setConfirmText] = useState("");
  // asumo que en tu contexto tienes la mascota seleccionada:
  const pet: PetType | null = storage.storedPet;

  const [loadLoading, setLoadLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  useEffect(() => {
    if (!session || !userId) return;

    const fetchData = async () => {
      try {
        if (!storage.storedOwnerData.owner_id) {
          const res = await getFetch(`/api/owners/${encodeURIComponent(userId)}`);
          const json = await res.json();
          if (res.ok) {
            storage.setStoredOwnerData(json);
            setOwnerInfo(json);
          } else {
            console.error("Error al obtener owner:", json.error);
            setError("No se pudo cargar la información del dueño.");
            setFormFailed(true);
          }
        }
        else {
          setOwnerInfo(storage.storedOwnerData);
        }
      } catch (err) {
        console.error("Fetch owner error:", err);
        setError("Error de red al cargar datos.");
        setFormFailed(true);
      }
      finally {
        setLoadLoading(false);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [userId, session]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!userId) {
      setError("Usuario no identificado.");
      setFormFailed(true);
      return;
    }

    try {
      if (userEmail) {
        const payload: OwnerDataType = {
          owner_id: userId,
          name: ownerInfo.name || "",
          last_name: ownerInfo.last_name || "",
          phone: ownerInfo.phone || "",
          address: ownerInfo.address || "",
          city: ownerInfo.city || "",
          country: ownerInfo.country || "",
          email: userEmail
        };

        const res = await putFetch('/api/owners', undefined, payload);
        const json = await res.json();

        if (res.ok) {
          setError("Datos actualizados correctamente.");
          storage.setStoredOwnerData(payload);
          setFormFailed(false);
        } else {
          console.error("API error:", json.error);
          setError(json.error || "Error al guardar los cambios.");
          setFormFailed(true);
        }
      }
    } catch (err) {
      console.error("Submit error:", err);
      setError("Error de red al guardar cambios.");
      setFormFailed(true);
    }
  };

  const handleDelete = async () => {
    if (!pet) return;
    const res = await fetch(`/api/pets/${encodeURIComponent(pet.id)}`, {
      method: "DELETE",
    });
    if (res.ok) {
      // actualizar lista en el contexto
      storage.setStoredOwnerPets(
        storage.storedOwnerPets.filter((p) => p.id !== pet.id)
      );
      storage.setStoredPet(Empty.Pet());
      router.replace("/");
    } else {
      console.error("Error al eliminar mascota");
    }
  };

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      <section style={{ marginBottom: "2rem" }}>
        <Title icon={<FaCog />} title="Configuración del dueño" />
        <form
          onSubmit={handleSubmit}
          style={{ display: "grid", gap: "1rem" }}
        >
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
            <label htmlFor="name">
              Nombre
              <input
                id="name"
                type="text"
                autoComplete="given-name"
                disabled={loadLoading}
                value={ownerInfo.name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="lastname">
              Apellido
              <input
                id="lastname"
                type="text"
                autoComplete="family-name"
                disabled={loadLoading}
                value={ownerInfo.last_name || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })}
                required
              />
            </label>

            <label htmlFor="phone">
              Teléfono
              <input
                id="phone"
                type="tel"
                autoComplete="tel"
                disabled={loadLoading}
                value={ownerInfo.phone || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, phone: e.target.value })}
                required
              />
            </label>

            <label htmlFor="address">
              Dirección
              <input
                id="address"
                type="text"
                disabled={loadLoading}
                autoComplete="address-line1"
                value={ownerInfo.address || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })}
                required
              />
            </label>

            <label htmlFor="city">
              Ciudad
              <input
                id="city"
                type="text"
                disabled={loadLoading}
                autoComplete="address-level2"
                value={ownerInfo.city || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })}
                required
              />
            </label>

            <label htmlFor="country">
              País
              <input
                id="country"
                type="text"
                disabled={loadLoading}
                autoComplete="country-name"
                value={ownerInfo.country || ""}
                onChange={e => setOwnerInfo({ ...ownerInfo, country: e.target.value })}
                required
              />
            </label>
          </div>

          <button type="submit">
            Guardar cambios
          </button>

          {error && (
            <p style={{ color: formFailed ? "red" : "green" }}>{error}</p>
          )}
        </form>
      </section>


      {/* ——— Sección Danger Zone para eliminar mascota ——— */}
      {pet && storage.storedPet.id && (
        <section
          style={{
            marginTop: "3rem",
            padding: "1rem",
            border: "1px solid #d73a49",
            borderRadius: "6px",
          }}
        >
          <h3
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              color: "#d73a49",
            }}
          >
            <FaExclamationTriangle /> Danger Zone
          </h3>
          <p>Eliminar permanentemente la mascota seleccionada.</p>
          <button
            type="button"
            style={{
              backgroundColor: "#d73a49",
              color: "white",
              padding: "0.5rem 1rem",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
            onClick={() => setShowDeleteModal(true)}
          >
            Eliminar mascota
          </button>
        </section>
      )}

      {/* ——— Modal de confirmación ——— */}
      {showDeleteModal && pet && (
        <div
          style={{
            position: "fixed",
            inset: 0,
            backgroundColor: "rgba(0,0,0,0.5)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            zIndex: 1000,
          }}
        >
          <div
            style={{
              background: "white",
              padding: "2rem",
              borderRadius: "6px",
              width: "90%",
              maxWidth: "400px",
            }}
          >
            <h2>Confirmar eliminación</h2>
            <p>
              Escribe el nombre de la mascota{" "}
              <strong>{pet.name}</strong> para confirmar:
            </p>
            <input
              type="text"
              placeholder="Nombre de la mascota"
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              style={{
                width: "100%",
                padding: "0.5rem",
                marginTop: "0.5rem",
                marginBottom: "1rem",
                border: "1px solid #ccc",
                borderRadius: "4px",
              }}
            />
            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}
            >
              <button
                type="button"
                onClick={() => {
                  setShowDeleteModal(false);
                  setConfirmText("");
                }}
              >
                Cancelar
              </button>
              <button
                type="button"
                disabled={confirmText !== pet.name}
                style={{
                  backgroundColor: "#d73a49",
                  color: "white",
                  padding: "0.5rem 1rem",
                  border: "none",
                  borderRadius: "4px",
                  cursor:
                    confirmText === pet.name ? "pointer" : "not-allowed",
                  opacity: confirmText === pet.name ? 1 : 0.6,
                }}
                onClick={handleDelete}
              >
                Eliminar
              </button>
            </div>
          </div>
        </div>
      )}

    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/upgrade/page.tsx
"use client";
import React from "react";

export default function UpgradePage() {
    return (
        <div style={{ width: "100%" }}>
            <h2>Mejora tu plan</h2>
            <section style={{ width: "100%", marginBottom: "2rem" }}>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/basic-data/page.tsx (server component)
"use client";
import React, { useEffect, useState } from "react";
import { FaUser } from "react-icons/fa";
import { format } from "@/utils/dates";
import { BasicField, Loading, Title } from "@/components/index";
import { FieldType } from "@/types/lib";
import { BasicDataType, OwnerDataType } from "@/types/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";

export default function BasicDataPage() {
  const { isMobile } = useDeviceDetect();
  const storage = useStorageContext();
  const [petData, setPetData] = useState<BasicDataType | null>(null);
  const [ownerData, setOwnerData] = useState<OwnerDataType | null>(null);
  const [basicDataItems, setBasicDataItems] = useState<FieldType[]>([]);
  const [contactItems, setContactItems] = useState<FieldType[]>([]);

  useEffect(() => {
    const petId = storage.storedPet.id;
    if (!petId || storage.storedBasicData.pet_id) {
      setPetData(storage.storedBasicData);
      return;
    }

    const fetchData = async () => {
      try {
        // 1) Datos básicos de la mascota
        const resPet = await getFetch(`/api/pets/basic-data/${storage.storedPet.id}`);
        if (!resPet.ok) throw new Error("Falló fetch basic-data");
        const basicData: BasicDataType = await resPet.json();
        storage.setStoredBasicData(basicData);
        setPetData(basicData);
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedBasicData]);


  useEffect(() => {
    const ownerId = storage.storedPet.owner_id;
    if (!ownerId || storage.storedOwnerData.owner_id) {
      setOwnerData(storage.storedOwnerData);
      return;
    }
    const fetchData = async () => {
      try {
        const resOwner = await getFetch(`/api/owners/${storage.storedPet.owner_id}`);
        if (!resOwner.ok) throw new Error("Falló fetch owners");
        const owner: OwnerDataType = await resOwner.json();
        storage.setStoredOwnerData(owner);
        setOwnerData(owner);
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedOwnerData]);

  useEffect(() => {
    if (!petData) return;
    setBasicDataItems([
      { label: "Tipo de mascota", show: true, value: petData.pet_type },
      { label: "Género", show: true, value: petData.gender },
      { label: "Peso", show: true, value: petData.weight },
      { label: "Raza", show: true, value: petData.race },
      { label: "Alergias", show: true, value: petData.has_allergies ? 'Si' : 'No' },
      { label: "Condición de peso", show: true, value: petData.weight_condition },
      { label: "Tamaño", show: true, value: petData.size },
      { label: "Vive con otros", show: true, value: petData.lives_with_others ? 'Si' : 'No' },
      { label: "Comida principal", show: true, value: petData.main_food },
      { label: "Última vacuna", show: true, value: petData.has_vaccine ? (`${petData.last_vaccine_name} (${format(petData.last_vaccine_date)})`) : 'No tiene vacunas' },
      { label: "Castrado", show: true, value: petData.is_castrated ? (`Sí (${format(petData.castration_date)})`) : 'No' },
      { label: "Antipulgas", show: true, value: petData.has_anti_flea ? (`Sí (${format(petData.anti_flea_date)})`) : 'No' },
      { label: "¿Usa medicina?", show: true, value: petData.uses_medicine ? 'Si' : 'No' },
      { label: "Condición especial", show: true, value: petData.special_condition ? 'Si' : 'No' },
    ]);
  }, [petData]);


  useEffect(() => {
    if (!ownerData) return;
    setContactItems([
      { label: "Nombre del contacto", show: true, value: ownerData.name },
      { label: "Teléfono", show: ownerData.phone != null, value: ownerData.phone },
      { label: "Dirección", show: ownerData.address != null, value: ownerData.address },
      { label: "Ciudad", show: true, value: ownerData.city },
      { label: "País", show: true, value: ownerData.country },
      { label: "Email", show: true, value: ownerData.email },
    ]);
  }, [ownerData]);

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      {/* Datos básicos en tres columnas */}
      <section style={{ marginBottom: "2rem" }}>
        {<Title icon={<FaUser />} title="Datos básicos" />}
        {!petData &&
          <Loading />
        }
        {petData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "1rem" }}>
            {basicDataItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
      <section>
        {<Title icon={<FaUser />} title="Datos de contacto" />}
        {!ownerData &&
          <Loading />
        }
        {ownerData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "1rem" }}>
            {contactItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
    </main>
  );
}

 
----- Archivo: page.tsx ----- 
// app/pages/pet/calendar/page.tsx (server component)
"use client";
import { Title } from "@/components/index";
import { useRoleContext } from "@/context/RoleProvider";
import React from "react";
import { FaCalendar } from "react-icons/fa";

export default function CalendarPage() {
    const { isVet } = useRoleContext();

    if (isVet) {
        return <div>Página para Veterinarios en desarrollo.</div>
    }
    return (
        <div style={{ width: "100%" }}>
            {<Title icon={<FaCalendar />} title="Próximos eventos programados" />}
            <section style={{ width: "100%", marginBottom: "2rem" }}>
                {/* <input type="date" value="2025-01-01" /> */}
            </section>

            <section>
                <h3>Datos de contacto</h3>
                <div
                    style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fit, minmax(120px, auto))",
                        gap: "0.5rem",
                        alignItems: "center",
                        marginBottom: "1rem",
                        fontSize: "0.8rem"
                    }}
                >
                    <select>
                        <option>Last 12 months</option>
                        <option>Last 6 months</option>
                    </select>
                    <input type="date" defaultValue="2020-08-01" />
                    <span style={{ textAlign: "center" }}>a</span>
                    <input type="date" defaultValue="2020-07-07" />
                    <select>
                        <option>Previous period</option>
                    </select>
                    <select>
                        <option>Monthly</option>
                    </select>
                    <button>Edit charts</button>
                </div>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/conditions/page.tsx
"use client";
import React from "react";
import { FaCloudSun } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function ConditionsPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Condiciones especiales"
            icon={<FaCloudSun />}
            apiUrl={'/api/pets/list/conditions/'}
            storedList={storage.storedConditionData}
            setStoredList={storage.setStoredConditionData}
            emptyMessage="No hay registro de condiciones especiales."
            mapItemToFields={FieldData.ForConditions}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// src/app/pages/pet/consultations/[petId]/page.tsx
"use client";
import React, { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { PetType, ConsultationType } from '@/types/index';
import { getFetch } from '@/app/api';
import { Loading, DataNotFound, Title } from '@/components/index';
import { ConsultationDetailView } from '@/components/index';
import { FaNotesMedical, FaListAlt, FaArrowLeft } from 'react-icons/fa';
import { useStorageContext } from '@/context/StorageProvider';
import { useSessionContext } from '@/context/SessionProvider'; // Para verificar el veterinario logueado
import { Dates } from '@/utils/index';

export default function PetConsultationsPage() {
    const params = useParams();
    const router = useRouter();
    const petId = params.petId as string;

    const { storedPet, setStoredPet } = useStorageContext();
    const { db: session } = useSessionContext(); // Usuario autenticado

    const [pet, setPet] = useState<PetType | null>(storedPet.id === petId ? storedPet : null);
    const [consultations, setConsultations] = useState<ConsultationType[]>([]);
    const [selectedConsultation, setSelectedConsultation] = useState<ConsultationType | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (!petId) {
            setError("ID de mascota no proporcionado.");
            setLoading(false);
            return;
        }

        const fetchData = async () => {
            setLoading(true);
            try {
                // Cargar datos de la mascota si no están en el contexto o son diferentes
                if (!pet || pet.id !== petId) {
                    const petResponse = await getFetch(`/api/pets/${petId}`);
                    const petData = await petResponse.json();
                    if (!petResponse.ok || !petData) {
                        throw new Error(petData?.message || 'Mascota no encontrada');
                    }
                    setPet(petData);
                    setStoredPet(petData); // Actualizar contexto
                }

                // Cargar consultas
                const consultsResponse = await getFetch(`/api/consultations?petId=${petId}`);
                const consultsData = await consultsResponse.json();
                if (!consultsResponse.ok || !consultsData.success) {
                    throw new Error(consultsData?.message || 'Error cargando consultas');
                }
                setConsultations(consultsData.consultations || []);
            } catch (err) {
                setError(err instanceof Error ? err.message : "Error desconocido al cargar datos.");
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [petId, storedPet, setStoredPet]); // pet no es dependencia para evitar bucle si se actualiza dentro

    const handleSelectConsultation = (consultation: ConsultationType) => {
        setSelectedConsultation(consultation);
    };

    const handleBackToList = () => {
        setSelectedConsultation(null);
    };

    // Función para recargar los datos de la consulta seleccionada (útil después de añadir un archivo)
    const refreshSelectedConsultation = async () => {
        if (!selectedConsultation?.id) return;
        try {
            const response = await getFetch(`/api/consultations/${selectedConsultation.id}`);
            const result = await response.json();
            if (response.ok && result.success) {
                setSelectedConsultation(result.consultation);
                // Actualizar la lista general también
                setConsultations(prev => prev.map(c => c.id === result.consultation.id ? result.consultation : c));
            } else {
                console.error("Error recargando consulta:", result.message);
            }
        } catch (err) {
            console.error("Error recargando consulta:", err);
        }
    };


    if (loading) return <Loading />;
    if (error) return <DataNotFound message={error} />;
    if (!pet) return <DataNotFound message="Mascota no encontrada." />;

    return (
        <main style={{ padding: "2rem" }}>
            <Title
                icon={<FaNotesMedical />}
                title={selectedConsultation
                    ? `Detalle Consulta (${Dates.format(selectedConsultation.consultation_date)}) para ${pet.name}`
                    : `Historial de Consultas para ${pet.name}`}
            />

            {selectedConsultation ? (
                <div>
                    <button onClick={handleBackToList} className="outline secondary" style={{ marginBottom: '1rem' }}>
                        <FaArrowLeft style={{ marginRight: '0.5rem' }} /> Volver al Listado
                    </button>
                    <ConsultationDetailView
                        consultation={selectedConsultation}
                        currentUserId={session?.user?.id || null} // Para lógica de edición/añadir archivos
                        onFileAdded={refreshSelectedConsultation} // Callback para refrescar después de añadir archivo
                    />
                </div>
            ) : (
                <>
                    {consultations.length === 0 ? (
                        <DataNotFound message="No hay consultas registradas para esta mascota." />
                    ) : (
                        <div role="list" style={{ marginTop: '1rem' }}>
                            {consultations.map((consult) => (
                                <article
                                    key={consult.id}
                                    onClick={() => handleSelectConsultation(consult)}
                                    role="listitem"
                                    style={{
                                        marginBottom: '1rem',
                                        cursor: 'pointer',
                                        borderLeft: '5px solid var(--primary)'
                                    }}
                                    className="pico-paper" // Usar alguna clase de Pico para el estilo de "papel"
                                >
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <strong>Motivo: {consult.reason_for_consultation.substring(0, 50)}{consult.reason_for_consultation.length > 50 ? '...' : ''}</strong>
                                        <span>{Dates.format(consult.consultation_date)} {consult.consultation_time}</span>
                                    </div>
                                    <small>HC#: {consult.hc_number || 'N/A'} - Institución: {consult.institution_name || 'N/A'}</small>
                                </article>
                            ))}
                        </div>
                    )}
                    <button
                        onClick={() => router.push(`/pages/vet/consultation/${petId}`)}
                        style={{ marginTop: '1.5rem' }}
                    >
                        <FaListAlt style={{ marginRight: '0.5rem' }} /> Agregar Nueva Consulta
                    </button>
                </>
            )}
        </main>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/lab-tests/page.tsx
"use client";
import React from "react";
import { FaFlask } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function LabTestsPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Exámenes de laboratorio"
            icon={<FaFlask />}
            apiUrl={'/api/pets/list/lab-tests/'}
            storedList={storage.storedLabTestData}
            setStoredList={storage.setStoredLabTestData}
            emptyMessage="No hay registro de resultados de laboratorio."
            mapItemToFields={FieldData.ForLabTests}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaPills } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function MedicinesPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Medicinas"
            icon={<FaPills />}
            apiUrl={'/api/pets/list/medicines/'}
            storedList={storage.storedMedicineData}
            setStoredList={storage.setStoredMedicineData}
            emptyMessage="No hay registro de medicamentos."
            mapItemToFields={FieldData.ForMedicines}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/register/page.tsx
export default function PetRegisterPage(){
    return <div></div>
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaCut } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function SurgeriesPage() {
    const storage = useStorageContext();
    return (
        <PageComponent
            parentId={storage.storedPet.id}
            title="Cirugías"
            icon={<FaCut />}
            apiUrl={'/api/pets/list/surgeries/'}
            storedList={storage.storedSurgeryData}
            setStoredList={storage.setStoredSurgeryData}
            emptyMessage="No hay registro de cirugías."
            mapItemToFields={FieldData.ForSurgeries}
        />
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/vaccines/page.tsx
"use client";
import React from "react";
import { FaSyringe } from "react-icons/fa";
import { PageComponent } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function VaccinesPage() {
  const storage = useStorageContext();
  return (
    <PageComponent
      parentId={storage.storedPet.id}
      title="Vacunas"
      icon={<FaSyringe />}
      apiUrl={'/api/pets/list/vaccines/'}
      storedList={storage.storedVaccineData}
      setStoredList={storage.setStoredVaccineData}
      emptyMessage="No hay registro de vacunas."
      mapItemToFields={FieldData.ForVaccines}
    />
  );
}
 
----- Archivo: index.ts ----- 
// src/components/forms/consultation/index.ts
export * from './ConsultationForm';
export * from './FileUploadItem';
// También puedes exportar todas las secciones desde aquí si prefieres
// export * from './sections';  
----- Archivo: ConsultationForm.tsx ----- 
// src/components/forms/consultation/ConsultationForm.tsx
import React, { useState } from 'react';
import type { PetType, CreateConsultationPayload, ConsultationProcedureType, ConsultationMedicationType, ConsultationFileType } from '@/types/index';
// import { Empty } from '@/data/index'; // Ya no se usa directamente aquí para inicializar

import { IdentitySection } from './sections/IdentitySection';
import { OwnerPetSection } from './sections/OwnerPetSection';
import { AnamnesisSection } from './sections/AnamnesisSection';
import { PhysicalExamSection } from './sections/PhysicalExamSection';
import { DiagnosticApproachSection } from './sections/DiagnosticApproachSection';
import { ComplementaryExamsSection } from './sections/ComplementaryExamsSection';
import { DiagnosisPlanSection } from './sections/DiagnosisPlanSection';
import { ProceduresSection } from './sections/ProceduresSection';
import { MedicationsSection } from './sections/MedicationsSection';
import { ObservationsSignatureSection } from './sections/ObservationsSignatureSection';
import { useStorageContext } from '@/context/StorageProvider';
import { useVetContext } from '@/context/VetContext';

interface ConsultationFormProps {
    pet: PetType;
    onSubmit: (formData: CreateConsultationPayload) => Promise<void>;
    isSubmitting: boolean;
}

export function ConsultationForm({ pet, onSubmit, isSubmitting }: ConsultationFormProps) {
    const { storedOwnerData } = useStorageContext();
    const { vet: veterinarianProfessionalData } = useVetContext();

    const [formData, setFormData] = useState<Partial<CreateConsultationPayload>>(() => {
        const today = new Date();
        const initialFormData: Partial<CreateConsultationPayload> = {
            consultation_date: today.toISOString().split('T')[0],
            consultation_time: today.toTimeString().split(' ')[0].substring(0, 5),
            procedures: [],
            medications: [],
            // Inicializar otros campos como null o string vacío según corresponda
            // para evitar que sean 'undefined' si el componente de sección espera un valor controlado.
            institution_name: '',
            hc_number: '',
            reason_for_consultation: '', // Campo requerido
            current_diet: '',
            // ... (inicializa todos los demás campos que usan los componentes de sección)
            presumptive_diagnosis: '', // Campo requerido
            therapeutic_plan: '',    // Campo requerido
            // ...etc.
        };
        // Inicializar todos los campos esperados por las secciones para evitar errores de "uncontrolled to controlled"
        const allExpectedFields: Array<keyof CreateConsultationPayload> = [
            'institution_name', 'hc_number', 'consultation_date', 'consultation_time',
            'reason_for_consultation', 'current_diet', 'previous_illnesses', 'previous_surgeries',
            'vaccination_history', 'last_deworming_product', 'recent_treatments', 'recent_travels',
            'animal_behavior_owner_description', 'lives_with_other_animals_details', 'sterilized_status',
            'birth_count', 'body_condition_score', 'temperature_celsius', 'heart_rate_bpm',
            'respiratory_rate_rpm', 'capillary_refill_time_sec', 'pulse_description',
            'mucous_membranes_description', 'hydration_percentage_description', 'sense_organs_description',
            'skin_and_coat_description', 'lymph_nodes_description', 'digestive_system_findings',
            'respiratory_system_findings', 'endocrine_system_findings', 'musculoskeletal_system_findings',
            'nervous_system_findings', 'urinary_system_findings', 'reproductive_system_findings',
            'rectal_palpation_findings', 'other_physical_findings', 'problem_list',
            'master_problem_list', 'differential_diagnoses', 'complementary_exams_summary',
            'presumptive_diagnosis', 'definitive_diagnosis', 'therapeutic_plan', 'prognosis',
            'evolution_notes', 'general_observations', 'signature_confirmation'
        ];

        allExpectedFields.forEach(field => {
            if (!(field in initialFormData)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (initialFormData as any)[field] = null; // o '' según el tipo esperado por el input
            }
        });
        return initialFormData;
    });

    const [uploadedFiles, setUploadedFiles] = useState<ConsultationFileType[]>([]);

    const handleChange = (
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
    ) => {
        const { name, value, type } = e.target;
        let processedValue: string | number | boolean | null = value;

        if (type === 'checkbox') {
            processedValue = (e.target as HTMLInputElement).checked;
        } else if (type === 'number') {
            if (value === '') {
                processedValue = null; // Enviar null si el campo numérico está vacío
            } else {
                const num = parseFloat(value);
                processedValue = isNaN(num) ? null : num; // null si no es un número válido
            }
        }
        // Para inputs de fecha y tiempo, el valor ya es un string en el formato correcto

        setFormData(prev => ({ ...prev, [name]: processedValue }));
    };

    const handleNumericChange = (name: keyof CreateConsultationPayload, value: string) => {
        const numValue = value === '' ? null : parseFloat(value);
        setFormData(prev => ({
            ...prev,
            [name]: numValue === null || isNaN(numValue as number) ? null : numValue,
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const finalPayload = { ...formData };
        // Asegurarse de que los campos requeridos tengan valor
        if (!finalPayload.reason_for_consultation || !finalPayload.presumptive_diagnosis || !finalPayload.therapeutic_plan) {
            alert("Por favor, complete todos los campos obligatorios: Motivo de Consulta, Diagnóstico Presuntivo y Plan Terapéutico.");
            return;
        }
        onSubmit(finalPayload as CreateConsultationPayload);
    };

    const handleProceduresChange = (updatedProcedures: Array<Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>>) => {
        setFormData(prev => ({ ...prev, procedures: updatedProcedures }));
    };

    const handleMedicationsChange = (updatedMedications: Array<Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>>) => {
        setFormData(prev => ({ ...prev, medications: updatedMedications }));
    };

    const handleFilesUpdate = (newFiles: ConsultationFileType[]) => {
        // Esta función podría no ser necesaria si los archivos se manejan enteramente
        // dentro de ComplementaryExamsSection hasta el momento del submit general,
        // o si la subida ocurre después de crear la consulta.
        // Por ahora, actualizamos un estado local si es necesario.
        setUploadedFiles(prevFiles => {
            const updated = [...prevFiles];
            newFiles.forEach(nf => {
                if (!updated.find(ef => ef.id === nf.id)) {
                    updated.push(nf);
                }
            });
            return updated;
        });
    };

    const handleToggleSection = (event: React.MouseEvent<HTMLElement>, sectionName: string) => {
        event.preventDefault(); // Prevenir el toggle nativo del <details>
        setOpenSection(prevOpenSection =>
            prevOpenSection === sectionName ? null : sectionName
        );
    };

    // Para controlar qué sección está abierta por defecto (opcional)
    const [openSection, setOpenSection] = useState<string | null>('identity'); // Abre la primera por defecto

    return (
        <form onSubmit={handleSubmit} className="space-y-4 pico-form" style={{ marginTop: '2rem' }}>

            <details open={openSection === 'identity'}>
                <summary
                    role="button"
                    className="secondary outline"
                    onClick={(e) => handleToggleSection(e, 'identity')}
                >
                    1. Identificación
                </summary>
                {openSection === 'identity' && ( // Renderizar contenido solo si está abierto
                    <IdentitySection formData={formData} handleChange={handleChange} />
                )}
            </details>

            <details open={openSection === 'ownerPet'}>
                <summary
                    role="button"
                    className="secondary outline"
                    onClick={(e) => handleToggleSection(e, 'ownerPet')}
                >
                    2. Datos Propietario y Reseña Mascota
                </summary>
                {openSection === 'ownerPet' && (
                    <OwnerPetSection owner={storedOwnerData} pet={pet} />
                )}
            </details>

            {/* Repetir el patrón para todas las demás secciones */}
            {/* Ejemplo para Anamnesis: */}
            <details open={openSection === 'anamnesis'}>
                <summary
                    role="button"
                    className="secondary outline"
                    onClick={(e) => handleToggleSection(e, 'anamnesis')}
                >
                    3. Anamnesis
                </summary>
                {openSection === 'anamnesis' && (
                    <AnamnesisSection formData={formData} handleChange={handleChange} handleNumericChange={handleNumericChange} />
                )}
            </details>


            <details open={openSection === 'physicalExam'}>
                <summary
                    role="button"
                    className="secondary outline"
                    onClick={(e) => handleToggleSection(e, 'physicalExam')}
                >
                    4. Exámenes físicos
                </summary>
                <PhysicalExamSection formData={formData} handleChange={handleChange} handleNumericChange={handleNumericChange} />
            </details>

            <details open={openSection === 'procedures'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'procedures')}>
                    5. Procedimientos en Consulta
                </summary>
                {openSection === 'procedures' && (
                    <ProceduresSection procedures={formData.procedures || []} onChange={handleProceduresChange} />
                )}
            </details>

            <details open={openSection === 'medications'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'medications')}>
                    6. Medicamentos en Consulta
                </summary>
                {openSection === 'medications' && (
                    <MedicationsSection medications={formData.medications || []} onChange={handleMedicationsChange} />
                )}
            </details>

            <details open={openSection === 'diagnosticApproach'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'diagnosticApproach')}>
                    7. Abordaje Diagnóstico
                </summary>
                {openSection === 'diagnosticApproach' && (
                    <DiagnosticApproachSection formData={formData} handleChange={handleChange} />
                )}
            </details>

            <details open={openSection === 'complementaryExams'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'complementaryExams')}>
                    8. Exámenes Complementarios
                </summary>
                {openSection === 'complementaryExams' && (
                    <ComplementaryExamsSection
                        petId={pet.id}
                        consultationId={""}
                        formData={formData}
                        handleChange={handleChange}
                        onFilesUpdate={handleFilesUpdate} />
                )}
                {uploadedFiles.length > 0 && (
                    <p>Archivos adjuntos: {uploadedFiles.length}</p>
                )}
            </details>

            <details open={openSection === 'diagnosisPlan'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'diagnosisPlan')}>
                    9. Diagnóstico y Plan
                </summary>
                {openSection === 'diagnosisPlan' && (
                    <DiagnosisPlanSection formData={formData} handleChange={handleChange} />
                )}
            </details>

            <details open={openSection === 'observations'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'observations')}>
                    10. Observaciones y Profesional
                </summary>
                {openSection === 'observations' && (
                    <ObservationsSignatureSection
                        formData={formData}
                        handleChange={handleChange}
                        professionalName={veterinarianProfessionalData ? `${veterinarianProfessionalData.first_name} ${veterinarianProfessionalData.last_name}` : "N/A"}
                        professionalRegistration={veterinarianProfessionalData?.registration || "N/A"}
                    />
                )}
            </details>


            <button type="submit" disabled={isSubmitting} aria-busy={isSubmitting} style={{ marginTop: '1.5rem' }}>
                {isSubmitting ? 'Guardando Consulta...' : 'Guardar Consulta'}
            </button>
        </form>
    );
} 
----- Archivo: FileUploadItem.tsx ----- 
// src/components/forms/consultation/FileUploadItem.tsx
import React from 'react';
import { ConsultationFileType } from '@/types/index';
import { FaFilePdf, FaFileImage, FaFileAlt, FaTrash } from 'react-icons/fa';

interface FileUploadItemProps {
    file: ConsultationFileType;
    onDelete: (fileId: string) => void;
    // onDownload?: (filePath: string) => void; // Opcional, si manejas la descarga
}

export function FileUploadItem({ file, onDelete /*, onDownload */ }: FileUploadItemProps) {
    const getFileIcon = () => {
        if (file.file_type?.startsWith('image/')) return <FaFileImage className="text-blue-500" />;
        if (file.file_type === 'application/pdf') return <FaFilePdf className="text-red-500" />;
        return <FaFileAlt className="text-gray-500" />;
    };

    // La URL de descarga vendría de una API que genere una URL firmada
    // const handleDownload = () => {
    //     if(onDownload) onDownload(file.file_path);
    // };

    return (
        <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '0.5rem',
            border: '1px solid #eee',
            borderRadius: '4px',
            marginBottom: '0.5rem',
            fontSize: '0.9rem'
        }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                {getFileIcon()}
                <span>{file.file_name}</span>
                <span style={{ fontSize: '0.75rem', color: '#777' }}> ({(file.file_size_bytes! / 1024).toFixed(1)} KB)</span>
            </div>
            <div>
                {/* 
                // Botón de descarga (requiere API para URL firmada)
                <button 
                    type="button" 
                    onClick={handleDownload} 
                    className="outline secondary" 
                    aria-label="Descargar archivo"
                    style={{marginRight: '0.5rem', padding: '0.25rem 0.5rem'}}
                >
                    <FaDownload />
                </button> 
                */}
                <button
                    type="button"
                    onClick={() => onDelete(file.id)}
                    className="outline secondary"
                    aria-label="Eliminar archivo"
                    style={{ color: 'var(--pico-color-red-500)', borderColor: 'var(--pico-color-red-500)', padding: '0.25rem 0.5rem' }}
                >
                    <FaTrash />
                </button>
            </div>
        </div>
    );
} 
----- Archivo: index.ts ----- 
// src/components/forms/consultation/sections/index.ts
export * from './IdentitySection';
export * from './OwnerPetSection';
export * from './AnamnesisSection';
export * from './PhysicalExamSection';
export * from './DiagnosticApproachSection';
export * from './ComplementaryExamsSection';
export * from './DiagnosisPlanSection';
export * from './ProceduresSection';
export * from './MedicationsSection';
export * from './ObservationsSignatureSection'; 
----- Archivo: AnamnesisSection.tsx ----- 
// src/components/forms/consultation/sections/AnamnesisSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface AnamnesisSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    handleNumericChange: (name: keyof CreateConsultationPayload, value: string) => void; // Para campos numéricos opcionales
}

export function AnamnesisSection({ formData, handleChange, handleNumericChange }: AnamnesisSectionProps) {
    return (
        <fieldset>
            <legend>4. Anamnesis</legend>
            <label htmlFor="current_diet">
                Dieta Actual
                <textarea
                    id="current_diet"
                    name="current_diet"
                    value={formData.current_diet || ''}
                    onChange={handleChange}
                    rows={2}
                />
            </label>
            <div className="grid">
                <label htmlFor="previous_illnesses">
                    Enfermedades Previas
                    <textarea
                        id="previous_illnesses"
                        name="previous_illnesses"
                        value={formData.previous_illnesses || ''}
                        onChange={handleChange}
                        rows={2}
                    />
                </label>
                <label htmlFor="previous_surgeries">
                    Cirugías Previas
                    <textarea
                        id="previous_surgeries"
                        name="previous_surgeries"
                        value={formData.previous_surgeries || ''}
                        onChange={handleChange}
                        rows={2}
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="vaccination_history">
                    Esquema Vacunal (Resumen)
                    <textarea
                        id="vaccination_history"
                        name="vaccination_history"
                        value={formData.vaccination_history || ''}
                        onChange={handleChange}
                        placeholder="Ej: Completo según edad, última revacunación Diciembre 2023"
                        rows={2}
                    />
                </label>
                <label htmlFor="last_deworming_product">
                    Última Desparasitación y Producto
                    <input
                        type="text"
                        id="last_deworming_product"
                        name="last_deworming_product"
                        value={formData.last_deworming_product || ''}
                        onChange={handleChange}
                        placeholder="Ej: Drontal Plus, hace 2 meses"
                    />
                </label>
            </div>
            <label htmlFor="recent_treatments">
                Tratamientos Recientes
                <textarea
                    id="recent_treatments"
                    name="recent_treatments"
                    value={formData.recent_treatments || ''}
                    onChange={handleChange}
                    rows={2}
                />
            </label>
            <div className="grid">
                <label htmlFor="recent_travels">
                    Viajes Recientes
                    <input
                        type="text"
                        id="recent_travels"
                        name="recent_travels"
                        value={formData.recent_travels || ''}
                        onChange={handleChange}
                        placeholder="Ej: Finca en Clima Cálido hace 1 semana"
                    />
                </label>
                <label htmlFor="lives_with_other_animals_details"> {/* Nuevo campo para detalles */}
                    ¿Vive con otros animales? ¿Cuáles?
                    <input
                        type="text"
                        id="lives_with_other_animals_details"
                        name="lives_with_other_animals_details" // Añadir a types y schema
                        value={formData.lives_with_other_animals_details || ''}
                        onChange={handleChange}
                        placeholder="Ej: Sí, un gato y un perro."
                    />
                </label>
            </div>
            <div className="grid">
                <label>
                    Esterilizado
                    <select name="sterilized_status" value={formData.sterilized_status || ""} onChange={handleChange}> {/* Nuevo Campo */}
                        <option value="" disabled>Seleccionar...</option>
                        <option value="yes">Sí</option>
                        <option value="no">No</option>
                        <option value="unknown">No se sabe</option>
                    </select>
                </label>
                <label htmlFor="birth_count">
                    N° de Partos (si aplica)
                    <input
                        type="number"
                        id="birth_count"
                        name="birth_count" // Nuevo Campo
                        value={formData.birth_count === undefined || formData.birth_count === null ? '' : formData.birth_count}
                        onChange={(e) => handleNumericChange('birth_count', e.target.value)}
                        min="0"
                    />
                </label>
            </div>
            <label htmlFor="animal_behavior_owner_description">
                Comportamiento del Animal (según propietario)
                <textarea
                    id="animal_behavior_owner_description"
                    name="animal_behavior_owner_description"
                    value={formData.animal_behavior_owner_description || ''}
                    onChange={handleChange}
                    rows={3}
                />
            </label>
            <label htmlFor="reason_for_consultation">
                Motivo de Consulta (según propietario)
                <textarea
                    id="reason_for_consultation"
                    name="reason_for_consultation"
                    value={formData.reason_for_consultation || ''}
                    onChange={handleChange}
                    rows={3}
                    required
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: ComplementaryExamsSection.tsx ----- 
// src/components/forms/consultation/sections/ComplementaryExamsSection.tsx
import React, { useState, useRef } from 'react';
import type { CreateConsultationPayload, ConsultationFileType } from '@/types/index';
import { FaUpload, FaPaperclip, FaSpinner } from 'react-icons/fa';
import { FileUploadItem } from '../FileUploadItem';

interface ComplementaryExamsSectionProps {
    petId: string; // Necesario para la ruta de subida de archivos
    consultationId: string; // Será vacío inicialmente, se usa si se edita o se sube post-creación
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    onFilesUpdate: (newFiles: ConsultationFileType[]) => void; // Para notificar al form padre
}

export function ComplementaryExamsSection({
    petId,
    consultationId, // Puede ser un ID temporal o se actualiza post-guardado
    formData,
    handleChange,
    onFilesUpdate,
}: ComplementaryExamsSectionProps) {
    const [localFiles, setLocalFiles] = useState<File[]>([]);
    const [uploading, setUploading] = useState<boolean[]>([]); // Para rastrear estado de subida por archivo
    const [uploadedServerFiles, setUploadedServerFiles] = useState<ConsultationFileType[]>([]);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.files) {
            const newFiles = Array.from(event.target.files);
            setLocalFiles(prev => [...prev, ...newFiles]);
            setUploading(prev => [...prev, ...newFiles.map(() => false)]); // Inicializar estado de subida
        }
    };

    const triggerFileInput = () => {
        fileInputRef.current?.click();
    };

    // Simulación de subida. En una app real, llamarías a tu API.
    const handleUploadFile = async (file: File, index: number) => {
        if (!consultationId && !confirm("El ID de consulta aún no está disponible. ¿Desea subir el archivo ahora? Se asociará una vez guarde la consulta.")) {
            // O podrías bloquear la subida hasta tener consultationId
            // return;
        }
        setUploading(prev => prev.map((u, i) => i === index ? true : u));
        setUploadError(null);

        const formDataApi = new FormData();
        formDataApi.append('file', file);
        formDataApi.append('petId', petId);
        // Si tuvieras un consultationId ya, lo enviarías aquí:
        // formDataApi.append('consultationId', consultationId);


        try {
            // Si no hay consultationId real aún, podrías subir a una "staging area"
            // o simplemente no crear el registro en `consultation_files` hasta después.
            // Por ahora, simularemos que la API puede manejarlo o que se requiere `consultationId`.
            // La API `/api/consultations/[consultationId]/files` espera un `consultationId` en la URL.
            // Esto implica que el `consultationId` debe existir.

            // Para este ejemplo, asumiremos que el `consultationId` es necesario.
            // En un flujo real, podrías:
            // 1. Guardar la consulta -> obtener ID -> luego permitir subir archivos.
            // 2. Subir archivos a un ID temporal/staging -> guardar consulta -> asociar archivos.

            // Si `consultationId` es una cadena vacía, la API fallará.
            // Esto es un punto a mejorar en el flujo general de la aplicación.
            if (!consultationId) {
                throw new Error("Se requiere un ID de consulta para subir archivos. Guarde la consulta primero.");
            }


            const response = await fetch(`/api/consultations/${consultationId}/files`, {
                method: 'POST',
                body: formDataApi,
                // No set Content-Type, el browser lo hace por FormData
            });

            const result = await response.json();

            if (!response.ok || !result.success) {
                throw new Error(result.message || `Error subiendo ${file.name}`);
            }

            setUploadedServerFiles(prev => [...prev, result.file as ConsultationFileType]);
            onFilesUpdate([result.file as ConsultationFileType]); // Notificar al padre
            setLocalFiles(prev => prev.filter((_, i) => i !== index)); // Remover de la lista local si tuvo éxito

        } catch (err) {
            console.error("Upload error:", err);
            setUploadError(err instanceof Error ? err.message : "Error desconocido.");
        } finally {
            setUploading(prev => prev.map((u, i) => i === index ? false : u));
        }
    };

    const removeUploadedFile = async (fileToRemove: ConsultationFileType) => {
        if (!fileToRemove.id) return;
        // Lógica para llamar a la API DELETE /api/consultations/files/[fileId]
        try {
            const response = await fetch(`/api/consultations/files/${fileToRemove.id}`, { method: 'DELETE' });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.message || "Error eliminando archivo del servidor.");
            }
            setUploadedServerFiles(prev => prev.filter(f => f.id !== fileToRemove.id));
            onFilesUpdate(uploadedServerFiles.filter(f => f.id !== fileToRemove.id)); // Notificar al padre
        } catch (err) {
            console.error("Error deleting file:", err);
            alert(err instanceof Error ? err.message : "No se pudo eliminar el archivo.");
        }
    };


    return (
        <fieldset>
            <legend>7. Exámenes Complementarios y Resultados</legend>
            <label htmlFor="complementary_exams_summary">
                Resumen de Exámenes Realizados / Hallazgos Principales (texto)
                <textarea
                    id="complementary_exams_summary"
                    name="complementary_exams_summary"
                    value={formData.complementary_exams_summary || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Ej: Hemograma: Leucocitosis leve. Radiografía abdominal: Sin hallazgos significativos."
                />
            </label>

            <div>
                <h6 style={{ marginTop: '1rem' }}>Archivos Adjuntos:</h6>
                <input
                    type="file"
                    multiple
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    style={{ display: 'none' }}
                    accept="image/*,application/pdf"
                />
                <button type="button" onClick={triggerFileInput} className="outline">
                    <FaPaperclip style={{ marginRight: '0.5rem' }} /> Seleccionar Archivos
                </button>

                {uploadError && <p className="text-error" style={{ marginTop: '0.5rem' }}>{uploadError}</p>}

                {/* Lista de archivos locales pendientes de subir */}
                {localFiles.length > 0 && (
                    <div style={{ marginTop: '1rem', border: '1px dashed #ccc', padding: '1rem' }}>
                        <p>Archivos listos para subir:</p>
                        <ul>
                            {localFiles.map((file, index) => (
                                <li key={index} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                    <span>{file.name} ({(file.size / 1024).toFixed(1)} KB)</span>
                                    <button
                                        type="button"
                                        onClick={() => handleUploadFile(file, index)}
                                        disabled={uploading[index]}
                                        className="secondary outline"
                                        style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                    >
                                        {uploading[index] ? <FaSpinner className="animate-spin" /> : <FaUpload />} Subir
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>
                )}

                {/* Lista de archivos ya subidos al servidor */}
                {uploadedServerFiles.length > 0 && (
                    <div style={{ marginTop: '1rem' }}>
                        <p>Archivos adjuntados:</p>
                        {uploadedServerFiles.map(file => (
                            <FileUploadItem key={file.id} file={file} onDelete={() => removeUploadedFile(file)} />
                        ))}
                    </div>
                )}
            </div>
        </fieldset>
    );
} 
----- Archivo: DiagnosisPlanSection.tsx ----- 
// src/components/forms/consultation/sections/DiagnosisPlanSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface DiagnosisPlanSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function DiagnosisPlanSection({ formData, handleChange }: DiagnosisPlanSectionProps) {
    return (
        <fieldset>
            <legend>8. Diagnóstico y Plan</legend>
            <label htmlFor="presumptive_diagnosis">
                Diagnóstico Presuntivo Justificado
                <textarea
                    id="presumptive_diagnosis"
                    name="presumptive_diagnosis"
                    value={formData.presumptive_diagnosis || ''}
                    onChange={handleChange}
                    rows={3}
                    required
                    placeholder="Describa el diagnóstico presuntivo y la justificación basada en los hallazgos."
                />
            </label>
            <label htmlFor="definitive_diagnosis">
                Diagnóstico Definitivo (si se tiene)
                <textarea
                    id="definitive_diagnosis"
                    name="definitive_diagnosis"
                    value={formData.definitive_diagnosis || ''}
                    onChange={handleChange}
                    rows={3}
                />
            </label>
            <label htmlFor="therapeutic_plan">
                Plan Terapéutico
                <textarea
                    id="therapeutic_plan"
                    name="therapeutic_plan"
                    value={formData.therapeutic_plan || ''}
                    onChange={handleChange}
                    rows={4}
                    required
                    placeholder="Detallar el tratamiento, recomendaciones, próxima revisión, etc."
                />
            </label>
            <label htmlFor="prognosis">
                Pronóstico
                <textarea
                    id="prognosis"
                    name="prognosis"
                    value={formData.prognosis || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Ej: Favorable, reservado, grave."
                />
            </label>
            <label htmlFor="evolution_notes">
                Evolución (Notas iniciales si aplica durante la consulta)
                <textarea
                    id="evolution_notes"
                    name="evolution_notes"
                    value={formData.evolution_notes || ''}
                    onChange={handleChange}
                    rows={3}
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: DiagnosticApproachSection.tsx ----- 
// src/components/forms/consultation/sections/DiagnosticApproachSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface DiagnosticApproachSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function DiagnosticApproachSection({ formData, handleChange }: DiagnosticApproachSectionProps) {
    return (
        <fieldset>
            <legend>6. Abordaje Diagnóstico</legend>
            <label htmlFor="problem_list">
                Lista de Problemas
                <textarea
                    id="problem_list"
                    name="problem_list"
                    value={formData.problem_list || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Ej: 1. Vómito agudo, 2. Letargia, 3. Deshidratación leve"
                />
            </label>
            <label htmlFor="master_problem_list">
                Lista Maestra (Problema Principal)
                <textarea
                    id="master_problem_list"
                    name="master_problem_list"
                    value={formData.master_problem_list || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Ej: Síndrome gastrointestinal agudo"
                />
            </label>
            <label htmlFor="differential_diagnoses">
                Diagnósticos Diferenciales
                <textarea
                    id="differential_diagnoses"
                    name="differential_diagnoses"
                    value={formData.differential_diagnoses || ''}
                    onChange={handleChange}
                    rows={4}
                    placeholder="Ej: 1. Gastroenteritis viral, 2. Cuerpo extraño, 3. Indiscreción alimentaria, 4. Pancreatitis"
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: IdentitySection.tsx ----- 
// src/components/forms/consultation/sections/IdentitySection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface IdentitySectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function IdentitySection({ formData, handleChange }: IdentitySectionProps) {
    return (
        <fieldset>
            <legend>1. Identificación de la Institución e Historia Clínica</legend>
            <div className="grid">
                <label htmlFor="institution_name">
                    Nombre de la Institución
                    <input
                        type="text"
                        id="institution_name"
                        name="institution_name" // Campo nuevo, añadir a CreateConsultationPayload y tabla
                        value={formData.institution_name || ''}
                        onChange={handleChange}
                        placeholder="Ej: Clínica Veterinaria XYZ"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="hc_number">
                    HC # (Número Consecutivo)
                    <input
                        type="text"
                        id="hc_number"
                        name="hc_number" // Campo nuevo
                        value={formData.hc_number || ''}
                        onChange={handleChange}
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="consultation_date">
                    Fecha
                    <input
                        type="date"
                        id="consultation_date"
                        name="consultation_date"
                        value={formData.consultation_date || ''}
                        onChange={handleChange}
                        required
                    />
                </label>
                <label htmlFor="consultation_time">
                    Hora
                    <input
                        type="time"
                        id="consultation_time"
                        name="consultation_time" // Campo nuevo
                        value={formData.consultation_time || ''}
                        onChange={handleChange}
                        required
                    />
                </label>
            </div>
        </fieldset>
    );
} 
----- Archivo: MedicationsSection.tsx ----- 
// src/components/forms/consultation/sections/MedicationsSection.tsx
import React from 'react';
import type { ConsultationMedicationType } from '@/types/index';
import { FaPlus, FaTrash } from 'react-icons/fa';

type MedicationFormItem = Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>;

interface MedicationsSectionProps {
    medications: MedicationFormItem[];
    onChange: (updatedMedications: MedicationFormItem[]) => void;
}

export function MedicationsSection({ medications, onChange }: MedicationsSectionProps) {
    const addMedication = () => {
        onChange([...medications, { medication_name: '', dosage: '', frequency: '', duration_days: null, notes: '' }]);
    };

    const removeMedication = (index: number) => {
        onChange(medications.filter((_, i) => i !== index));
    };

    const handleMedicationChange = (
        index: number,
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        const { name, value } = e.target;
        let processedValue: string | number | null = value;
        if (name === "duration_days") {
            processedValue = value === '' ? null : parseInt(value, 10);
            if (isNaN(processedValue as number)) processedValue = null;
        }

        onChange(
            medications.map((med, i) =>
                i === index ? { ...med, [name]: processedValue } : med
            )
        );
    };

    return (
        <fieldset>
            <legend>Medicamentos Administrados/Prescritos en Consulta</legend>
            {medications.map((med, index) => (
                <div key={index} style={{ border: '1px solid #e0e0e0', padding: '1rem', borderRadius: '4px', marginBottom: '1rem' }}>
                    <div className="grid">
                        <label htmlFor={`medication_name_${index}`}>
                            Nombre del Medicamento
                            <input
                                type="text"
                                id={`medication_name_${index}`}
                                name="medication_name"
                                value={med.medication_name}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                        <label htmlFor={`dosage_${index}`}>
                            Dosis
                            <input
                                type="text"
                                id={`dosage_${index}`}
                                name="dosage"
                                value={med.dosage}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                    </div>
                    <div className="grid">
                        <label htmlFor={`frequency_${index}`}>
                            Frecuencia
                            <input
                                type="text"
                                id={`frequency_${index}`}
                                name="frequency"
                                value={med.frequency}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                        <label htmlFor={`duration_days_${index}`}>
                            Duración (días)
                            <input
                                type="number"
                                id={`duration_days_${index}`}
                                name="duration_days"
                                value={med.duration_days === null || med.duration_days === undefined ? '' : med.duration_days}
                                onChange={(e) => handleMedicationChange(index, e)}
                                min="0"
                            />
                        </label>
                    </div>
                    <label htmlFor={`medication_notes_${index}`}>
                        Notas Adicionales
                        <textarea
                            id={`medication_notes_${index}`}
                            name="notes"
                            value={med.notes || ''}
                            onChange={(e) => handleMedicationChange(index, e)}
                            rows={2}
                        />
                    </label>
                    <button
                        type="button"
                        onClick={() => removeMedication(index)}
                        className="secondary outline"
                        style={{ marginTop: '0.5rem', maxWidth: 'fit-content' }}
                        aria-label="Eliminar medicamento"
                    >
                        <FaTrash />
                    </button>
                </div>
            ))}
            <button type="button" onClick={addMedication} className="outline">
                <FaPlus style={{ marginRight: '0.5rem' }} /> Agregar Medicamento
            </button>
        </fieldset>
    );
} 
----- Archivo: ObservationsSignatureSection.tsx ----- 
// src/components/forms/consultation/sections/ObservationsSignatureSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface ObservationsSignatureSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    professionalName: string;
    professionalRegistration: string;
}

export function ObservationsSignatureSection({
    formData,
    handleChange,
    professionalName,
    professionalRegistration
}: ObservationsSignatureSectionProps) {
    return (
        <fieldset>
            <legend>9. Observaciones y Profesional</legend>
            <label htmlFor="general_observations">
                Observaciones Adicionales / Anexos (descripción)
                <textarea
                    id="general_observations"
                    name="general_observations"
                    value={formData.general_observations || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Consentimientos informados, recomendaciones de egreso, etc."
                />
            </label>

            <div className="grid">
                <label>
                    Nombre MV o MVZ Tratante
                    <input type="text" value={professionalName} readOnly disabled />
                </label>
                <label>
                    Matrícula Profesional
                    <input type="text" value={professionalRegistration} readOnly disabled />
                </label>
            </div>
            <label>
                Firma (Digital o constancia)
                {/* Este campo es complejo de implementar digitalmente sin herramientas específicas.
                    Podría ser un campo de texto donde el vet confirma su responsabilidad. */}
                <input
                    type="text"
                    name="signature_confirmation" // Nuevo campo
                    value={formData.signature_confirmation || ""}
                    onChange={handleChange}
                    placeholder="Confirmo la veracidad de esta consulta bajo mi matrícula profesional."
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: OwnerPetSection.tsx ----- 
// src/components/forms/consultation/sections/OwnerPetSection.tsx
import React from 'react';
import type { OwnerDataType, PetType } from '@/types/index';

interface OwnerPetSectionProps {
    owner: OwnerDataType | null;
    pet: PetType;
    // basicPetData?: BasicDataType; // Podrías pasar BasicDataType si ya la tienes cargada
}

export function OwnerPetSection({ owner, pet /*, basicPetData */ }: OwnerPetSectionProps) {
    // Idealmente, los datos de 'Especie', 'Sexo', 'Fecha de nacimiento', 'Peso (gr.)', 'Chip #'
    // vendrían de `BasicDataType` de la mascota.
    // Aquí simulamos algunos o los dejamos como placeholder.
    // En una implementación real, cargarías `BasicDataType` junto con `PetType`.

    return (
        <>
            <fieldset>
                <legend>2. Datos del Propietario</legend>
                <div className="grid">
                    <label>
                        Nombre Propietario
                        <input type="text" value={`${owner?.name || ''} ${owner?.last_name || ''}`} readOnly disabled />
                    </label>
                    <label>
                        Teléfono Celular
                        <input type="text" value={owner?.phone || ''} readOnly disabled />
                    </label>
                </div>
                <label>
                    Correo Electrónico
                    <input type="text" value={owner?.email || ''} readOnly disabled />
                </label>
                {/* Puedes añadir más campos del propietario si son relevantes y están disponibles */}
            </fieldset>

            <fieldset>
                <legend>3. Reseña de la Mascota</legend>
                <div className="grid">
                    <label>
                        Nombre Paciente
                        <input type="text" value={pet.name} readOnly disabled />
                    </label>
                    <label>
                        Especie
                        {/* <input type="text" value={basicPetData?.pet_type || 'N/A'} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                </div>
                <div className="grid">
                    <label>
                        Raza
                        {/* <input type="text" value={basicPetData?.race || 'N/A'} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                    <label>
                        Sexo
                        {/* <input type="text" value={basicPetData?.gender || 'N/A'} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                </div>
                <div className="grid">
                    <label>
                        Fecha de Nacimiento
                        {/* <input type="date" value={basicPetData?.birth_date ? Dates.format(basicPetData.birth_date) : ''} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                    <label>
                        Peso (gr.)
                        {/* <input type="text" value={basicPetData?.weight || 'N/A'} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                </div>
                <div className="grid">
                    <label>
                        Color y Tipo de Pelaje
                        <input type="text" name="coat_description" placeholder="Describir color y pelaje" readOnly disabled />
                    </label>
                    <label>
                        Chip #
                        {/* <input type="text" value={basicPetData?.chip_number || 'N/A'} readOnly disabled /> */}
                        <input type="text" value={'N/A'} readOnly disabled />
                    </label>
                </div>
                {/* Añade más campos de la reseña según sea necesario */}
            </fieldset>
        </>
    );
} 
----- Archivo: PhysicalExamSection.tsx ----- 
// src/components/forms/consultation/sections/PhysicalExamSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface PhysicalExamSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    handleNumericChange: (name: keyof CreateConsultationPayload, value: string) => void;
}

export function PhysicalExamSection({ formData, handleChange, handleNumericChange }: PhysicalExamSectionProps) {
    return (
        <fieldset>
            <legend>5. Examen Físico General</legend>
            
            {/* Sub-sección: Constantes Fisiológicas y Estado General */}
            <div className="grid">
                <label htmlFor="body_condition_score">
                    Condición Corporal (1-5)
                    <input
                        type="number"
                        id="body_condition_score"
                        name="body_condition_score"
                        value={formData.body_condition_score === undefined || formData.body_condition_score === null ? '' : formData.body_condition_score}
                        onChange={(e) => handleNumericChange('body_condition_score', e.target.value)}
                        min="1" max="5" step="0.5"
                        placeholder="Ej: 3"
                    />
                </label>
                <label htmlFor="temperature_celsius">
                    T (°C)
                    <input
                        type="number"
                        id="temperature_celsius"
                        name="temperature_celsius"
                        value={formData.temperature_celsius === undefined || formData.temperature_celsius === null ? '' : formData.temperature_celsius}
                        onChange={(e) => handleNumericChange('temperature_celsius', e.target.value)}
                        step="0.1"
                        placeholder="Ej: 38.5"
                    />
                </label>
            </div>
            <div className="grid">
                 <label htmlFor="heart_rate_bpm">
                    FC (L/min)
                    <input
                        type="number"
                        id="heart_rate_bpm"
                        name="heart_rate_bpm"
                        value={formData.heart_rate_bpm === undefined || formData.heart_rate_bpm === null ? '' : formData.heart_rate_bpm}
                        onChange={(e) => handleNumericChange('heart_rate_bpm', e.target.value)}
                        min="0"
                        placeholder="Ej: 120"
                    />
                </label>
                <label htmlFor="respiratory_rate_rpm">
                    FR (R/min)
                    <input
                        type="number"
                        id="respiratory_rate_rpm"
                        name="respiratory_rate_rpm"
                        value={formData.respiratory_rate_rpm === undefined || formData.respiratory_rate_rpm === null ? '' : formData.respiratory_rate_rpm}
                        onChange={(e) => handleNumericChange('respiratory_rate_rpm', e.target.value)}
                        min="0"
                        placeholder="Ej: 20"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="capillary_refill_time_sec">
                    TRPC (seg) / TLLC (seg)
                    <input
                        type="number"
                        id="capillary_refill_time_sec"
                        name="capillary_refill_time_sec"
                        value={formData.capillary_refill_time_sec === undefined || formData.capillary_refill_time_sec === null ? '' : formData.capillary_refill_time_sec}
                        onChange={(e) => handleNumericChange('capillary_refill_time_sec', e.target.value)}
                        min="0" step="0.1"
                        placeholder="Ej: 1.5"
                    />
                </label>
                <label htmlFor="pulse_description"> {/* Nuevo campo para descripción del pulso */}
                    Pulso (descripción)
                    <input
                        type="text"
                        id="pulse_description"
                        name="pulse_description"
                        value={formData.pulse_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: Fuerte, rítmico"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="mucous_membranes_description">
                    Mucosas
                    <input
                        type="text"
                        id="mucous_membranes_description"
                        name="mucous_membranes_description"
                        value={formData.mucous_membranes_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: Rosadas, húmedas"
                    />
                </label>
                <label htmlFor="hydration_percentage_description"> {/* Cambiado para ser descripción */}
                    Porcentaje Deshidratación (descripción)
                    <input
                        type="text"
                        id="hydration_percentage_description"
                        name="hydration_percentage_description" // Renombrar en types/schema
                        value={formData.hydration_percentage_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: 5% estimado, leve"
                    />
                </label>
            </div>
             <label htmlFor="sense_organs_description">
                Órganos de los Sentidos (general)
                <textarea
                    id="sense_organs_description"
                    name="sense_organs_description"
                    value={formData.sense_organs_description || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Observaciones generales sobre ojos, oídos, nariz..."
                />
            </label>
            
            {/* Sub-sección: Examen por Sistemas */}
            <h6 style={{ marginTop: '1.5rem', marginBottom: '0.5rem' }}>Examen por Sistemas:</h6>
            <label htmlFor="skin_and_coat_description">
                Piel y Pelaje
                <textarea id="skin_and_coat_description" name="skin_and_coat_description" value={formData.skin_and_coat_description || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="lymph_nodes_description">
                Ganglios Linfáticos
                <textarea id="lymph_nodes_description" name="lymph_nodes_description" value={formData.lymph_nodes_description || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="digestive_system_findings">
                Sistema Digestivo
                <textarea id="digestive_system_findings" name="digestive_system_findings" value={formData.digestive_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="respiratory_system_findings">
                Sistema Respiratorio
                <textarea id="respiratory_system_findings" name="respiratory_system_findings" value={formData.respiratory_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="endocrine_system_findings">
                Sistema Endocrino
                <textarea id="endocrine_system_findings" name="endocrine_system_findings" value={formData.endocrine_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="musculoskeletal_system_findings">
                Sistema Músculo Esquelético
                <textarea id="musculoskeletal_system_findings" name="musculoskeletal_system_findings" value={formData.musculoskeletal_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="nervous_system_findings">
                Sistema Nervioso
                <textarea id="nervous_system_findings" name="nervous_system_findings" value={formData.nervous_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="urinary_system_findings">
                Sistema Urinario
                <textarea id="urinary_system_findings" name="urinary_system_findings" value={formData.urinary_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="reproductive_system_findings">
                Sistema Reproductivo
                <textarea id="reproductive_system_findings" name="reproductive_system_findings" value={formData.reproductive_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="rectal_palpation_findings">
                Palpación Rectal (si aplica)
                <textarea id="rectal_palpation_findings" name="rectal_palpation_findings" value={formData.rectal_palpation_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="other_physical_findings">
                Otros Hallazgos Físicos
                <textarea id="other_physical_findings" name="other_physical_findings" value={formData.other_physical_findings || ''} onChange={handleChange} rows={2} />
            </label>
        </fieldset>
    );
} 
----- Archivo: ProceduresSection.tsx ----- 
// src/components/forms/consultation/sections/ProceduresSection.tsx
import React from 'react';
import type { ConsultationProcedureType } from '@/types/index'; // Usaremos el tipo base
import { FaPlus, FaTrash } from 'react-icons/fa';

// El tipo para el formulario interno, sin los campos generados por BD
type ProcedureFormItem = Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>;

interface ProceduresSectionProps {
    procedures: ProcedureFormItem[];
    onChange: (updatedProcedures: ProcedureFormItem[]) => void;
}

export function ProceduresSection({ procedures, onChange }: ProceduresSectionProps) {
    const addProcedure = () => {
        onChange([...procedures, { procedure_name: '', description: '' }]);
    };

    const removeProcedure = (index: number) => {
        const updated = procedures.filter((_, i) => i !== index);
        onChange(updated);
    };

    const handleProcedureChange = (
        index: number,
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        const { name, value } = e.target;
        const updated = procedures.map((proc, i) =>
            i === index ? { ...proc, [name]: value } : proc
        );
        onChange(updated);
    };

    return (
        <fieldset>
            <legend>Procedimientos Realizados en Consulta</legend>
            {procedures.map((proc, index) => (
                <div key={index} className="grid" style={{ alignItems: 'flex-end', marginBottom: '1rem', border: '1px solid #e0e0e0', padding: '1rem', borderRadius: '4px' }}>
                    <label htmlFor={`procedure_name_${index}`}>
                        Nombre del Procedimiento
                        <input
                            type="text"
                            id={`procedure_name_${index}`}
                            name="procedure_name"
                            value={proc.procedure_name}
                            onChange={(e) => handleProcedureChange(index, e)}
                            placeholder="Ej: Limpieza de oídos"
                            required
                        />
                    </label>
                    <label htmlFor={`procedure_description_${index}`} className="pico-col-span-2"> {/* Ocupa más espacio si es necesario */}
                        Descripción/Notas
                        <textarea
                            id={`procedure_description_${index}`}
                            name="description"
                            value={proc.description || ''}
                            onChange={(e) => handleProcedureChange(index, e)}
                            rows={2}
                        />
                    </label>
                    <button
                        type="button"
                        onClick={() => removeProcedure(index)}
                        className="secondary outline"
                        style={{ maxWidth: 'fit-content', marginBottom: '0.5rem' }} // PicoCSS a veces necesita ajustes para botones pequeños
                        aria-label="Eliminar procedimiento"
                    >
                        <FaTrash />
                    </button>
                </div>
            ))}
            <button type="button" onClick={addProcedure} className="outline">
                <FaPlus style={{ marginRight: '0.5rem' }} /> Agregar Procedimiento
            </button>
        </fieldset>
    );
} 
----- Archivo: page.tsx ----- 
// src/app/pages/vet/consultation/[petId]/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { useRouter, useParams } from "next/navigation";
import { Title, Loading, DataNotFound } from "@/components/index";
import { PetType, CreateConsultationPayload } from "@/types/index";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useVetContext } from "@/context/VetContext"; // Si los datos del vet vienen de aquí
import { getFetch, postFetch } from "@/app/api";
import { FaClipboardList } from "react-icons/fa";
import { ConsultationForm } from "../ConsultationForm";

export default function ConsultationPage() {
    const router = useRouter();
    const params = useParams();
    const petId = params.petId as string;

    const { db: session } = useSessionContext();
    const { storedPet, storedVetAccess, setStoredPet } = useStorageContext();
    const { vet: veterinarianData } = useVetContext(); // Datos del veterinario logueado

    const [pet, setPet] = useState<PetType | null>(storedPet.id === petId ? storedPet : null);
    const [loadingPet, setLoadingPet] = useState<boolean>(!pet);
    const [errorPet, setErrorPet] = useState<string | null>(null);
    const [submitting, setSubmitting] = useState<boolean>(false);
    const [submitError, setSubmitError] = useState<string | null>(null);

    useEffect(() => {
        if (!petId) {
            setErrorPet("ID de mascota no encontrado en la ruta.");
            setLoadingPet(false);
            return;
        }

        if (storedPet.id === petId) {
            setPet(storedPet);
            setLoadingPet(false);
        } else {
            const fetchPet = async () => {
                try {
                    const response = await getFetch(`/api/pets/${petId}`);
                    const petData = await response.json();
                    if (!response.ok || !petData) {
                        throw new Error(petData.message || "Mascota no encontrada");
                    }
                    setPet(petData);
                    setStoredPet(petData); // Actualizar el contexto si se carga una diferente
                } catch (err) {
                    console.error("Error fetching pet:", err);
                    setErrorPet(err instanceof Error ? err.message : "Error cargando datos de la mascota.");
                } finally {
                    setLoadingPet(false);
                }
            };
            fetchPet();
        }
    }, [petId, storedPet, setStoredPet]);

    const handleFormSubmit = async (formData: CreateConsultationPayload) => {
        setSubmitting(true);
        setSubmitError(null);

        const payload: CreateConsultationPayload = {
            ...formData,
            pet_id: petId,
        };

        // Determinar quién registra la consulta
        if (veterinarianData?.vet_id && session?.user?.user_metadata?.role === 'veterinarian') {
            payload.veterinarian_id = veterinarianData.vet_id;
        } else if (storedVetAccess?.id) {
            // Si se accedió con código y el usuario actual NO es un veterinario con sesión
            // (o si queremos priorizar el vet_access_id si existe)
            payload.veterinary_access_id = storedVetAccess.id;
            // Opcionalmente, podrías querer también el ID del usuario que está usando el código si está logueado
            // payload.uploaded_by_user_id = session?.user?.id;
        } else {
            setSubmitError("No se pudo identificar al veterinario responsable. Inicie sesión como veterinario o use un código de acceso válido.");
            setSubmitting(false);
            return;
        }

        try {
            const response = await postFetch('/api/consultations', undefined, payload);
            const result = await response.json();

            if (!response.ok || !result.success) {
                throw new Error(result.message || "Error al guardar la consulta.");
            }

            // Aquí podrías manejar la subida de archivos si se hace después de crear la consulta
            // o si el `ConsultationForm` maneja la subida de archivos y pasa las URLs/IDs

            alert("Consulta guardada exitosamente.");
            // Redirigir a la página de la mascota o a una lista de consultas
            router.push(`/pages/pet/basic-data`); // O una ruta más apropiada

        } catch (err) {
            console.error("Error submitting consultation:", err);
            setSubmitError(err instanceof Error ? err.message : "Error desconocido al guardar.");
        } finally {
            setSubmitting(false);
        }
    };

    if (loadingPet) return <Loading />;
    if (errorPet) return <DataNotFound message={errorPet} />;
    if (!pet) return <DataNotFound message="Mascota no encontrada." />;

    return (
        <main style={{ padding: "2rem" }}>
            <Title icon={<FaClipboardList />} title={`Nueva Consulta para ${pet.name}`} />

            {submitError && <p className="text-error" style={{ marginTop: '1rem' }}>{submitError}</p>}

            <ConsultationForm
                pet={pet}
                onSubmit={handleFormSubmit}
                isSubmitting={submitting}
            // Pasar datos del veterinario si se van a mostrar en el form (ej. nombre del profesional)
            // veterinarianInfo={veterinarianData || storedVetAccess}
            />
        </main>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/vet/[code]/page.tsx
"use client";
import { useEffect, useState } from "react";
import { useStorageContext } from "@/context/StorageProvider";
import PetEditForm from "./components/forms/PetEditForm";
import { PetType } from "@/types/index";
import { useRouter } from "next/navigation";

interface VetPageProps {
  params: Promise<{ code: string }>;
}

export default function VetPage({ params }: VetPageProps) {
  const [validatedCode, setValidatedCode] = useState("");
  const [pet, setPet] = useState<PetType | null>(null);
  const [isValid, setIsValid] = useState(false);
  const [message, setMessage] = useState("");
  const router = useRouter();

  const storage = useStorageContext();

  useEffect(() => {
    const fetchData = async () => {
      const { code } = await params;
      setValidatedCode(code);

      try {
        const res = await fetch(`/api/vet/validate?code=${code}`);
        const data = await res.json();

        if (!res.ok || !data.success) {
          setMessage(data.message || "Error validando el código.");
          return;
        }

        storage.setStoredPetCode(data.codeRecord);
        storage.setStoredPet(data.pet);
        if (data.vetAccess) {
          storage.setStoredVetAccess(data.vetAccess);
        }

        setPet(data.pet);
        router.replace(`/pages/vet/consultation/${data.pet.id}`);
        setIsValid(true);

      } catch (err) {
        console.error("Error validando código veterinario:", err);
        setMessage("Ocurrió un error al validar el código.");
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params]);

  return (
    <main className="container" style={{ padding: "2rem" }}>
      <h1>Editar datos de mascota</h1>

      {!isValid && (
        <p style={{ marginBottom: "1rem", color: "red" }}>
          {message}
        </p>
      )}

      {pet && (
        <PetEditForm code={validatedCode} pet={pet} disabled={!isValid} />
      )}
    </main>
  );
}
 
----- Archivo: PetEditForm.tsx ----- 
// app/pages/vet/[code]/components/forms/PetEditForm.tsx
"use client";
import { putFetch } from "@/app/api";
import { PetType } from "@/types/index";
import React, { useState, FormEvent } from "react";

interface Props {
  code: string;
  pet: PetType;
  disabled?: boolean;
}

export default function PetEditForm({ code, pet, disabled = false }: Props) {
  const [name, setName] = useState(pet.name);
  const [image, setImage] = useState(pet.image || "");
  const [alert, setAlert] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (disabled) return;

    const res = await putFetch(`/api/vet/edit/${pet.id}`, undefined, { code, name, image });

    // ← usar res.ok para determinar éxito
    const success = res.ok;
    setFormFailed(!success);

    if (success) {
      setAlert("Datos actualizados correctamente.");
    } else {
      const json = await res.json();
      setAlert(json.error || "Error al actualizar.");
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: 400, display: "grid", gap: "1rem" }}
    >
      <label>
        Nombre
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          disabled={disabled}
          required
        />
      </label>

      <label>
        Imagen
        <input
          type="text"
          value={image}
          onChange={(e) => setImage(e.target.value)}
          disabled={disabled}
        />
      </label>

      <button type="submit" disabled={disabled}>
        Guardar cambios
      </button>

      {alert && (
        // ← solo basar color en formFailed
        <p style={{ color: formFailed ? "red" : "green" }}>{alert}</p>
      )}
    </form>
  );
}
 
----- Archivo: layout.tsx ----- 
// app/vet-access/layout.tsx
export default function VetLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/vet-access/page.tsx
"use client";
import React, { useState } from "react";
import Link from "next/link";
import VeterinaryModal from "@/components/modals/VeterinaryModal";

export default function VetAccessPage() {
  const [showVetModal, setShowVetModal] = useState(false);

  return (
    <main className="container" style={{ padding: "2rem", maxWidth: 600 }}>
      <h1>Acceso Veterinario</h1>
      <p>
        Introduce el código de la mascota que te haya facilitado el dueño para
        ver su historial y agregar nuevas entradas.
      </p>

      <div
        className="grid"
        style={{ gridTemplateColumns: "1fr", gap: "1rem", margin: "2rem 0" }}
      >
        {/* Botón para acceder sin registrarse */}
        <button
          className="contrast"
          onClick={() => setShowVetModal(true)}
        >
          Ingresar sin registrarse
        </button>

        {/* Enlace a registro de veterinario (implementa esta ruta si lo deseas) */}
        <Link href="/vet-access/register" className="primary">
          Registrarme como veterinario
        </Link>
      </div>

      {/**  
       * Reutilizamos el componente VeterinaryModal para capturar datos
       * y hacer el POST a VeterinaryAccessRepository.create  
       */}
      {showVetModal && (
        <VeterinaryModal />
      )}
    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// app/vet-access/register/page.tsx
"use client";
import React, { FormEvent, useState } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import ModalComponent from "@/components/lib/modal";
import { postFetch } from "@/app/api";
import { FaEye, FaEyeSlash } from "react-icons/fa";
import { ownerSignUp } from "@/services/authService";

export default function VetRegisterPage() {
  const router = useRouter();

  // Estados del formulario
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  // Estados UI
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError("");

    // Validación básica
    if (![firstName, lastName, registration, clinicName, city, email, password].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }

    setLoading(true);
    try {
      // 1) Crear cuenta en auth
      const { data: { user } } = await ownerSignUp(email, password, 'veterinarian');
      const vetId = user?.id;
      /*
      const signUpRes = await postFetch("/api/auth/sign-up", undefined, { email, password, role: 'veterinarian' });
      const signUpJson = await signUpRes.json();
      if (!signUpRes.ok || !signUpJson.success) {
        setError("Error al registrar la cuenta.");
        return;
      }
      const vetId = signUpJson.user?.id;*/
      if (vetId) {
        // 2) Guardar perfil de veterinario
        const profileRes = await postFetch("/api/vet", undefined, {
          vet_id: vetId,
          first_name: firstName,
          last_name: lastName,
          registration,
          clinic_name: clinicName,
          city,
          email
        });
        if (!profileRes.ok) {
          setError("Error creando perfil de veterinario.");
          return;
        }
      }

      // 3) Mostrar modal de confirmación de correo
      setShowConfirmModal(true);

    } catch {
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  // Modal de “Confirma tu correo”
  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal}
      >
        <button
          className="contrast"
          onClick={() => router.push("/")}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          Ya confirmé, continuar
        </button>
      </ModalComponent>
    );
  }

  // Formulario de registro
  return (
    <main style={{ maxWidth: 600, margin: "2rem auto", padding: '2rem' }}>
      <h1>Registro Veterinario</h1>
      <form onSubmit={handleSubmit}
        style={{
          background: "#fff",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
          width: "100%",
          maxWidth: "550px",
        }}>
        <div className="grid" style={{ gridTemplateColumns: "1fr 1fr", gap: "1rem" }}>
          <label>
            Nombre
            <input
              type="text"
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              required
            />
          </label>
          <label>
            Apellido
            <input
              type="text"
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              required
            />
          </label>
          <label>
            Registro profesional
            <input
              type="text"
              value={registration}
              onChange={e => setRegistration(e.target.value)}
              required
            />
          </label>
          <label>
            Clínica / Laboratorio
            <input
              type="text"
              value={clinicName}
              onChange={e => setClinicName(e.target.value)}
              required
            />
          </label>
          <label>
            Ciudad
            <input
              type="text"
              value={city}
              onChange={e => setCity(e.target.value)}
              required
            />
          </label>
        </div>

        <label>
          Email
          <input
            type="email"
            value={email}
            onChange={e => setEmail(e.target.value)}
            required
          />
        </label>

        <label style={{ position: 'relative' }}>
          Contraseña
          <input
            type={showPassword ? "text" : "password"}
            value={password}
            onChange={e => setPassword(e.target.value)}
            required
          />
          <button
            type="button"
            onClick={() => setShowPassword(!showPassword)}
            aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
            style={{
              position: 'absolute',
              right: '0.75rem',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'none',
              border: 'none',
              padding: 0,
              cursor: 'pointer',
            }}
          >
            {showPassword ? <FaEyeSlash size={23} color={'#000'} style={{ marginTop: '16px' }} /> : <FaEye size={23} color={'#000'} style={{ marginTop: '16px' }} />}
          </button>
        </label>

        {error && <p style={{ color: "red", marginTop: "0.5rem" }}>{error}</p>}

        <button
          type="submit"
          disabled={loading}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          {loading ? "Registrando..." : "Registrarme"}
        </button>
      </form>
    </main>
  );
}
 
----- Archivo: index.ts ----- 
// layout
export { default as SideBar } from "./layout/SideBar";
export { default as Bubbles } from "./modals/Bubbles";
export { default as ClientAppProvider } from "../context/ClientAppProvider";

// lib
export { default as AddItem } from "./lib/addItem";
export { default as BasicField } from "./lib/basicField";
export { default as CircularImage } from './lib/circularImage';
export { default as DataNotFound } from "./lib/dataNotFound";
export { default as Display } from "./lib/display";
export { default as Entities } from "./lib/entities";
export { default as Entity } from "./lib/entity";
export { default as EntityFields } from "./lib/entityFields";
export { default as EntityForm } from "./lib/entityForm";
export { default as Field } from "./lib/field";
export { default as Form } from "./lib/form";
export { default as Loading } from "./lib/loading";
export { default as Modal } from "./lib/modal";
export { default as PageComponent } from "./lib/page";
export { default as RemoveItem } from "./lib/removeItem";
export { default as Steps } from "./lib/steps";
export { default as Title } from "./lib/title";

export { default as ConsultationDetailView } from './consultations/ConsultationDetailView';
 
----- Archivo: ConsultationDetailView.tsx ----- 
// src/components/consultations/ConsultationDetailView.tsx
"use client";
import React, { useRef, useState } from 'react';
import { ConsultationType, ConsultationFileType } from '@/types/index';
import { Dates } from '@/utils/index';
import { FaPaperclip, FaTrash, FaDownload, FaSpinner, FaPlusCircle } from 'react-icons/fa';

interface ConsultationDetailViewProps {
    consultation: ConsultationType;
    currentUserId: string | null;
    onFileAdded: () => void;
}

const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; // 5MB
const ALLOWED_FILE_TYPES_ARRAY = ['image/jpeg', 'image/png', 'application/pdf', 'image/webp', 'image/gif'];

// Helper para verificar si un valor se considera "con datos"
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const hasValue = (value: any): boolean => {
    if (value === null || value === undefined) return false;
    if (typeof value === 'string' && value.trim() === '') return false;
    if (typeof value === 'number' && isNaN(value)) return false; // Aunque los nulls numéricos ya se filtran
    return true;
};


export default function ConsultationDetailView({ consultation, currentUserId, onFileAdded }: ConsultationDetailViewProps) {
    const [showAddFile, setShowAddFile] = useState(false);
    const [fileToUpload, setFileToUpload] = useState<File | null>(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);
    // ... (resto del estado y handlers como antes: isUploading, uploadError, fileInputRef, canEditOrAddFiles, handleFileSelect, handleUploadFile, handleDownloadFile, handleDeleteFile)
    const canEditOrAddFiles = consultation.veterinarian_id === currentUserId ||
        (consultation.veterinary_access_id && currentUserId && consultation.veterinarian_id === null);

    const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.files && event.target.files[0]) {
            const file = event.target.files[0];
            if (file.size > MAX_FILE_SIZE_BYTES) {
                setUploadError(`El archivo excede ${MAX_FILE_SIZE_BYTES / (1024 * 1024)}MB.`);
                setFileToUpload(null);
                return;
            }
            if (!ALLOWED_FILE_TYPES_ARRAY.includes(file.type)) {
                setUploadError(`Tipo de archivo no permitido. Permitidos: ${ALLOWED_FILE_TYPES_ARRAY.join(', ')}`);
                setFileToUpload(null);
                return;
            }
            setFileToUpload(file);
            setUploadError(null);
        }
    };

    const handleUploadFile = async () => {
        if (!fileToUpload || !canEditOrAddFiles) return;
        setIsUploading(true);
        setUploadError(null);
        const formData = new FormData();
        formData.append('file', fileToUpload);
        formData.append('petId', consultation.pet_id);
        try {
            const response = await fetch(`/api/consultations/${consultation.id}/files`, {
                method: 'POST',
                body: formData,
            });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.message || 'Error al subir el archivo.');
            }
            alert('Archivo subido exitosamente!');
            setFileToUpload(null);
            setShowAddFile(false);
            if (fileInputRef.current) fileInputRef.current.value = "";
            onFileAdded();
        } catch (err) {
            setUploadError(err instanceof Error ? err.message : 'Error desconocido.');
        } finally {
            setIsUploading(false);
        }
    };

    const handleDownloadFile = async (file: ConsultationFileType) => {
        try {
            const response = await fetch(`/api/consultations/files/${file.id}/download`);
            const result = await response.json();
            if (response.ok && result.success && result.downloadUrl) {
                window.open(result.downloadUrl, '_blank');
            } else {
                throw new Error(result.message || "No se pudo obtener la URL de descarga.");
            }
        } catch (err) {
            alert(err instanceof Error ? err.message : "Error al descargar archivo.");
        }
    };

    const handleDeleteFile = async (fileId: string) => {
        if (!confirm("¿Está seguro de que desea eliminar este archivo? Esta acción no se puede deshacer.")) return;
        try {
            const response = await fetch(`/api/consultations/files/${fileId}`, { method: 'DELETE' });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.message || "Error eliminando archivo.");
            }
            alert("Archivo eliminado.");
            onFileAdded();
        } catch (err) {
            alert(err instanceof Error ? err.message : "No se pudo eliminar el archivo.");
        }
    };


    const renderField = (label: string, value: string | number | boolean | null | undefined, isTextArea = false) => {
        if (!hasValue(value)) return null; // Usar el helper hasValue
        const displayValue = typeof value === 'boolean' ? (value ? 'Sí' : 'No') : value;
        return (
            <div style={{ marginBottom: '0.8rem', paddingBottom: '0.5rem', borderBottom: '1px dotted #eee' }}>
                <strong style={{ display: 'block', color: 'var(--secondary)', fontSize: '0.9em' }}>{label}:</strong>
                {isTextArea ? (
                    <p style={{ whiteSpace: 'pre-wrap', margin: '0.25rem 0 0 0' }}>{displayValue}</p>
                ) : (
                    <span style={{ display: 'block', margin: '0.25rem 0 0 0' }}>{displayValue}</span>
                )}
            </div>
        );
    };

    // --- Funciones para determinar si una sección tiene datos ---
    const anamnesisFields = [
        consultation.current_diet, consultation.previous_illnesses, consultation.previous_surgeries,
        consultation.vaccination_history, consultation.last_deworming_product, consultation.recent_treatments,
        consultation.recent_travels, consultation.animal_behavior_owner_description,
        consultation.lives_with_other_animals_details, consultation.sterilized_status, consultation.birth_count
    ];
    const showAnamnesisSection = hasValue(consultation.reason_for_consultation) || anamnesisFields.some(hasValue);

    const physicalExamGeneralFields = [
        consultation.body_condition_score, consultation.temperature_celsius, consultation.heart_rate_bpm,
        consultation.respiratory_rate_rpm, consultation.capillary_refill_time_sec, consultation.pulse_description,
        consultation.mucous_membranes_description, consultation.hydration_percentage_description,
        consultation.sense_organs_description
    ];
    const physicalExamSystemsFields = [
        consultation.skin_and_coat_description, consultation.lymph_nodes_description,
        consultation.digestive_system_findings, consultation.respiratory_system_findings,
        consultation.endocrine_system_findings, consultation.musculoskeletal_system_findings,
        consultation.nervous_system_findings, consultation.urinary_system_findings,
        consultation.reproductive_system_findings, consultation.rectal_palpation_findings,
        consultation.other_physical_findings
    ];
    const showPhysicalExamSection = physicalExamGeneralFields.some(hasValue) || physicalExamSystemsFields.some(hasValue);

    const diagnosticApproachFields = [
        consultation.problem_list, consultation.master_problem_list, consultation.differential_diagnoses
    ];
    const showDiagnosticApproachSection = diagnosticApproachFields.some(hasValue);

    const diagnosisPlanFields = [
        consultation.definitive_diagnosis, consultation.therapeutic_plan, // Presumptive es obligatorio
        consultation.prognosis, consultation.evolution_notes
    ];
    const showDiagnosisPlanSection = hasValue(consultation.presumptive_diagnosis) || hasValue(consultation.therapeutic_plan) || diagnosisPlanFields.some(hasValue);

    const observationsFields = [
        consultation.general_observations, consultation.signature_confirmation
    ];
    const showObservationsSection = observationsFields.some(hasValue);


    return (
        <article className="pico-paper" style={{ padding: '1.5rem', fontSize: '0.95rem' }}>
            {/* Sección de Identificación (siempre visible o con sus propias comprobaciones) */}
            <div className="grid">
                {renderField("Fecha", Dates.format(consultation.consultation_date))}
                {renderField("Hora", consultation.consultation_time)}
            </div>
            <div className="grid">
                {renderField("HC #", consultation.hc_number)}
                {renderField("Institución", consultation.institution_name)}
            </div>
            {(hasValue(consultation.hc_number) || hasValue(consultation.institution_name) || hasValue(consultation.consultation_time)) && <hr />}


            {showAnamnesisSection && (
                <>
                    <h4>Anamnesis</h4>
                    {renderField("Motivo de Consulta", consultation.reason_for_consultation, true)}
                    {renderField("Dieta Actual", consultation.current_diet, true)}
                    {renderField("Enfermedades Previas", consultation.previous_illnesses, true)}
                    {renderField("Cirugías Previas", consultation.previous_surgeries, true)}
                    {renderField("Esquema Vacunal (Resumen)", consultation.vaccination_history, true)}
                    {renderField("Última Desparasitación y Producto", consultation.last_deworming_product)}
                    {renderField("Tratamientos Recientes", consultation.recent_treatments, true)}
                    {renderField("Viajes Recientes", consultation.recent_travels, true)}
                    {renderField("Comportamiento del Animal (descripción del propietario)", consultation.animal_behavior_owner_description, true)}
                    {renderField("Convive con otros animales (detalles)", consultation.lives_with_other_animals_details)}
                    {renderField("Esterilizado", consultation.sterilized_status)}
                    {renderField("N° de Partos", consultation.birth_count)}
                    <hr />
                </>
            )}

            {showPhysicalExamSection && (
                <>
                    <h4>Examen Físico</h4>
                    {physicalExamGeneralFields.some(hasValue) && <h5>General</h5>}
                    {renderField("Condición Corporal (1-5)", consultation.body_condition_score)}
                    {renderField("Temperatura (°C)", consultation.temperature_celsius)}
                    {renderField("Frecuencia Cardíaca (lpm)", consultation.heart_rate_bpm)}
                    {renderField("Frecuencia Respiratoria (rpm)", consultation.respiratory_rate_rpm)}
                    {renderField("TRPC/TLLC (seg)", consultation.capillary_refill_time_sec)}
                    {renderField("Pulso (descripción)", consultation.pulse_description)}
                    {renderField("Mucosas (descripción)", consultation.mucous_membranes_description)}
                    {renderField("Hidratación (descripción)", consultation.hydration_percentage_description)}
                    {renderField("Órganos de los Sentidos (descripción)", consultation.sense_organs_description, true)}

                    {physicalExamSystemsFields.some(hasValue) && <h5 style={{ marginTop: '1rem' }}>Por Sistemas</h5>}
                    {renderField("Piel y Pelaje", consultation.skin_and_coat_description, true)}
                    {renderField("Ganglios Linfáticos", consultation.lymph_nodes_description, true)}
                    {renderField("Sistema Digestivo", consultation.digestive_system_findings, true)}
                    {renderField("Sistema Respiratorio", consultation.respiratory_system_findings, true)}
                    {renderField("Sistema Endocrino", consultation.endocrine_system_findings, true)}
                    {renderField("Sistema Músculo Esquelético", consultation.musculoskeletal_system_findings, true)}
                    {renderField("Sistema Nervioso", consultation.nervous_system_findings, true)}
                    {renderField("Sistema Urinario", consultation.urinary_system_findings, true)}
                    {renderField("Sistema Reproductivo", consultation.reproductive_system_findings, true)}
                    {renderField("Palpación Rectal", consultation.rectal_palpation_findings, true)}
                    {renderField("Otros Hallazgos Físicos", consultation.other_physical_findings, true)}
                    <hr />
                </>
            )}

            {consultation.procedures && consultation.procedures.length > 0 && (
                <>
                    <h4>Procedimientos Realizados en Consulta</h4>
                    {/* ... (código de lista de procedimientos sin cambios) ... */}
                    <ul style={{ paddingLeft: '1.5rem', listStyleType: 'disc' }}>
                        {consultation.procedures.map(proc => (
                            <li key={proc.id} style={{ marginBottom: '0.5rem' }}>
                                <strong>{proc.procedure_name}</strong>
                                {proc.description && <p style={{ fontSize: '0.9em', margin: '0.2em 0 0.5em 1em', color: 'var(--muted-color)' }}>{proc.description}</p>}
                            </li>
                        ))}
                    </ul>
                    <hr />
                </>
            )}

            {consultation.medications && consultation.medications.length > 0 && (
                <>
                    <h4>Medicamentos Administrados/Prescritos en Consulta</h4>
                    {/* ... (código de lista de medicamentos sin cambios) ... */}
                    <ul style={{ paddingLeft: '1.5rem', listStyleType: 'disc' }}>
                        {consultation.medications.map(med => (
                            <li key={med.id} style={{ marginBottom: '0.5rem' }}>
                                <strong>{med.medication_name}</strong>: {med.dosage} / {med.frequency}
                                {med.duration_days && <span> por {med.duration_days} día(s)</span>}
                                {med.notes && <p style={{ fontSize: '0.9em', margin: '0.2em 0 0.5em 1em', color: 'var(--muted-color)' }}>{med.notes}</p>}
                            </li>
                        ))}
                    </ul>
                    <hr />
                </>
            )}

            {showDiagnosticApproachSection && (
                <>
                    <h4>Abordaje Diagnóstico</h4>
                    {renderField("Lista de Problemas", consultation.problem_list, true)}
                    {renderField("Lista Maestra (Problema Principal)", consultation.master_problem_list, true)}
                    {renderField("Diagnósticos Diferenciales", consultation.differential_diagnoses, true)}
                    <hr />
                </>
            )}

            {/* Sección de Exámenes Complementarios y Archivos */}
            {(hasValue(consultation.complementary_exams_summary) || (consultation.files && consultation.files.length > 0) || canEditOrAddFiles) && (
                <>
                    <h4>Exámenes Complementarios</h4>
                    {renderField("Resumen de Exámenes / Hallazgos Principales", consultation.complementary_exams_summary, true)}

                    {consultation.files && consultation.files.length > 0 && (
                        // ... (código de lista de archivos sin cambios) ...
                        <div style={{ marginTop: '1rem', marginBottom: '1rem' }}>
                            <h5>Archivos Adjuntos:</h5>
                            {consultation.files.map(file => (
                                <div key={file.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.5rem 0.2rem', borderBottom: '1px solid #f0f0f0' }}>
                                    <span style={{ display: 'flex', alignItems: 'center' }}><FaPaperclip style={{ marginRight: '0.5rem', color: 'var(--muted-color)' }} /> {file.file_name} <small style={{ marginLeft: '0.5rem', color: 'var(--muted-font-color)' }}>({(file.file_size_bytes || 0 / 1024).toFixed(1)}KB)</small></span>
                                    <div>
                                        <button onClick={() => handleDownloadFile(file)} className="outline secondary pico-button-small" aria-label="Descargar" title="Descargar" style={{ marginRight: '0.5rem', padding: '0.3rem 0.6rem' }}>
                                            <FaDownload />
                                        </button>
                                        {canEditOrAddFiles && (
                                            <button onClick={() => handleDeleteFile(file.id)} className="outline contrast pico-button-small" aria-label="Eliminar" title="Eliminar" style={{ padding: '0.3rem 0.6rem' }}>
                                                <FaTrash />
                                            </button>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {canEditOrAddFiles && (
                        // ... (código para añadir archivo sin cambios) ...
                        <div style={{ marginTop: '1.5rem', marginBottom: '1rem' }}>
                            <button type="button" onClick={() => setShowAddFile(prev => !prev)} className="outline pico-button-small">
                                {showAddFile ? 'Cancelar subida' : <><FaPlusCircle style={{ marginRight: '0.5rem' }} /> Adjuntar Nuevo Archivo</>}
                            </button>
                            {showAddFile && (
                                <div style={{ marginTop: '1rem', border: '1px dashed var(--primary)', padding: '1rem', borderRadius: 'var(--pico-border-radius)' }}>
                                    <label htmlFor="file-upload-detail">Seleccionar archivo:</label>
                                    <input id="file-upload-detail" type="file" ref={fileInputRef} onChange={handleFileSelect} accept={ALLOWED_FILE_TYPES_ARRAY.join(',')} />
                                    {fileToUpload && <p style={{ marginTop: '0.5rem', fontSize: '0.85em' }}>Seleccionado: {fileToUpload.name}</p>}
                                    {uploadError && <p className="text-error" style={{ marginTop: '0.5rem' }}>{uploadError}</p>}
                                    <button
                                        onClick={handleUploadFile}
                                        disabled={!fileToUpload || isUploading}
                                        aria-busy={isUploading}
                                        style={{ marginTop: '1rem' }}
                                    >
                                        {isUploading ? <><FaSpinner className="animate-spin" /> Subiendo...</> : "Confirmar y Subir Archivo"}
                                    </button>
                                </div>
                            )}
                        </div>
                    )}
                    <hr />
                </>
            )}


            {showDiagnosisPlanSection && (
                <>
                    <h4>Diagnóstico y Plan</h4>
                    {renderField("Diagnóstico Presuntivo Justificado", consultation.presumptive_diagnosis, true)}
                    {renderField("Diagnóstico Definitivo", consultation.definitive_diagnosis, true)}
                    {renderField("Plan Terapéutico", consultation.therapeutic_plan, true)}
                    {renderField("Pronóstico", consultation.prognosis, true)}
                    {renderField("Evolución", consultation.evolution_notes, true)}
                    <hr />
                </>
            )}

            {showObservationsSection && (
                <>
                    <h4>Observaciones Finales y Profesional</h4>
                    {renderField("Observaciones Generales / Anexos (descripción)", consultation.general_observations, true)}
                    {renderField("Confirmación/Firma Profesional", consultation.signature_confirmation)}
                    {/* {renderField("Veterinario Tratante ID", consultation.veterinarian_id || consultation.veterinary_access_id)} */}
                </>
            )}
        </article>
    );
} 
----- Archivo: index.ts ----- 
export { default as BasicDataForm } from './BasicDataForm';
export { default as PetNameForm } from './PetNameForm'; 
----- Archivo: BasicDataForm.tsx ----- 
// src/components/forms/BasicDataForm.tsx
import React, { useState, useEffect, Dispatch } from 'react';
import { InitialBasicDataType, PetStep as PetStep, PetType, type BasicDataType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import { Dates, Steps } from '@/utils/index';
import { petTypes, genders, weightUnits, breedOptions, foodOptions, weightConditionOptions, sizeOptions } from '@/data/petdata';
import { Empty } from '@/data/index';
import { useDeviceDetect } from '@/hooks/useDeviceDetect';
import { postFetch } from '@/app/api';
import StepsComponent from '../lib/steps';
import { useStorageContext } from '@/context/StorageProvider';

interface BasicDataFormProps {
  pet: PetType;
  basicData: BasicDataType;
  setBasicData: (basicData: BasicDataType) => void;
  onBack: () => void;
  onNext: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
}

export default function BasicDataForm({ pet, basicData, setBasicData, onNext, onBack, stepStates, setStepStates }: BasicDataFormProps) {
  const step = PetStep.BasicData;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  }
  const stateEq = (stepState: StepStateEnum) => {
    return stepStates.find(x => x.step == step)?.state == stepState;
  }
  const initials = (basicData: BasicDataType, fetch: boolean = false): InitialBasicDataType => {
    const initialPetType = petTypes.filter(t => t == basicData.pet_type).length > 0 || (basicData.pet_type == '' && !fetch) ? basicData.pet_type : 'Otro';
    const initialFood = foodOptions.find(t => t == basicData.main_food) != null || (basicData.main_food == '' && !fetch) ? basicData.main_food : 'Otro';
    const initialRace = (breedOptions[initialPetType] ?? []).filter(t => t == basicData.race).length > 0 || (basicData.race == '' && !fetch) ? basicData.race : 'Otro';
    const initialOtherPetType = initialPetType != 'Otro' && basicData.pet_type == 'Otro' ? '' : basicData.pet_type;
    const initialOtherFood = initialFood != 'Otro' && basicData.main_food == 'Otro' ? '' : basicData.main_food;
    const initialOtherRace = initialRace != 'Otro' && basicData.race == 'Otro' ? '' : basicData.race;
    return {
      petType: initialPetType,
      food: initialFood,
      race: initialRace,
      otherPetType: initialOtherPetType,
      otherFood: initialOtherFood,
      otherRace: initialOtherRace
    };
  };

  const initial = initials(basicData);
  const [formData, setFormData] = useState<Partial<BasicDataType>>({ ...basicData, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [weight, setWeight] = useState<number>(parseFloat(basicData.weight.split(' ')[0]) ?? 0);
  const [weightUnit, setWeightUnit] = useState<string>(basicData.weight.split(' ')[1]);
  const [otherPetType, setOtherPetType] = useState<string>(initial.otherPetType);
  const [otherFood, setOtherFood] = useState<string>(initial.otherFood);
  const [otherRace, setOtherRace] = useState<string>(initial.otherRace);
  const [loadedWithPreviusData, setLoadedWithPreviusData] = useState<boolean>(false);
  const [savedData, setSavedData] = useState<BasicDataType>(Empty.BasicData());
  const { isMobile, isDesktop, isTablet } = useDeviceDetect();
  const storage = useStorageContext();

  // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
  const sectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: isMobile
      ? "repeat(2, 1fr)"
      : "repeat(4, 1fr)"
  };
  // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
  const tabletSectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: "repeat(2, 1fr)"
  };



  useEffect(() => {
    if (JSON.stringify(savedData) != JSON.stringify(formData) && !stateEq(StepStateEnum.NotInitialize) && loadLoading == false) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData, otherPetType, otherFood, otherRace, weight, weightUnit]);

  useEffect(() => {
    const fetchData = async () => {
      setLoadLoading(true);
      if (stateEq(StepStateEnum.NotInitialize) && !basicData.pet_id)
        if (stateEq(StepStateEnum.NotInitialize)) {
          setState(StepStateEnum.Initialize);
          let basicDataSaved: BasicDataType = Empty.BasicData();
          if (!storage.storedBasicData.pet_id) {
            const petResponse = await fetch(`/api/pets/basic-data/${pet.id}`);
            if (!petResponse.ok) throw new Error("Falló fetch basic-data");
            const data = await petResponse.json() as BasicDataType;
            if (data) {
              basicDataSaved = data;
            }

          }
          else if (storage.storedBasicData.pet_id == pet.id) {
            basicDataSaved = storage.storedBasicData;
          }
          if (basicDataSaved.pet_id) {
            setSavedData(basicDataSaved);
            setBasicData(basicDataSaved);
            const initial = initials(basicDataSaved, loadedWithPreviusData);
            setLoadedWithPreviusData(true);
            setFormData({ ...basicDataSaved, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
            setWeight(parseFloat(basicDataSaved.weight.split(' ')[0]));
            setWeightUnit(basicDataSaved.weight.split(' ')[1]);
            setOtherPetType(initial.otherPetType);
            setOtherRace(initial.otherRace);
            setOtherFood(initial.otherFood);
          }
        }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet.id, formData]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(false);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        const finalFood = formData.main_food === 'Otro' ? otherFood.trim() : formData.main_food;
        const finalPetType = formData.pet_type === 'Otro' ? otherPetType.trim() : formData.pet_type;
        const finalRace = formData.race === 'Otro' ? otherRace.trim() : formData.race;
        const finalWeight = `${weight ?? 0} ${weightUnit}`;
        const dataToSave: BasicDataType = {
          ...(formData as BasicDataType),
          main_food: finalFood || '',
          weight: finalWeight || '0 Kg',
          pet_type: finalPetType || '',
          race: finalRace || '',
        };
        const basicDataResponse = await postFetch(`/api/pets/basic-data/${formData.pet_id}`, undefined, dataToSave);
        if (!basicDataResponse.ok) throw new ApiError("Error actualizado datos básicos de la mascota");
        setSavedData(dataToSave);
        setBasicData(dataToSave);
        if (dataToSave.pet_id == storage.storedBasicData.pet_id) {
          storage.setStoredBasicData(dataToSave);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
      setSubmitLoading(true);
    } finally {
      setSubmitLoading(true);
    }
  };

  return (
    <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={stepStates.length} error={error}>
      {/* Sección: Información básica */}
      <fieldset>
        <legend><b>Información básica</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="pet_type">Tipo de mascota</label>
            <select
              id="pet_type"
              className="w-full"
              value={formData.pet_type}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: 'Otro', race: '' });
                } else {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: val, race: '' });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona tipo</option>
              {petTypes.map(type => <option key={type} value={type}>{type}</option>)}
            </select>
            {formData.pet_type === 'Otro' && (
              <input
                value={otherPetType}
                type="text"
                placeholder="Especifica el tipo"
                className="w-full mt-2"
                disabled={loadLoading}
                onChange={e => setOtherPetType(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="gender">Género</label>
            <select
              id="gender"
              className="w-full"
              value={formData.gender}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, gender: e.target.value })}
              required
            >
              <option value="" disabled>Selecciona género</option>
              {genders.map(g => <option key={g} value={g}>{g}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="weight">Peso</label>
            <div className="flex gap-2">
              <input
                id="weight"
                type="number"
                pattern="^\d+(?:\.\d{1,2})?$"
                min="0"
                className="w-2/3"
                disabled={loadLoading}
                value={weight ?? 0}
                onChange={e => setWeight(parseFloat(e.target.value) ?? 0)}
                required
              />
              <select
                id="weight_unit"
                className="w-1/3"
                value={weightUnit}
                disabled={loadLoading}
                onChange={e => setWeightUnit(e.target.value)}
              >
                {weightUnits.map(u => <option key={u} value={u}>{u}</option>)}
              </select>
            </div>
          </div>
          <div>
            <label htmlFor="race">Raza</label>
            <select
              id="race"
              className="w-full"
              disabled={loadLoading || !formData.pet_type}
              value={formData.race}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: 'Otro' });
                } else {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: val });
                }
              }}
              required
            >
              <option value="" disabled>{formData.pet_type ? 'Selecciona raza' : 'Selecciona primero tipo'}</option>
              {formData.pet_type && breedOptions[formData.pet_type].map(r => <option key={r} value={r}>{r}</option>)}
            </select>
            {formData.race === 'Otro' && (
              <input
                value={otherRace}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la raza"
                className="w-full mt-2"
                onChange={e => setOtherRace(e.target.value)}
              />
            )}
          </div>
        </div>
      </fieldset>

      {/* Sección: Alimentación y entorno */}
      <fieldset>
        <legend><b>Alimentación y entorno</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="main_food">Comida principal</label>
            <select
              id="main_food"
              className="w-full"
              value={formData.main_food}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: 'Otro' });
                } else {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: val });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona comida</option>
              {foodOptions.map(food => <option key={food} value={food}>{food}</option>)}
            </select>
            {formData.main_food === 'Otro' && (
              <input
                value={otherFood}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la comida"
                className="w-full mt-2"
                onChange={e => setOtherFood(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="weight_condition">Condición de peso</label>
            <select
              id="weight_condition"
              className="w-full"
              value={formData.weight_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, weight_condition: e.target.value })}
            >
              <option value="" disabled>Selecciona condición</option>
              {weightConditionOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="size">Tamaño</label>
            <select
              id="size"
              className="w-full"
              value={formData.size}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, size: e.target.value })}
            >
              <option value="" disabled>Selecciona tamaño</option>
              {sizeOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
        </div>
        <div style={sectionGridStyle}>
          <div>
            <label className="flex items-center gap-2" htmlFor="lives_with_others">
              <input
                id="lives_with_others"
                type="checkbox"
                checked={formData.lives_with_others}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, lives_with_others: e.target.checked })}
              />
              Vive con otros
            </label>
          </div>
          <div>
            <label className="flex items-center gap-2" htmlFor="has_allergies">
              <input
                id="has_allergies"
                type="checkbox"
                checked={formData.has_allergies}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_allergies: e.target.checked })}
              />
              Alergias
            </label>
          </div>
        </div>
      </fieldset>

      {/* Sección: Vacunación y procedimientos */}
      <fieldset>
        <legend><b>Vacunación y procedimientos</b></legend>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          <div style={{ gridColumn: 'span 2' }}>
            <label className="flex items-center gap-2" htmlFor="has_vaccine">
              <input
                id="has_vaccine"
                type="checkbox"
                checked={formData.has_vaccine}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_vaccine: e.target.checked })}
              />
              Tiene vacunas
            </label>
          </div>
          {isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_castrated">
                  <input
                    id="is_castrated"
                    type="checkbox"
                    checked={formData.is_castrated}
                    onChange={e => setFormData({ ...formData, is_castrated: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Castrado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
        </div>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          {formData.has_vaccine && (
            <>
              <div>
                <label htmlFor="last_vaccine_name">Nombre última vacuna</label>
                <input
                  id="last_vaccine_name"
                  type="text"
                  className="w-full"
                  value={formData.last_vaccine_name}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_name: e.target.value })}
                />
              </div>
              <div>
                <label htmlFor="last_vaccine_date">Fecha última vacuna</label>
                <input
                  id="last_vaccine_date"
                  type="date"
                  className="w-full"
                  value={formData.last_vaccine_date ? Dates.format(formData.last_vaccine_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_date: e.target.valueAsDate || undefined })}
                />
              </div>
            </>
          )}
          {!formData.has_vaccine &&
            <>
              <div style={{ gridColumn: 'span 2' }}></div>
            </>}
          {!isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_castrated">
                  <input
                    id="is_castrated"
                    type="checkbox"
                    checked={formData.is_castrated}
                    onChange={e => setFormData({ ...formData, is_castrated: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Castrado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
          <div>
            {formData.is_castrated && (
              <div>
                <label htmlFor="castration_date">Fecha de castración</label>
                <input
                  id="castration_date"
                  type="date"
                  className="w-full"
                  value={formData.castration_date ? Dates.format(formData.castration_date) : ''}
                  onChange={e => setFormData({ ...formData, castration_date: e.target.valueAsDate || undefined })}
                  disabled={loadLoading}
                />
              </div>
            )}
          </div>
          <div>
            {formData.has_anti_flea && (
              <div>
                <label htmlFor="anti_flea_date">Fecha antipulgas</label>
                <input
                  id="anti_flea_date"
                  type="date"
                  className="w-full"
                  value={formData.anti_flea_date ? Dates.format(formData.anti_flea_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, anti_flea_date: e.target.valueAsDate || undefined })}
                />
              </div>
            )}
          </div>
        </div>
      </fieldset>

      {/* Sección: Otros datos */}
      <fieldset>
        <legend><b>Otros datos</b></legend>
        <div style={sectionGridStyle}>
          <label className="flex items-center gap-2" htmlFor="uses_medicine">
            <input
              id="uses_medicine"
              type="checkbox"
              checked={formData.uses_medicine}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, uses_medicine: e.target.checked })}
            />
            Usa medicina
          </label>
          <label className="flex items-center gap-2" htmlFor="special_condition">
            <input
              id="special_condition"
              type="checkbox"
              checked={formData.special_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, special_condition: e.target.checked })}
            />
            Condición especial
          </label>
        </div>
      </fieldset>
    </StepsComponent>
  );
} 
----- Archivo: PetNameForm.tsx ----- 
// src/components/forms/PetNameForm.tsx
import React, { Dispatch, useEffect, useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { FaCloudUploadAlt } from 'react-icons/fa';
import { generateUniquePetId } from '@/utils/random';
import { PetStep, PetType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import StepsComponent from '../lib/steps';
import { Steps } from '@/utils/index';
import { Empty } from '@/data/index';
import { CircularImage } from "@/components/index";
import { getFetch, postFetch } from '@/app/api';
import { useStorageContext } from '@/context/StorageProvider';

interface PetFormProps {
  ownerId: string;
  pet: PetType;
  setPet: (pet: PetType) => void;
  onNext: () => void;
  onBack: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
}

export default function PetNameForm({
  ownerId,
  pet,
  setPet,
  onNext,
  onBack,
  stepStates,
  setStepStates,
}: PetFormProps) {
  const step = PetStep.Name;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  };
  const stateEq = (stepState: StepStateEnum) =>
    stepStates.find((x) => x.step === step)?.state === stepState;

  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [savedData, setSavedData] = useState<PetType>(Empty.Pet());
  const [preview, setPreview] = useState<string>(pet.image || '/pets/pet.jpg');
  const storage = useStorageContext();

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result as string;
      setPet({ ...pet, image: base64 });
      setPreview(base64);
    };
    reader.readAsDataURL(file);
  }, [pet, setPet]);

  const { getRootProps, getInputProps, isDragActive, open } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    multiple: false,
    noClick: true,
    noKeyboard: true,
  });

  useEffect(() => {
    const fetchData = async () => {
      if (stateEq(StepStateEnum.NotInitialize) && !pet.id) {
        setState(StepStateEnum.Initialize);
      } else if (stateEq(StepStateEnum.NotInitialize)) {
        setState(StepStateEnum.Initialize);
        let petSaved: PetType = Empty.Pet();
        if (!storage.storedPet.id) {
          const response = await getFetch(`/api/pets/${pet.id}`);
          if (!response.ok) {
            throw new ApiError('Error al obtener la mascota');
          }
          petSaved = (await response.json())[0] as PetType;
        }
        else if (storage.storedPet.id == pet.id) {
          petSaved = storage.storedPet;
        }
        if (petSaved) {
          setPet(petSaved);
          setSavedData(petSaved);
          setPreview(petSaved.image || preview);
        }
      }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  useEffect(() => {
    if (
      JSON.stringify(savedData) !== JSON.stringify(pet) &&
      !stateEq(StepStateEnum.NotInitialize)
    ) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(true);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        const newId = pet.id || (await generateUniquePetId());
        const newPet: PetType = { id: newId, name: pet.name, image: pet.image, owner_id: ownerId };
        if (JSON.stringify(newPet) != JSON.stringify(pet)) {
          const response = await postFetch('/api/pets', undefined, newPet);
          const result = await response.json();
          if (!response.ok) {
            throw new ApiError('Error al guardar mascota');
          }
          const savedPet: PetType = result[0] as PetType;
          setSavedData(savedPet);
          if (newPet.id)
            storage.setStoredPet(savedPet);
          const pets = storage.storedOwnerPets.filter((p: PetType) => p.id != savedPet.id);
          storage.setStoredOwnerPets([...pets, savedPet]);
          setPet(savedPet);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
    } finally {
      setSubmitLoading(false);
    }
  };

  return (
    <StepsComponent
      onBack={onBack}
      onNext={handleSubmit}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      step={step}
      totalSteps={stepStates.length}
      error={error}
    >
      <div style={{ display: 'grid', gap: '1rem', marginBottom: '30px' }}>
        <label>
          Nombre
          <input
            type="text"
            value={pet.name}
            disabled={loadLoading}
            onChange={(e) => setPet({ ...pet, name: e.target.value })}
            required
          />
        </label>

        {pet.image ? (
          <CircularImage
            src={preview}
            width={200}
            getRootProps={getRootProps}
            getInputProps={getInputProps}
            onClick={open}
            overlayText="Cambiar foto"
            hoverEnabled={true}
          />
        ) : (
          <div
            {...getRootProps()}
            style={{
              border: `2px dashed ${isDragActive ? '#4285f4' : '#ccc'}`,
              borderRadius: '4px',
              padding: '1.5rem',
              backgroundColor: isDragActive ? '#e8f0fe' : '#f5f5f5',
              textAlign: 'center',
              cursor: 'pointer'
            }}
            onClick={open}
          >
            <input {...getInputProps()} />
            <FaCloudUploadAlt
              style={{ fontSize: '2rem', color: isDragActive ? '#4285f4' : '#888' }}
            />
            <p style={{ marginTop: '0.5rem', fontWeight: 'bold' }}>
              <b>Selecciona o</b> arrastra y suelta la foto aquí
            </p>
          </div>
        )}
      </div>
    </StepsComponent>
  );
}
 
----- Archivo: SideBar.tsx ----- 
// app/components/layout/SideBar.tsx
"use client";
import React, { useEffect, useState } from "react";
import {
    FaBars,
    FaCalendar,
    FaCloudSun,
    FaCog,
    FaCut,
    FaFlask,
    FaHome,
    FaPills,
    FaPowerOff,
    FaRocket,
    FaSyringe,
    FaUser
} from "react-icons/fa";
import Link from 'next/link';
import Image from 'next/image';
import { MenuType } from "@/types/lib";
import { v4 } from 'uuid';
import { useRouter } from "next/navigation";
import { FaPencil, FaUserDoctor } from "react-icons/fa6";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { handleLogout } from "@/services/authService";
import { useSessionContext } from "@/context/SessionProvider";
import { useRoleContext } from "@/context/RoleProvider";

export default function SideBar() {
    const { isMobile, isTablet, isDesktop } = useDeviceDetect();
    const { db: session } = useSessionContext();
    const storage = useStorageContext();
    const [menuItems, setMenuItems] = useState<MenuType[]>([]);
    const router = useRouter();
    const { setShowEditPetModal } = useUI();
    const { isOwner, isVet } = useRoleContext();

    const menuData = (show: boolean): MenuType[] => [
        { label: "Inicio", icon: <FaHome />, url: "/", show: isOwner },
        { label: "Calendario", icon: <FaCalendar />, url: "/", show: show },
        { label: "Datos básicos", icon: <FaUser />, url: "/pages/pet/basic-data", show },
        { label: "Vacunas", icon: <FaSyringe />, url: "/pages/pet/vaccines", show },
        { label: "Cirugías", icon: <FaCut />, url: "/pages/pet/surgeries", show },
        { label: "Medicinas", icon: <FaPills />, url: "/pages/pet/medicines", show },
        { label: "Condiciones especiales", icon: <FaCloudSun />, url: "/pages/pet/conditions", show },
        { label: "Lab. de exámenes", icon: <FaFlask />, url: "/pages/pet/lab-tests", show },
        { label: "Consultas veterinarias", icon: <FaUserDoctor />, url: `/pages/pet/consultations/${storage.storedPet.id}`, show },
        { label: "Mejora tu plan", icon: <FaRocket />, url: "/pages/owner/upgrade", show: isOwner },
        { label: "Configuraciones", icon: <FaCog />, url: "/pages/owner/settings", show: isOwner },
        { label: 'Editar Mascota', icon: <FaPencil />, url: "", showModal: setShowEditPetModal, show: isOwner && show },
        { label: "Agregar Consulta", icon: <FaCog />, url: `/pages/vet/consultation/${storage.storedPet.id}`, show: isVet && show },
    ];
    useEffect(() => {
        const menu = menuData(storage.storedPet.id != "");
        setMenuItems(menu);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedPet, storage.storedOwnerPets, session, storage.storedVetAccess, setShowEditPetModal]);

    const goToLogin = () => {
        storage.setStoredVetAccess(Empty.VetAccess());
        router.push("/login");
    }

    if (menuItems.filter(m => m.show).length == 0) {
        return <></>;
    }

    function item({ label, icon, url, show, showModal }: MenuType) {
        if (!show) {
            return <div key={v4()}></div>;
        }
        else if (showModal) {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <a onClick={() => showModal(true)} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </a>
                </li>
            );
        }
        else {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <Link href={url} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </Link>
                </li>
            );
        }
    }

    return (
        <>
            {/* Desktop Sidebar */}
            {isDesktop && (
                <aside
                    style={{
                        width: "300px",
                        display: "flex",
                        flexDirection: "column",
                        paddingTop: "1rem",
                        backgroundColor: "#ffffff",
                        boxShadow: "0 4px 12px rgba(0,0,0,0.05)",
                    }}
                >
                    <div style={{ padding: "0 1rem 1rem", display: 'flex', alignItems: 'center' }}>
                        <CircularImage
                            src={storage.storedPet.image || "/pets/pet.jpg"}
                            width={80}
                        />
                        <p style={{ marginLeft: '20px' }}>
                            <b>{storage.storedPet.name ?? 'Nombre de tu mascota'}</b>
                        </p>
                    </div>
                    <nav style={{ padding: "0 1rem" }}>
                        <ul>
                            {menuItems.map(item)}
                            {session && <li><a style={{ background: "none", border: "none", color: '#d32f2f' }} onClick={() => handleLogout(storage, router)}> <FaPowerOff style={{ marginRight: '1rem' }} />Cerrar sesión</a></li>}
                            {!session && <li><button onClick={goToLogin}>Iniciar sesión</button></li>}
                        </ul>
                    </nav>
                    <div style={{ display: "flow", justifyContent: "space-around", marginTop: "1rem" }}>
                        <Image src="/others/play-store.png" alt="Google Play" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                        <br /><br />
                        <Image src="/others/app-store.png" alt="App Store" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                    </div>
                </aside>
            )}

            {/* Mobile Sidebar */}
            {(isMobile || isTablet) && (
                <aside
                    style={{
                        position: "fixed",
                        top: 0,
                        bottom: 0,
                        left: 0,
                        width: "64px",
                        backgroundColor: "#ffffff",
                        boxShadow: "2px 0 8px rgba(0,0,0,0.05)",
                        zIndex: 1000,
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        paddingTop: "1rem",
                        gap: "1rem"
                    }}
                >
                    {/* Foto y nombre */}
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>
                        <CircularImage src={storage.storedPet.image || "/pets/pet.jpg"} width={50} borderSize="2px" />
                        <span style={{ fontSize: "1rem", textAlign: "center", padding: "0 4px" }}><b>{storage.storedPet.name}</b></span>
                    </div>

                    {/* Íconos con tooltip */}
                    {menuItems.filter(m => m.show).map(({ label, icon, url, showModal }) => {
                        const content = (
                            <div className="tooltip-container" style={{ fontSize: "1.75rem", cursor: "pointer" }}>
                                {icon}
                                <span className="tooltip-text tooltip-right">{label}</span>
                            </div>
                        );

                        if (showModal) {
                            return (
                                <button
                                    key={label}
                                    onClick={() => showModal(true)}
                                    style={{ background: "none", border: "none", color: '#02659a', padding: '0' }}
                                >
                                    {content}
                                </button>
                            );
                        } else {
                            return (
                                <Link
                                    key={label}
                                    href={url}
                                    style={{ display: "flex", justifyContent: "center", alignItems: "center", color: '#02659a' }}
                                >
                                    {content}
                                </Link>
                            );
                        }
                    })}

                    {/* Logout/Login */}
                    <div style={{ position: 'fixed', bottom: "0", marginBottom: "1rem" }}>
                        <div className="tooltip-container" style={{ cursor: "pointer" }}>
                            <button
                                onClick={session ? () => handleLogout(storage, router) : goToLogin}
                                style={{ background: "none", border: "none", fontSize: "1.75rem", color: '#d32f2f' }}
                            >
                                {session ? <FaPowerOff /> : <FaBars />}
                            </button>
                            <span className="tooltip-text tooltip-right">{session ? "Cerrar sesión" : "Iniciar sesión"}</span>
                        </div>
                    </div>
                </aside>
            )}
        </>
    );
}
 
----- Archivo: addItem.tsx ----- 
// src/components/lib/addItem.tsx

import { tooltipStyles } from "@/styles/tooltip";
import { FaInfoCircle } from "react-icons/fa";
interface AddItemProps {
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
    count: number;
}

export default function AddItemComponent({ entityName, loadLoading, handleAdd, count }: AddItemProps) {
    return (
        <>
            <style jsx global>{`
        ${tooltipStyles}

        /* Override específico para tooltip de advertencia */
        .tooltip-container.tooltip-warning .tooltip-text {
          background-color: #fff3cd !important;  /* amarillo pálido */
          color: #856404 !important;            /* texto oscuro */
          border-color: #ffeeba !important;      /* borde amarillo */

          /* Posicionar a la derecha del icono */
          top: 50%;
          left: 120%;
          right: auto;
          bottom: auto;
          transform: translateY(-50%);   
          
        }
        .tooltip-container>svg {    
            font-size: 33px;
            color: #856404;
            margin-left: 10px;
        }
      `}</style>
            <div className="flex items-center flex-wrap gap-2">
                <button
                    type="button"
                    onClick={handleAdd}
                    className="contrast"
                    disabled={loadLoading}
                >
                    Agregar {count == 0 ? '' : 'otra '} {entityName}
                </button>

                {count === 0 && (
                    <span className="tooltip-container tooltip-warning">
                        <FaInfoCircle className="ml-1 text-yellow-600" />
                        <span className="tooltip-text">
                            Puedes añadir estos datos más tarde
                        </span>
                    </span>
                )}
            </div>
        </>
    );
} 
----- Archivo: basicField.tsx ----- 
// src/components/lib/basicField.tsx
import { FieldType } from "@/types/lib";

interface BasicFieldProps {
    item: FieldType
}

export default function BasicFieldComponent(props: BasicFieldProps) {
    if (!props.item.show) {
        return <div></div>;
    }
    return (
        <div key={props.item.label} style={{ backgroundColor: "#ffffff", padding: "1rem", borderRadius: "0.5rem", boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
            <p style={{ fontSize: "0.75rem", color: "#6B7280", margin: 0 }}>{props.item.label}</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}>{props.item.value}</p>
        </div>
    );
}
 
----- Archivo: circularImage.tsx ----- 
// src/components/lib/circularImage.tsx
import React, { useState } from 'react';
import Image from 'next/image';

// Componente reutilizable para avatar circular
interface CircularImageProps {
    src: string;
    width: number;
    borderSize?: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getRootProps?: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInputProps?: any;
    onClick?: () => void;
    overlayText?: string;
    hoverEnabled?: boolean;
}

export default function CircularImageComponent({ src, width, borderSize = '5px', getRootProps, getInputProps, onClick, overlayText, hoverEnabled = false }: CircularImageProps) {
    const [hover, setHover] = useState(false);
    if (!hoverEnabled) {
        return (
            <div style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: `${borderSize} solid #02659a`,
                cursor: 'pointer'
            }}
            >
                <Image
                    loading={"lazy"}
                    src={src}
                    alt="Foto de la mascota" fill
                    style={{ objectFit: 'cover' }} />
            </div>
        );
    }
    return (
        <div
            {...getRootProps()}
            onClick={onClick}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: '5px solid #02659a',
                cursor: 'pointer'
            }}
        >
            <input {...getInputProps()} />
            <Image
                loading={"lazy"}
                src={src}
                alt="Foto de la mascota" fill
                style={{ objectFit: 'cover' }} />
            {hover && overlayText && (
                <div
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'rgba(255,255,255,0.6)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        borderRadius: '50%'
                    }}
                >
                    <span style={{ fontWeight: 'bold', color: '#333', textAlign: 'center' }}>
                        {overlayText}
                    </span>
                </div>
            )}
        </div>
    );
} 
----- Archivo: dataNotFound.tsx ----- 
// src/components/DataNotFound.tsx
import React from "react";
import { FaInbox } from "react-icons/fa";

interface DataNotFoundProps {
  message: string;
}

export default function DataNotFoundComponent({ message }: DataNotFoundProps) {
  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: "2rem",
        backgroundColor: "#F3F4F6",
        borderRadius: "0.5rem",
        color: "#6B7280",
        textAlign: "center",
        maxWidth: "400px",
        margin: "2rem auto",
        boxShadow: "0 2px 8px rgba(0,0,0,0.05)",
      }}
    >
      <FaInbox
        size={48}
        style={{ marginBottom: "1rem", color: "#D1D5DB" }}
      />
      <p style={{ fontSize: "1.25rem", lineHeight: "1.5" }}>
        {message}
      </p>
    </div>
  );
}
 
----- Archivo: display.tsx ----- 
// src/components/lib/display.tsx
import { FieldType, FormType as DisplayType } from "@/types/lib";
import { Field } from "@/components/index";
import { v4 } from "uuid";

interface DisplayProps {
    formItems: DisplayType[];
    isMobile: boolean;
}

export default function DisplayComponent(props: DisplayProps) {
    return (
        <div style={{ display: "grid", gridTemplateColumns: props.isMobile ? "1fr" : "repeat(2, 1fr)", gap: "1rem" }}>
            {props.formItems.map((item) => (
                <div key={item.id} style={{ backgroundColor: "transparent", padding: "0.1rem", borderRadius: "0.5rem", borderColor: '#000', borderWidth: '1px', border: 'groove', boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
                    {item.fields.map((field: FieldType) =>
                        <Field key={v4()} field={field} />
                    )}
                </div>
            ))}
        </div>
    );
} 
----- Archivo: entities.tsx ----- 
// src/components/entities.tsx
"use client";

import React from "react";
import { AddItem, Entity } from "@/components/index";

interface EntitiesProps {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    form: (item: any, id: number) => React.JSX.Element;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    entityList: any[];
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
}
export default function EntitiesComponent({ form, entityList, entityName, loadLoading, handleAdd }: EntitiesProps) {

    return (
        <div className="grid grid-cols-1 gap-6" style={{ display: 'flow' }}>
            {entityList.map((item, i: number) => (
                <Entity key={i.toString()} index={i} entityName={entityName} >
                    {form(item, i)}
                </Entity>
            ))}

            <AddItem entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} count={entityList.length} />
        </div>
    );
}
 
----- Archivo: entity.tsx ----- 
// src/components/lib/entity.tsx
"use client";

import { Strings } from "@/utils/index";
import React from "react";

interface EntityProps {
    key: string;
    children: React.ReactNode;
    entityName: string;
    index: number;
}

export default function EntityComponent({ children, index, entityName }: EntityProps) {
    

    return (
        <fieldset
            key={index}
            className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 border rounded"
            style={{ display: 'flex', border: '1px solid #02659a', borderRadius: '10px', padding: '1rem' }} >
            <legend className="text-lg font-semibold" >
                <b style={{paddingLeft: '1rem', paddingRight: '1rem'}}>{Strings.titleCase(entityName)} #{index + 1}</b>
            </legend>
            {children}
        </fieldset>
    );
}
 
----- Archivo: entityFields.tsx ----- 
// src/components/lib/entityFields.tsx
"use client";

import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { FieldConfig } from "@/types/lib";
import { Dates } from "@/utils/index";
import React from "react";
import RemoveItemComponent from "./removeItem";


interface EntityFieldsProps<T extends { id: string | undefined }> {
    fieldsConfig: FieldConfig<T>[];
    item: T;
    index: number;
    loadLoading: boolean;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateItem: (index: number, field: keyof T, value: any) => void;
    handleRemove: (id: string | undefined) => void;
}

export default function EntityFieldsComponent<T extends { id: string | undefined }>({
    fieldsConfig,
    item,
    index,
    loadLoading,
    updateItem,
    handleRemove
}: EntityFieldsProps<T>) {

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const setValue = (type: 'text' | 'date', item: any, name: string | number | symbol): string | number | readonly string[] | undefined => {
        if (type == 'date') {
            return item[name] ? Dates.format(item[name]) : ''
        }
        return item[name] ?? "";
    }

    const { isMobile } = useDeviceDetect();

    const gridTemplateColumnsCalculateDesktopOrTablet = (count: number) => {
        switch (count) {
            case 5: return "repeat(3, 1fr)";
            case 4: return "repeat(3, 1fr)";
            case 3: return "repeat(4, 1fr)";
            case 2:
            default: return "repeat(3, 1fr)";
        }
    }

    // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
    const sectionGridStyle: React.CSSProperties = {
        display: "grid",
        gap: "1rem",
        gridTemplateColumns: isMobile
            ? "repeat(2, 1fr)"
            : gridTemplateColumnsCalculateDesktopOrTablet(fieldsConfig.length)
    };

    return (
        <div style={sectionGridStyle}>
            {fieldsConfig.map(({ label, name, type, mandatory, className }) => (
                <label key={`${String(name)}-${index}`} className={className}>
                    {label}
                    <input
                        type={type}
                        value={setValue(type, item, name)}
                        disabled={loadLoading}
                        onChange={(e) =>
                            updateItem(
                                index,
                                name,
                                type === "date"
                                    ? (e.target as HTMLInputElement).valueAsDate
                                    : (e.target as HTMLInputElement).value
                            )
                        }
                        required={mandatory}
                        className="w-full"
                    />
                </label>
            ))}
            <RemoveItemComponent id={item.id} loadLoading={loadLoading} handleRemove={handleRemove} />
        </div>
    );
}
 
----- Archivo: entityForm.tsx ----- 
// src/components/entityForm.tsx
"use client";

import React from "react";
import type { Dispatch, SetStateAction } from "react";
import { EntityFields, Form } from "@/components/index";
import { useLoadEntities } from "@/hooks/useLoadEntities";
import { useEntityList } from "@/hooks/useEntityList";
import { useEntitySubmit } from "@/hooks/useEntitySubmit";
import type { FieldConfig, StepsStateType } from "@/types/lib";

export interface EntityFormProps<T extends { id?: string }> {
  id: string;
  storedList: T[];
  setStoredList: (list: T[] | null) => void;
  data: T[];
  setData: Dispatch<SetStateAction<T[]>>;
  step: number;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<SetStateAction<StepsStateType[]>>;
  entityName: string;
  emptyFactory: (id: string) => Partial<T>;
  fieldsConfig: FieldConfig<T>[];
  onNext: () => void;
  onBack: () => void;
}

export default function EntityFormComponent<T extends { id: string | undefined }>({
  id,
  storedList,
  setStoredList,
  data,
  setData,
  step,
  stepStates,
  setStepStates,
  entityName,
  emptyFactory,
  fieldsConfig,
  onNext,
  onBack,
}: EntityFormProps<T>) {
  // 1) Carga los datos guardados
  const {
    list,
    setList,
    error: loadError,
    setError: setLoadError,
    loading: loadLoading,
  } = useLoadEntities<T>(
    id,
    entityName,
    storedList,
    setStoredList,
    data,
    setData,
    step,
    stepStates,
    setStepStates
  );

  // 2) Gestión de la lista en memoria (añadir, eliminar, editar)
  const { addItem, removeItem, updateItem } = useEntityList<T>(
    emptyFactory,
    id,
    setList,
    setLoadError,
    step,
    stepStates
  );

  // 3) Envío y validación
  const {
    submit,
    loading: submitLoading,
    error: submitError,
  } = useEntitySubmit<T>(
    id,
    list,
    entityName,
    setStoredList,
    setData,
    fieldsConfig,
    step,
    stepStates,
    setStepStates,
    loadError,
    setLoadError
  );

  // 4) Renderizado de campos dinámicos
  const renderFields = (item: T, index: number) => (
    <EntityFields<T>
      fieldsConfig={fieldsConfig}
      item={item}
      index={index}
      loadLoading={loadLoading}
      updateItem={updateItem}
      handleRemove={removeItem}
    />
  );

  return (
    <Form<T>
      entityList={list}
      step={step}
      totalSteps={stepStates.length}
      entityName={entityName}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      error={loadError || submitError}
      form={renderFields}
      onBack={onBack}
      handleAdd={addItem}
      handleSubmit={() => submit(onNext)}
    />
  );
}
 
----- Archivo: field.tsx ----- 
// src/components/lib/field.tsx
import { FieldType } from "@/types/lib";
import React from "react";

interface FieldsProps {
    field: FieldType;
} 

export default function FieldComponent(props: FieldsProps) {
    if (!props.field.show) {
        return <div></div>;
    }
    return (
        <div key={props.field.label} style={{ backgroundColor: "#fff", padding: "1rem", margin: '0.5rem', borderRadius: "0.5rem", boxShadow: "0 2px 8px rgba(0,0,0,0.05)" }}>
            <p style={{ fontSize: "0.75rem", color: "#6B7280", margin: 0 }}>{props.field.label}:</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}> {props.field.value}</p>
        </div>
    );
} 
----- Archivo: form.tsx ----- 
// src/components/form.tsx
"use client";
import React from "react";
import StepsComponent from "./steps";
import EntitiesComponent from "@/components/lib/entities";

interface FormProps<T extends { id: string | undefined }> {
    entityList: Partial<T>[];
    step: number;
    totalSteps: number;
    entityName: string;
    submitLoading: boolean;
    loadLoading: boolean;
    error: string | null;
    form: (entity: T , i: number) => React.JSX.Element
    onBack: () => void;
    handleAdd: () => void;
    handleSubmit: () => Promise<void>;
}

export default function FormComponent<T extends { id: string | undefined }>({ entityList, step, totalSteps, entityName, submitLoading, loadLoading, error, form, onBack, handleAdd, handleSubmit }: FormProps<T> ) {
    return (
        <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={totalSteps} error={error} >
            <EntitiesComponent form={form} entityList={entityList} entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} />
        </StepsComponent >
    );
}
 
----- Archivo: loading.tsx ----- 
import React from "react";
import { FaSpinner } from "react-icons/fa";

export default function LoadingComponent() {
  return (
    <div className="loading-container">
      <FaSpinner
        size={48}
        style={{
          color: "#3b82f6",
          marginBottom: "1rem",
          animation: "spin 1s linear infinite"
        }}
      />
      <p>Cargando...</p>
      <style jsx>{`
        .loading-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          padding: 2rem;
          color: #6b7280;
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to   { transform: rotate(360deg); }
        }
        p {
          font-size: 1rem;
        }
      `}</style>
    </div>
  );
}
 
----- Archivo: modal.tsx ----- 
// app/components/lib/modal.tsx
"use client";
import React, { Dispatch, SetStateAction } from "react";
import { FaTimes } from "react-icons/fa";

interface ModalProps {
    children: React.ReactNode;
    title: string;
    description?: string;
    setShowModal: Dispatch<SetStateAction<boolean>>;
    maxWidth?: string;
    dropdownRef?: React.RefObject<HTMLDivElement | null>;
}

export default function ModalComponent({ children, title, description, setShowModal, maxWidth = "450px", dropdownRef }: ModalProps) {
    return (
        <div
            style={{
                position: "fixed",
                inset: 0,
                backgroundColor: "rgba(0,0,0,0.5)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 2000,
            }}
        >

            <div
                ref={dropdownRef}
                style={{
                    backgroundColor: "#fff",
                    borderRadius: "1rem",
                    padding: "2rem",
                    width: "90%",
                    maxWidth: maxWidth,
                    position: "relative",
                }}
            >

                    {/* Close button */}
                    <button
                        onClick={() => setShowModal(false)}
                        style={{
                            position: "absolute",
                            top: "0.5rem",
                            right: "0.5rem",
                            background: "none",
                            border: "none",
                            fontSize: "1rem",
                            cursor: "pointer",
                            color: '#000'
                        }}
                        aria-label="Cerrar modal"
                    >
                        <FaTimes />
                    </button>
                    <h2 className="modal-title">{title}</h2>
                    <p className="description">{description}</p>
                    {children}
                </div>
        </div >
    );
}
 
----- Archivo: page.tsx ----- 
// src/components/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { v4 } from "uuid";
import { Loading, DataNotFound, Display, Title } from "@/components/index";
import { ApiError, FormType } from "@/types/lib";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useSession } from "@/hooks/useSession";
import { getFetch } from "@/app/api";

export interface PageProps<T> {
    parentId: string,
    title: string;
    icon: React.JSX.Element;
    apiUrl: string;
    storedList: T[];
    setStoredList: (value: T[]) => void;
    /** Mapea cada ítem a un array de campos para Display */
    mapItemToFields: (item: T) => { label: string; show: boolean; value: string }[];
    emptyMessage: string;
}

const PageComponent = <T,>({
    parentId,
    title,
    icon,
    apiUrl,
    storedList,
    setStoredList,
    mapItemToFields,
    emptyMessage,
}: PageProps<T>) => {
    useSession();
    const { isMobile } = useDeviceDetect();
    const [items, setItems] = useState<T[] | null>(null);

    useEffect(() => {
        if (!parentId) return;
        const fetchData = async () => {
            try {
                let data: T[] = [];
                if (storedList == null) {
                    const response = await getFetch(`${apiUrl}${parentId}`);
                    if (!response.ok) throw new ApiError(`Error llamando al api: ${apiUrl}${parentId}`);
                    const data = await response.json();
                    setItems(data);
                    setStoredList(data);
                }
                else {
                    data = storedList;
                    setItems(data);
                }
            } catch (err) {
                console.error(`Error cargando ${title.toLowerCase()}:`, err);
            }
        };
        fetchData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storedList]);

    const formItems: FormType[] = (items || []).map((item) => ({
        id: v4(),
        fields: mapItemToFields(item),
    }));

    return (
        <main style={{ padding: isMobile ? "2rem 1rem" : "2rem" }}>
            <Title icon={icon} title={title} />
            {items === null ? (
                <Loading />
            ) : items.length === 0 ? (
                <DataNotFound message={emptyMessage} />
            ) : (
                <Display formItems={formItems} isMobile={isMobile} />
            )}
        </main>
    );
};

export default PageComponent;
 
----- Archivo: removeItem.tsx ----- 
// app/components/lib/removeItem.tsx
import { FaTrash } from "react-icons/fa";

interface RemoveItemProps {
    id: string | undefined;
    loadLoading: boolean;
    handleRemove: (id: string | undefined) => void;
}

export default function RemoveItemComponent({ id, loadLoading, handleRemove }: RemoveItemProps) {
    return (
        <div className="flex flex-wrap gap-2" style={{ marginTop: '26px', alignContent: 'center' }}>
            <button
                type="button"
                onClick={() => handleRemove(id)}
                className="contrast"
                disabled={loadLoading}
            >
                <FaTrash />
            </button>
        </div>
    );
} 
----- Archivo: steps.tsx ----- 
// src/components/lib/steps.tsx
import React from 'react';

interface StepsProps {
  children: React.ReactNode;
  step: number;
  totalSteps: number;
  submitLoading: boolean;
  loadLoading: boolean;
  error: string | null;
  onNext: () => void;
  onBack: () => void;
}

export default function StepsComponent({ children, submitLoading, loadLoading, step, totalSteps, error, onNext, onBack }: StepsProps) {

  return (
    <>
      <div className="space-y-4">
        <div style={{ maxHeight: '500px', overflowY: 'auto', padding: '1rem', marginBottom: '1rem' }}>
          {children}
        </div>
        {error && (
          <p className="text-error">
            {error}
          </p>
        )}
        <div className="mt-4 flex justify-between">
          {step > 0 && (
            <button
              type="button"
              onClick={onBack}
              className="btn-secondary ml-auto"
              style={{ float: 'left' }}
            >
              Atrás
            </button>
          )}
          <button
            type="button"
            onClick={onNext}
            disabled={submitLoading || loadLoading}
            className="btn-primary"
            style={{ float: 'right' }}
          >
            {submitLoading ? "Guardando…" : (totalSteps - 1 == step ? "Finalizar" : "Siguiente")}
          </button>
        </div>
      </div>
    </>
  );
}
 
----- Archivo: title.tsx ----- 
// src/components/lib/title.tsx
interface TitleProps {
    icon: React.JSX.Element;
    title: string;
}

export default function TitleComponent(props: TitleProps) {
    return (
        <h3 style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            {props.icon} {props.title}
        </h3>
    );
} 
----- Archivo: AddPetModal.tsx ----- 
// src/components/modals/AddPetModal.tsx
"use client";

import React, { useState, Dispatch, SetStateAction, useEffect } from "react";
import ModalComponent from "../lib/modal";
import { EntityForm } from "@/components/index";

import { PetNameForm, BasicDataForm } from "@/components/forms";

import {
    emptyVaccine,
    emptyMedicine,
    emptyLabTest,
    emptyCondition,
    emptySurgery,
} from "@/utils/factories";

import {
    PetStep,
    PetType,
    BasicDataType,
    VaccineDataType,
    MedicineDataType,
    LabTestDataType,
    ConditionDataType,
    SurgeryDataType
} from "@/types/index";

import type { StepsStateType, StepConfig } from "@/types/lib";
import { Empty } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";

interface AddPetModalProps {
    editPet?: PetType
}

export default function AddPetModal({ editPet }: AddPetModalProps) {
    const session = useSessionContext();
    const storage = useStorageContext();
    const [step, setStep] = useState<PetStep>(PetStep.Name);
    const { showAddPetModal, setShowAddPetModal, setShowEditPetModal } = useUI();

    // Estados por entidad
    const [pet, setPet] = useState<PetType>(editPet == undefined ? Empty.Pet() : editPet);
    const [basicData, setBasicData] = useState<BasicDataType>(Empty.BasicData());
    const [vaccinesData, setVaccinesData] = useState<VaccineDataType[]>([]);
    const [medicinesData, setMedicinesData] = useState<MedicineDataType[]>([]);
    const [labTestsData, setLabTestsData] = useState<LabTestDataType[]>([]);
    const [conditionsData, setConditionsData] = useState<ConditionDataType[]>([]);
    const [surgeriesData, setSurgeriesData] = useState<SurgeryDataType[]>([]);
    const [stepStates, setStepStates] = useState<StepsStateType[]>(Empty.Steps());


    useEffect(() => {
        setStepStates(Empty.Steps());
    }, [showAddPetModal])

    // Validar sesión
    if (!session?.db?.user?.id) return null;
    const ownerId = session.db.user.id;

    const totalSteps = 7;
    const next = () => setStep(s => Math.min(s + 1, totalSteps - 1));
    const back = () => setStep(s => Math.max(s - 1, 0));
    const finalize = () => {
        if (!pet.id) return;
        pet.owner_id = ownerId;
        storage.setStoredOwnerPets([...(storage.storedOwnerPets ?? []), pet]);
        setShowAddPetModal(false);
        setShowEditPetModal(false);
        setStepStates(Empty.Steps());
    };

    // Configuración dinámica para los pasos que usan EntityForm
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const stepConfigs: Partial<Record<PetStep, StepConfig<any>>> = {
        [PetStep.Vaccines]: {
            entityName: "vacuna",
            storedList: storage.storedVaccineData,
            setStoredList: storage.setStoredVaccineData,
            emptyFactory: emptyVaccine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Lote *", name: "batch", type: "text", mandatory: true, className: "w-full" },
                { label: "Marca *", name: "brand", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Medicines]: {
            entityName: "medicina",
            storedList: storage.storedMedicineData,
            setStoredList: storage.setStoredMedicineData,
            emptyFactory: emptyMedicine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Dosis *", name: "dosage", type: "text", mandatory: true, className: "w-full" },
                { label: "Frecuencia *", name: "frequency", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.LabTests]: {
            entityName: "prueba",
            storedList: storage.storedLabTestData,
            setStoredList: storage.setStoredLabTestData,
            emptyFactory: emptyLabTest,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Tipo *", name: "type", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Resultado", name: "result", type: "text", className: "w-full" },
            ],
        },
        [PetStep.Conditions]: {
            entityName: "condición",
            storedList: storage.storedConditionData,
            setStoredList: storage.setStoredConditionData,
            emptyFactory: emptyCondition,
            fieldsConfig: [
                { label: "Condición *", name: "condition", type: "text", mandatory: true, className: "w-full" },
                { label: "Severidad *", name: "severity", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Surgeries]: {
            entityName: "cirugía",
            storedList: storage.storedSurgeryData,
            setStoredList: storage.setStoredSurgeryData,
            emptyFactory: emptySurgery,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
            ],
        },
    };

    // Mapeo de datos y setters por paso
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dataMap: Partial<Record<PetStep, [any[], Dispatch<SetStateAction<any[]>>]>> = {
        [PetStep.Vaccines]: [vaccinesData, setVaccinesData],
        [PetStep.Medicines]: [medicinesData, setMedicinesData],
        [PetStep.LabTests]: [labTestsData, setLabTestsData],
        [PetStep.Conditions]: [conditionsData, setConditionsData],
        [PetStep.Surgeries]: [surgeriesData, setSurgeriesData],
    };

    const renderStep = () => {
        switch (step) {
            case PetStep.Name:
                return (
                    <PetNameForm
                        ownerId={ownerId}
                        pet={pet}
                        setPet={setPet}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                    />
                );

            case PetStep.BasicData:
                return (
                    <BasicDataForm
                        pet={pet}
                        basicData={basicData}
                        setBasicData={setBasicData}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                    />
                );

            default: {
                // TS: usamos Partial y ! para asegurar que cfg y data existen
                const cfg = stepConfigs[step]!;
                const [items, setItems] = dataMap[step]!;

                return (
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    <EntityForm<any>
                        key={step}
                        id={pet.id!}
                        storedList={cfg.storedList}
                        setStoredList={cfg.setStoredList}
                        data={items}
                        setData={setItems}
                        step={step}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                        entityName={cfg.entityName}
                        emptyFactory={cfg.emptyFactory}
                        fieldsConfig={cfg.fieldsConfig}
                        onNext={step === PetStep.Surgeries ? finalize : next}
                        onBack={back}
                    />
                );
            }
        }
    };

    const stepTitle = () => {
        const titles: Record<PetStep, string> = {
            [PetStep.Name]: "Agrega tu mascota",
            [PetStep.BasicData]: `Datos básicos de ${pet.name}`,
            [PetStep.Vaccines]: `Información de vacunas de ${pet.name}`,
            [PetStep.Medicines]: `Información de medicamentos de ${pet.name}`,
            [PetStep.LabTests]: `Información de exámenes de ${pet.name}`,
            [PetStep.Conditions]: `Información de condiciones especiales de ${pet.name}`,
            [PetStep.Surgeries]: `Información de cirugías de ${pet.name}`,
        };
        return titles[step] || "";
    };

    return (
        <ModalComponent title={stepTitle()} setShowModal={editPet == undefined ? setShowAddPetModal : setShowEditPetModal} maxWidth="1000px">
            {renderStep()}
        </ModalComponent>
    );
}
 
----- Archivo: Bubbles.tsx ----- 
// app/components/modals/Bubbles.tsx
"use client"
import React, { useEffect, useState } from "react";
import { FaShareAlt, FaCommentDots, FaUserMd, FaExchangeAlt } from "react-icons/fa";
import FeedbackModal from "./FeedbackModal";
import PetCodeModal from "./PetCodeModal";
import VeterinaryModal from "./VeterinaryModal";
import ChangePetModal from "./ChangePetModal";
import AddPetModal from "./AddPetModal";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useRoleContext } from "@/context/RoleProvider";
import VeterinarianPetCodeModal from "./VeterinarianPetCodeModal";

const bubbleStyleBase: React.CSSProperties = {
  backgroundColor: "#ffffff",
  border: "1px solid rgb(1, 114, 173)",
  borderRadius: "50%",
  width: "3rem",
  height: "3rem",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  color: "rgb(1, 114, 173)",
  fontSize: "1.25rem",
  cursor: "pointer",
};

export default function Bubbles() {

  const [showChangePetBubble, setShowChangePetBubble] = useState(false);
  const { isOwner, isVet } = useRoleContext();

  const storage = useStorageContext();

  const { setShowFeedbackModal,
    showFeedbackModal,
    setShowVetModal,
    showVetModal,
    setShowCodeModal,
    showCodeModal,
    setShowChangePetModal,
    showChangePetModal,
    showAddPetModal,
    showEditPetModal,
    setShowVetPetCodeModal,
    showVetPetCodeModal
  } = useUI();

  useEffect(() => {
    const show = (storage.storedOwnerPets.length ?? 0) > 0;
    setShowChangePetBubble(show);
  }, [storage.storedOwnerPets]);

  return (
    <div
      style={{
        position: "fixed",
        right: "1rem",
        bottom: "1rem",
        display: "flex",
        flexDirection: "column",
        gap: "1rem",
        zIndex: 1500,
      }}
    >
      {/* Feedback Bubble */}
      <div className="tooltip-container" draggable>
        <button
          onClick={() => setShowFeedbackModal(true)}
          style={bubbleStyleBase}
          aria-label="Feedback"
        >
          <FaCommentDots />
        </button>
        <span className="tooltip-text tooltip-left">Enviar feedback</span>
      </div>

      {/* Vet Bubble */}
      {isOwner && !isVet && storage.storedPet.id &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Soy médico veterinario</span>
        </div>
      }

      {/* Vet Bubble */}
      {isVet &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetPetCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Ingresar código de una mascota</span>
        </div>
      }

      {/* Code Bubble */}
      {isOwner && !isVet && storage.storedPet.id &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Código único"
          >
            <FaShareAlt />
          </button>
          <span className="tooltip-text tooltip-left">Genera un código único para tu veterinario</span>
        </div>
      }

      {/* Change Pet Bubble */}
      {showChangePetBubble &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowChangePetModal(true)}
            style={bubbleStyleBase}
            aria-label="Cambia de mascota"
          >
            <FaExchangeAlt />
          </button>
          <span className="tooltip-text tooltip-left">Cambia de mascota</span>
        </div>
      }

      {/* Modals */}
      {showChangePetModal && <ChangePetModal />}
      {showVetModal && <VeterinaryModal />}
      {showCodeModal && <PetCodeModal />}
      {showFeedbackModal && <FeedbackModal />}
      {showAddPetModal && <AddPetModal />}
      {showEditPetModal && <AddPetModal editPet={storage.storedPet} />}
      {showVetPetCodeModal && <VeterinarianPetCodeModal />}
    </div>
  );
}
 
----- Archivo: ChangePetModal.tsx ----- 
// app/components/modals/ChangePetModal.tsx
"use client";
import React, {
  useState,
  useRef,
  useEffect,
} from "react";
import { FaChevronDown, FaChevronUp, FaPlus } from "react-icons/fa";
import { PetType } from "@/types/index";
import ModalComponent from "../lib/modal";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index"
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";

export default function ChangePetModal() {
  const storage = useStorageContext();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { setShowChangePetModal, setShowAddPetModal } = useUI();

  // close dropdown if you click outside
  useEffect(() => {
    const handleClickOutside = (ev: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(ev.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () =>
      document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleSelect = (pet: PetType) => {
    storage.resetPet();
    storage.setStoredPet(pet);
    setIsOpen(false);
    setShowChangePetModal(false);
    storage.setStoredVetAccess(Empty.VetAccess());
  };

  const addPet = () => {
    setShowChangePetModal(false);
    setShowAddPetModal(true);
  };

  return (
    <ModalComponent title="Selecciona la mascota" description="Visualiza la información de la mascota seleccionada" setShowModal={setShowChangePetModal} dropdownRef={dropdownRef}>
      {/* Custom dropdown */}
      <div style={{ position: "relative", marginTop: "1rem" }}>
        <button
          type="button"
          onClick={() => setIsOpen((o) => !o)}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "0.5rem 1rem",
            borderRadius: "0.5rem",
            border: "1px solid #ccc",
            background: "#fff",
          }}
        >
          <div style={{ display: "flex", alignItems: "center" }}>
            <CircularImage
              src={storage.storedPet.image || "/pets/pet.jpg"}
              width={60}
              borderSize="3px" />
            <span style={{ color: '#000', marginLeft: '10px' }}>
              {storage.storedPet.name ?? "Selecciona una mascota"}
            </span>
          </div>
          {isOpen ? <FaChevronUp /> : <FaChevronDown />}
        </button>

        {isOpen && (
          <ul
            style={{
              position: "absolute",
              top: "100%",
              left: 0,
              right: 0,
              background: "#fff",
              border: "1px solid #ccc",
              borderRadius: "0.5rem",
              maxHeight: 200,
              overflowY: "auto",
              marginTop: "0.25rem",
              zIndex: 2010,
              padding: 0,
              listStyle: "none",
            }}
          >
            {storage.storedOwnerPets.map((pet: PetType) => (
              <li
                className="pet-selection"
                key={pet.id}
                onClick={() => handleSelect(pet)}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "0.5rem 1rem",
                  cursor: "pointer",
                }}
              >
                <CircularImage
                  src={pet.image || "/pets/pet.jpg"}
                  width={50}
                  borderSize="3px" />
                <span style={{ color: '#000', marginLeft: '8px' }}>{pet.name}</span>
              </li>
            ))}
            <li
              className="pet-selection"
              onClick={addPet}
              style={{
                display: "flex",
                alignItems: "center",
                padding: "0.5rem 1rem",
                cursor: "pointer",
              }}>
              <FaPlus />
              <span style={{ color: '#000', marginLeft: '20px' }}>Agregar mascota</span>
            </li>
          </ul>
        )}

      </div>
    </ModalComponent>
  );
}
 
----- Archivo: FeedbackModal.tsx ----- 
// app/components/modals/FeedbackModal.tsx
"use client";
import React, { useState } from "react";
import ModalComponent from "../lib/modal";
import { postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";


export default function FeedbackModal() {
  const [feedback, setFeedback] = useState("");
  const [sending, setSending] = useState(false);
  const [isAnonymous, setIsAnonymous] = useState(false);
  const session = useSessionContext();
  const { setShowFeedbackModal } = useUI();

  const sendFeedback = async (anonymous: boolean) => {
    if (!feedback.trim()) return;
    setSending(true);

    try {
      const res = await postFetch(`/api/feedback`, undefined, { feedback, anonymous, userEmail: session?.db?.user.email });
      if (!res.ok) throw new Error("Error en el servidor");
      alert("¡Gracias por tu opinión!");
      setShowFeedbackModal(false);
    } catch (err) {
      console.error(err);
      alert("Ocurrió un error al enviar tu mensaje.");
      setSending(false);
    }
  };

  return (
    <ModalComponent title="Queremos leerte" description="Cuéntanos tu experiencia con Lampo o sobre tu mascota" setShowModal={setShowFeedbackModal}>
      <textarea
        value={feedback}
        onChange={(e) => setFeedback(e.target.value)}
        style={{
          width: "100%",
          minHeight: "4rem",
          padding: "0.5rem",
          borderRadius: "0.5rem",
          border: "1px solid #ccc",
          marginTop: "0.75rem",
        }}
        disabled={sending}
      />

      {/* Checkbox para envío anónimo */}
      <label style={{ display: "flex", alignItems: "center", marginTop: "0.75rem" }}>
        <input
          type="checkbox"
          checked={isAnonymous}
          onChange={(e) => setIsAnonymous(e.target.checked)}
          disabled={sending}
          style={{ marginRight: "0.5rem" }}
        />
        Enviar de forma anónima
      </label>

      <div style={{ display: "flex", gap: "0.5rem", marginTop: "1rem" }}>
        <button
          onClick={() => sendFeedback(isAnonymous)}
          style={{ flex: 1 }}
          disabled={sending || !feedback.trim()}
        >
          {sending ? "Enviando..." : "Enviar"}
        </button>
      </div>
    </ModalComponent>
  );
}
 
----- Archivo: PetCodeModal.tsx ----- 
// app/components/modals/PetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { FaShareAlt, FaCopy } from "react-icons/fa";
import ModalComponent from "../lib/modal";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { postFetch } from "@/app/api";
import { useUI } from "@/context/UIProvider";

export default function PetCodeModal() {
  const [code, setCode] = useState("");
  const [show, setShow] = useState(false);
  const [error, setError] = useState("");
  const [copied, setCopied] = useState(false);
  const session = useSessionContext();
  const storage = useStorageContext();
  const { setShowCodeModal } = useUI();

  async function generar() {
    setError("");
    try {
      const res = await postFetch('/api/pets/me/code', undefined, { owner_id: session?.db?.user.id, pet_id: storage.storedPet.id });

      if (res.status === 404) {
        setError("No se encontró la mascota.");
        return;
      }
      if (!res.ok) {
        setError("Error al generar el código.");
        return;
      }

      const json = await res.json();
      if (json.code) {
        setCode(json.code);
        setShow(true);
        setCopied(false);
      } else {
        setError("Respuesta inválida del servidor.");
      }
    } catch (e) {
      console.error(e);
      setError("Ocurrió un error al generar el código.");
    }
  }

  const handleCopy = () => {
    navigator.clipboard.writeText(code).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
  };

  return (
    <ModalComponent title="Generar código" setShowModal={setShowCodeModal}>

      {!show &&
        <p style={{ fontSize: "0.8rem" }}>
          Este es un código dinámico de acesso para que tu veterinario pueda editar la información clínica de tu mascota.
        </p>
      }

      {error && (
        <p style={{ color: "red", marginBottom: "0.5rem", fontSize: "0.9rem" }}>
          {error}
        </p>
      )}

      {show && (
        <>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              marginBottom: "0.5rem",
            }}
          >
            {code.split("").map((char, idx) => (
              <span
                key={idx}
                style={{
                  display: "inline-block",
                  width: "2rem",
                  padding: "0.5rem 0",
                  border: "1px solid #ccc",
                  borderRadius: "0.25rem",
                  color: "#007BFF",
                  fontWeight: "bold",
                  textAlign: "center",
                  fontFamily: "monospace",
                }}
              >
                {char}
              </span>
            ))}

            <button
              onClick={handleCopy}
              style={{
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: "0.5rem",
              }}
              title="Copiar código"
            >
              <FaCopy size={20} color={copied ? "green" : "#007BFF"} />
            </button>
          </div>

          {copied && (
            <p style={{ color: "green", marginBottom: "0.5rem", fontSize: "0.8rem" }}>
              ¡Código copiado!
            </p>
          )}

          <p style={{ fontSize: "0.8rem" }}>
            Este código es único para cada mascota. Compártelo con tu médico veterinario para brindarle acceso al historial.
          </p>

        </>
      )}

      {!show &&
        <button
          onClick={generar}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "0.5rem",
            marginTop: "1rem",
          }}
        >
          <FaShareAlt size={20} /> Generar
        </button>
      }
    </ModalComponent>
  );
}
 
----- Archivo: VeterinarianPetCodeModal.tsx ----- 
// src/components/modals/VeterinarianPetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { useRouter } from "next/navigation";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { useVetContext } from "@/context/VetContext";
import { useUI } from "@/context/UIProvider";

export default function VeterinarianPetCodeModal() {
    const router = useRouter();
    const { vet } = useVetContext();
    const { setShowVetPetCodeModal } = useUI();

    const storage = useStorageContext();

    const [code, setCode] = useState("");
    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    if (!vet) {
        return;
    }

    const handleSubmit = async () => {
        setError("");
        const sanitizedCode = code.trim().toUpperCase();
        if (!sanitizedCode) {
            setError("Por favor ingresa el código de la mascota.");
            return;
        }
        setLoading(true);

        try {
            // Envío de código junto con datos ocultos del veterinario
            const vetPayload = {
                code: sanitizedCode,
                firstName: vet.first_name,
                lastName: vet.last_name,
                registration: vet.registration,
                clinicName: vet.clinic_name,
                city: vet.city
            };
            const res = await postFetch("/api/vet/use-code", undefined, vetPayload);
            const data = await res.json();

            if (!res.ok || data.error) {
                setError(data.error || "Código inválido o expirado.");
            } else {
                // Obtener datos de la mascota y almacenar
                const petRes = await getFetch(`/api/pets/${data.pet_id}`);
                if (!petRes.ok) {
                    setError("No se encontró la mascota.");
                } else {
                    const petData = await petRes.json();
                    storage.setStoredPet(petData);
                    storage.setStoredOwnerPets([]);
                    storage.setStoredVetAccess({
                        id: data.vet_access,
                        pet_id: petData.id,
                        pet_code_id: data.pet_code,
                        vet_first_name: vet.first_name,
                        vet_last_name: vet.last_name,
                        professional_registration: vet.registration,
                        clinic_name: vet.clinic_name,
                        city: vet.city
                    });
                    setShowVetPetCodeModal(false);
                    router.push(`/pages/vet/consultation/${petData.id}`);
                }
            }
        } catch {
            setError("Ocurrió un error inesperado.");
        } finally {
            setLoading(false);
        }
    };

    return (
        <ModalComponent
            title="Acceder a historial"
            description="Solo ingresa el código de la mascota para acceder a su historial"
            setShowModal={setShowVetPetCodeModal}
        >
            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    handleSubmit();
                }}
            >
                {/* Inputs ocultos con datos del veterinario */}
                <input type="hidden" name="firstName" value={vet.first_name} />
                <input type="hidden" name="lastName" value={vet.last_name} />
                <input type="hidden" name="registration" value={vet.registration} />
                <input type="hidden" name="clinicName" value={vet.clinic_name} />
                <input type="hidden" name="city" value={vet.city} />

                {/* Input visible para el código */}
                <label className="label">
                    Código de la mascota
                    <input
                        type="text"
                        className="input"
                        value={code}
                        onChange={(e) => setCode(e.target.value)}
                        placeholder="e.g. U8Y499"
                        required
                    />
                </label>

                {error && <p className="error">{error}</p>}

                <button
                    type="submit"
                    className="submit-btn"
                    disabled={loading}
                >
                    {loading ? "Validando..." : "Acceder"}
                </button>
            </form>
        </ModalComponent>
    );
}
 
----- Archivo: VeterinaryModal.tsx ----- 
// app/components/modals/VeterinaryModal.tsx
"use client";
import React, { useState } from "react";
import { useRouter } from "next/navigation";
import { veterinaryStyles } from "../../styles/veterinary";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";


export default function VeterinaryModal() {
  const [code, setCode] = useState("");
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const storage = useStorageContext();
  const { setShowVetModal } = useUI();

  const handleSubmit = async () => {
    setError("");
    const sanitizedCode = code.replaceAll(" ", "").toUpperCase();
    if (![sanitizedCode, firstName, lastName, registration, clinicName, city].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }
    setLoading(true);

    try {
      const codeResponse = await postFetch(
        '/api/vet/use-code',
        undefined,
        {
          code: sanitizedCode,
          firstName,
          lastName,
          registration,
          clinicName,
          city
        }
      );
      const codeData = await codeResponse.json();

      if (!codeResponse.ok || codeData.error) {
        setError(codeData.error || "Código inválido o expirado.");
      } else {
        const petResponse = await getFetch(`/api/pets/${codeData.pet_id}`);

        if (!petResponse.ok) {
          setError("No se encontró la mascota.");
        }
        const petData = await petResponse.json();
        storage.setStoredPet(petData);
        storage.setStoredOwnerPets([]);

        storage.setStoredVetAccess({
          id: codeData.vet_access,
          pet_id: petData.id,
          pet_code_id: codeData.pet_code,
          vet_first_name: codeData.firstName,
          vet_last_name: codeData.lastName,
          professional_registration: codeData.registration,
          clinic_name: codeData.clinicName,
          city: codeData.city
        });
        setShowVetModal(false);
        router.push(`/pages/vet/consultation/${petData.id}`);
      }
    } catch {
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <ModalComponent title="Soy médico veterinario" description="Aquí puedes revisar el historial completo, modificarlo y agregar entradas
        a la historia de la mascota" setShowModal={setShowVetModal} maxWidth="1000px">

      <div className="form-grid" style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
        <div>
          <h4 className="label">Nombre</h4>
          <input
            className="input"
            type="text"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Nombre"
          />
        </div>

        <div>
          <h4 className="label">Apellido</h4>
          <input
            className="input"
            type="text"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Apellido"
          />
        </div>

        <div>
          <h4 className="label">Registro profesional</h4>
          <input
            className="input"
            type="text"
            value={registration}
            onChange={(e) => setRegistration(e.target.value)}
            placeholder="Número de registro"
          />
        </div>

        <div>
          <h4 className="label">Clínica / Laboratorio</h4>
          <input
            className="input"
            type="text"
            value={clinicName}
            onChange={(e) => setClinicName(e.target.value)}
            placeholder="Nombre de la clínica"
          />
        </div>

        <div>
          <h4 className="label">Ciudad</h4>
          <input
            className="input"
            type="text"
            value={city}
            onChange={(e) => setCity(e.target.value)}
            placeholder="Ciudad"
          />
        </div>

        <div>
          <h4 className="label">Código de la mascota</h4>
          <input
            className="input-code"
            type="text"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            placeholder="e.g. U8Y499"
          />
        </div>
      </div>

      {error && <p className="error">{error}</p>}

      <button
        className="submit-btn"
        onClick={handleSubmit}
        disabled={loading}
      >
        {loading ? "Guardando..." : "Acceder"}
      </button>

      <style jsx>{veterinaryStyles}</style>
    </ModalComponent>
  );
}
 
----- Archivo: StorageContextType.ts ----- 
// src/context/storageType.ts
 
----- Archivo: AppContextProvider.tsx ----- 
// src/context/AppContext.tsx

import { UIProvider } from "./UIProvider";
import { OwnerSessionProvider } from "./OwnerSessionProvider";
import { VetProvider } from "./VetContext";
import { RoleProvider } from "./RoleProvider";
import { StorageProvider } from "./StorageProvider";
import { PlanProvider } from "./PlanProvider";

export function AppContextProvider({ children }: { children: React.ReactNode }) {
  return (
    <StorageProvider>
      <RoleProvider>
        <UIProvider>
          <PlanProvider>
            <OwnerSessionProvider>
              <VetProvider>
                {children}
              </VetProvider>
            </OwnerSessionProvider>
          </PlanProvider>
        </UIProvider>
      </RoleProvider>
    </StorageProvider>
  );
}
 
----- Archivo: ClientAppProvider.tsx ----- 
// components/layout/ClientAppProvider.tsx
"use client";
import React from "react";
import { AppContextProvider } from "@/context/AppContextProvider";
import { Bubbles, Loading, SideBar } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { usePathname } from "next/navigation";
import useAuthRedirect from "@/hooks/useAuthRedirect";
import { useSessionContext } from "./SessionProvider";
import { useRoleContext } from "./RoleProvider";

interface Props {
    children: React.ReactNode;
}

export default function ClientAppProvider({ children }: Props) {
    useAuthRedirect();

    const { isMobile, isDesktop } = useDeviceDetect(); 
    const { isLoading: isSessionLoading } = useSessionContext();
    const pathname = usePathname();
    const { isVetWithoutUserSession } = useRoleContext();

    // 2. Determinar si la ruta actual es una ruta pública/especial que no usa el layout principal.
    const isAuthRoute = pathname === "/login" ||
        pathname.startsWith("/auth/callback") ||
        pathname.startsWith("/pages/auth/verify");

    if (isSessionLoading) {
        return <Loading />; // Loader fullscreen o centrado
    }

    if (isAuthRoute) {
        return (
            <AppContextProvider>
                {children}
            </AppContextProvider>
        );
    }

    const isVetUserNow = isVetWithoutUserSession;
    if (isVetUserNow) {
        return null;
    }

    const gridCols = isMobile ? "1fr" : "300px 1fr";


    return (
        <AppContextProvider>
            <div
                className="container grid"
                style={{
                    gridTemplateColumns: gridCols,
                    minHeight: "100vh",
                    transition: "grid-template-columns 0.3s ease",
                    backgroundColor: "#F9FAFB",
                    fontFamily: "'Inter', sans-serif",
                    marginLeft: '2%',
                }}
            >
                <SideBar />
                <Bubbles />
                <main
                    style={{
                        padding: "3rem",
                        marginLeft: isMobile ? "1rem" : isDesktop ? "5rem" : "2rem",
                        width: isMobile ? "100%" : isDesktop ? "107%" : "247%",
                    }}
                >
                    {children}
                </main>
            </div>
        </AppContextProvider>
    );
}
 
----- Archivo: OwnerSessionProvider.tsx ----- 
// src/context/OwnerSessionProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useOwnerSession } from "@/hooks/useOwnerSession";

interface OwnerSessionContextType { isLoading: boolean }

const OwnerSessionContext = createContext<OwnerSessionContextType>({
    isLoading: true
});

export const useOwnerSessionContext = () => useContext(OwnerSessionContext);

export function OwnerSessionProvider({ children }: { children: React.ReactNode }) {
    const { isLoading } = useOwnerSession();
    return (
        <OwnerSessionContext.Provider value={{  isLoading }}>
            {children}
        </OwnerSessionContext.Provider>
    );
} 
----- Archivo: PlanProvider.tsx ----- 
// src/context/PlanProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useSelectedPlan } from "@/hooks/useSelectedPlan";

interface PlanContextType {
    isLoading: boolean;
    hasSelectedPlan: boolean;
    hasFreePlan: boolean;
    hasStandardPlan: boolean;
    hasAdvancedPlan: boolean;
    hasLifetimePlan: boolean;
    doesNotRequiresPlan: boolean;
}

const PlanContext = createContext<PlanContextType>({
    isLoading: true,
    hasSelectedPlan: true,
    hasFreePlan: true,
    hasStandardPlan: false,
    hasAdvancedPlan: false,
    hasLifetimePlan: false,
    doesNotRequiresPlan: false,
});

export const usePlanContext = () => useContext(PlanContext);

export function PlanProvider({ children }: { children: React.ReactNode }) {
    const {
        isLoading,
        hasSelectedPlan,
        hasFreePlan,
        hasStandardPlan,
        hasAdvancedPlan,
        hasLifetimePlan,
        doesNotRequiresPlan } = useSelectedPlan();
    return (
        <PlanContext.Provider value={{
            isLoading,
            hasSelectedPlan,
            hasFreePlan,
            hasStandardPlan,
            hasAdvancedPlan,
            hasLifetimePlan,
            doesNotRequiresPlan
        }}>
            {children}
        </PlanContext.Provider>
    );
} 
----- Archivo: RoleProvider.tsx ----- 
// src/context/RoleProvider.tsx
"use client";
import { useRole } from "@/hooks/useRole";
import { createContext, useContext } from "react";

export const Role = createContext({} as ReturnType<typeof useRole>);
export const useRoleContext = () => useContext(Role);

export function RoleProvider({ children }: { children: React.ReactNode }) {
    const storage = useRole();
    return <Role.Provider value={storage}>{children}</Role.Provider>;
} 
----- Archivo: SessionProvider.tsx ----- 
// src/context/SessionProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useSession as useAppSessionHook } from "@/hooks/useSession";
import { Session as SupabaseSession } from "@supabase/supabase-js";

interface AppSessionContextType {
    db: SupabaseSession | null;
    isLoading: boolean;
    setSession: (session: SupabaseSession) => Promise<void>;
}

const SessionContext = createContext<AppSessionContextType>({
    db: null,
    isLoading: true,
    setSession: async () => {}
});

export const useSessionContext = () => useContext(SessionContext);

export function SessionProvider({ children }: { children: React.ReactNode }) {
    const { session, isLoading, setSession } = useAppSessionHook();
    return (
        <SessionContext.Provider value={{ db: session, isLoading: isLoading, setSession }}>
            {children}
        </SessionContext.Provider>
    );
} 
----- Archivo: StorageProvider.tsx ----- 
// src/context/StorageProvider.tsx
"use client";
import { useAppStorage } from "@/hooks/useAppStorage";
import { createContext, useContext } from "react";

export const Storage = createContext({} as ReturnType<typeof useAppStorage>);
export const useStorageContext = () => useContext(Storage);

export function StorageProvider({ children }: { children: React.ReactNode }) {
    const storage = useAppStorage();
    return <Storage.Provider value={storage}>{children}</Storage.Provider>;
} 
----- Archivo: UIProvider.tsx ----- 
// src/context/UIProvider.tsx
"use client";
import { useState, createContext, useContext, SetStateAction } from "react";
import { useStorageContext } from "./StorageProvider";

export interface UIState {
    showVetModal: boolean;
    setShowVetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showCodeModal: boolean;
    setShowCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
    showFeedbackModal: boolean;
    setShowFeedbackModal: React.Dispatch<React.SetStateAction<boolean>>;
    showChangePetModal: boolean;
    setShowChangePetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showAddPetModal: boolean;
    setShowAddPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showEditPetModal: boolean;
    setShowEditPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showVetPetCodeModal: boolean;
    setShowVetPetCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
}

const UIContext = createContext({} as UIState);
export const useUI = () => useContext(UIContext);

export function UIProvider({ children }: { children: React.ReactNode }) {
    const [showVetModal, setShowVetModal] = useState(false);
    const [showCodeModal, setShowCodeModal] = useState(false);
    const [showFeedbackModal, setShowFeedbackModal] = useState(false);
    const [showChangePetModal, setShowChangePetModal] = useState(false);
    const [showAddPetModal, setShowAddPetModal] = useState(false);
    const [showEditPetModal, setShowEditPetModal] = useState(false);
    const [showVetPetCodeModal, setShowVetPetCodeModal] = useState(false);
    const storage = useStorageContext();

    const closeEditPetModal: React.Dispatch<React.SetStateAction<boolean>> = (close: SetStateAction<boolean>) => {
       if(!close){
        storage.resetPet();
       }
        return setShowEditPetModal(close);
    }

    return (
        <UIContext.Provider value={{
            showVetModal,
            setShowVetModal,
            showCodeModal,
            setShowCodeModal,
            showFeedbackModal,
            setShowFeedbackModal,
            showChangePetModal,
            setShowChangePetModal,
            showAddPetModal,
            setShowAddPetModal,
            showEditPetModal,
            setShowEditPetModal: closeEditPetModal,
            showVetPetCodeModal,
            setShowVetPetCodeModal
        }}>
            {children}
        </UIContext.Provider>
    );
}
 
----- Archivo: VetContext.tsx ----- 
// src/context/VetContext.tsx
"use client";
import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { getFetch } from "@/app/api";
import type { VeterinarianType } from "@/types/index";
import { useSessionContext } from "./SessionProvider";
import { useRoleContext } from "./RoleProvider";
import { useUI } from "./UIProvider";
import { useStorageContext } from "./StorageProvider";

interface VetContextType {
    vet: VeterinarianType | null;
    loading: boolean;
    refresh: () => Promise<void>;
}

// Contexto para proveer datos del veterinario autenticado
export const VetContext = createContext<VetContextType | undefined>(undefined);

interface VetProviderProps {
    children: ReactNode;
}

export function VetProvider({ children }: VetProviderProps) {
    const session = useSessionContext();
    const [vet, setVet] = useState<VeterinarianType | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const { isVetWithSession } = useRoleContext();
    const { setShowVetPetCodeModal } = useUI();
    const storage = useStorageContext();

    // Función para obtener datos del veterinario desde API
    const fetchVet = async () => {
        setLoading(true);
        try {
            if (isVetWithSession) {
                if (!session?.db?.user?.id) {
                    setVet(null);
                    return;
                }
                if (!storage.storedVetData.vet_id) {
                    const res = await getFetch(`/api/vet/${session.db?.user.id}`);
                    if (!res.ok) {
                        console.error("Error fetching veterinarian profile");
                        setVet(null);
                    } else {
                        const data: VeterinarianType = await res.json();
                        storage.setStoredVetData(data);
                        setVet(data);
                    }
                }
                else{
                    setVet(storage.storedVetData);
                }
                if (!storage.storedVetAccess.id) {
                    setShowVetPetCodeModal(true);
                }
            }
        } catch (error) {
            console.error(error);
            setVet(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchVet();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session]);

    return (
        <VetContext.Provider value={{ vet, loading, refresh: fetchVet }}>
            {children}
        </VetContext.Provider>
    );
}

// Hook para consumir el contexto de veterinario
export function useVetContext(): VetContextType {
    const context = useContext(VetContext);
    if (!context) {
        throw new Error("useVetContext debe usarse dentro de un VetProvider");
    }
    return context;
} 
----- Archivo: empty.ts ----- 
import { StepsStateType, StepStateEnum } from "@/types/lib";
import { PetType, PetCodeType, OwnerDataType, BasicDataType, VaccineDataType, SurgeryDataType, MedicineDataType, ConditionDataType, LabTestDataType, VeterinaryAccessType, FeatureType, PlanType, PlanVersionType, SubscriptionType, PetStep, VeterinarianType } from "@/types/index";
import { ConditionRepository, LabTestRepository, MedicineRepository, SurgeryRepository, VaccineRepository } from "../repositories";
import { BasicDataTypeSchema, ConditionDataTypeSchema, LabTestDataTypeSchema, MedicineDataTypeSchema, PetTypeSchema, SurgeryDataTypeSchema, VaccineDataTypeSchema } from "@/schemas/validationSchemas";

export function Pet(): PetType { return { id: '', name: '', image: '', owner_id: '' } };

export function PetCode(): PetCodeType { return { id: '', pet_id: '', code: '', used: false, expires_at: '' } };

export function OwnerData(): OwnerDataType {
    return {
        owner_id: '',
        name: '',
        last_name: '',
        phone: '',
        address: '',
        city: '',
        country: '',
        email: ''
    }
};
export function BasicData(): BasicDataType {
    return {
        pet_id: '',
        pet_type: '',
        gender: '',
        weight: '0 Kg',
        race: '',
        has_allergies: false,
        weight_condition: '',
        size: '',
        lives_with_others: false,
        main_food: '',
        has_vaccine: false,
        last_vaccine_name: undefined,
        last_vaccine_date: undefined,
        is_castrated: false,
        castration_date: undefined,
        has_anti_flea: false,
        anti_flea_date: undefined,
        uses_medicine: false,
        special_condition: false
    }
};
export function VaccineData(): VaccineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        description: undefined,
        date: undefined,
        batch: '',
        brand: ''
    }
};
export function SurgeryData(): SurgeryDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        date: undefined,
        description: undefined
    }
};
export function MedicineData(): MedicineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        dosage: '',
        frequency: ''
    }
};
export function ConditionData(): ConditionDataType {
    return {
        id: '',
        pet_id: '',
        condition: '',
        severity: ''
    }
};
export function LabTestData(): LabTestDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        type: '',
        date: undefined,
        result: undefined
    }
};
export function Feature(): FeatureType {
    return {
        text: '',
        badge: ''
    }
};
export function Plan(): PlanType {
    return {
        id: 0,
        slug: ''
    }
};
export function PlanVersion(): PlanVersionType {
    return {
        id: 0,
        plan_id: 0,
        slug: '',
        version: 0,
        title: '',
        description: '',
        price_month: 0,
        price_year: 0,
        discount_month: 0,
        discount_year: 0,
        features: [],
        effective_from: '',
        effective_to: null,
        plans: {
            id: 0,
            slug: ''
        }
    }
};
export function Subscription(): SubscriptionType {
    return {
        id: 0,
        owner_id: '',
        plan_version_id: 0,
        cycle: 'monthly',
        status: 'pending',
        external_id: null,
        price_at_purchase: 0,
        discount_applied: 0,
        started_at: '',
        expires_at: null,
        updated_at: ''
    }
};

export function VetAccess(): VeterinaryAccessType {
    return {
        id: '',
        pet_id: '',
        pet_code_id: '',
        vet_first_name: '',
        vet_last_name: '',
        professional_registration: '',
        clinic_name: '',
        city: ''
    }
}

export function VetData(): VeterinarianType {
    return {
        vet_id: '',
        first_name: '',
        last_name: '',
        email: '',
        registration: '',
        clinic_name: '',
        city: ''
    }
}

export function Steps(): StepsStateType[] {
    return [
        { step: PetStep.Name, state: StepStateEnum.NotInitialize, schema: PetTypeSchema },
        { step: PetStep.BasicData, state: StepStateEnum.NotInitialize, schema: BasicDataTypeSchema },
        { step: PetStep.Vaccines, state: StepStateEnum.NotInitialize, schema: VaccineDataTypeSchema, url: '/api/pets/list/vaccines/', repository: new VaccineRepository() },
        { step: PetStep.Medicines, state: StepStateEnum.NotInitialize, schema: MedicineDataTypeSchema, url: '/api/pets/list/medicines/', repository: new MedicineRepository() },
        { step: PetStep.LabTests, state: StepStateEnum.NotInitialize, schema: LabTestDataTypeSchema, url: '/api/pets/list/lab-tests/', repository: new LabTestRepository() },
        { step: PetStep.Conditions, state: StepStateEnum.NotInitialize, schema: ConditionDataTypeSchema, url: '/api/pets/list/conditions/', repository: new ConditionRepository() },
        { step: PetStep.Surgeries, state: StepStateEnum.NotInitialize, schema: SurgeryDataTypeSchema, url: '/api/pets/list/surgeries/', repository: new SurgeryRepository() }
    ];
}

import { Empty } from "../data";

export function emptyStorage() {
    return {
        resetSession: () => { },
        resetPet: () => { },
        storedPet: Empty.Pet(),
        setStoredPet: () => { },
        storedBasicData: Empty.BasicData(),
        setStoredBasicData: () => { },
        storedOwnerData: Empty.OwnerData(),
        setStoredOwnerData: () => { },
        storedVetData: Empty.VetData(),
        setStoredVetData: () => { },
        storedVetAccess: Empty.VetAccess(),
        setStoredVetAccess: () => { },
        storedPetCode: Empty.PetCode(),
        setStoredPetCode: () => { },
        storedOwnerPets: [],
        setStoredOwnerPets: () => { },
        storedVaccineData: [],
        setStoredVaccineData: () => { },
        storedConditionData: [],
        setStoredConditionData: () => { },
        storedLabTestData: [],
        setStoredLabTestData: () => { },
        storedMedicineData: [],
        setStoredMedicineData: () => { },
        storedSurgeryData: [],
        setStoredSurgeryData: () => { }
    }
} 
----- Archivo: entityFieldData.ts ----- 
import { ConditionDataType, LabTestDataType, SurgeryDataType, VaccineDataType } from "@/types/index";
import { Dates } from "@/utils/index";

export function ForConditions(condition: ConditionDataType) {
    return [
        { label: "Condición", show: true, value: condition.condition },
        { label: "Severidad", show: true, value: condition.severity },
    ];
}

export function ForLabTests(labTest: LabTestDataType) {
    return [
        { label: "Prueba", show: true, value: labTest.name },
        { label: "Tipo", show: true, value: labTest.type },
        {
            label: "Fecha",
            show: labTest.date != null,
            value: Dates.format(labTest.date),
        },
        {
            label: "Resultado",
            show: labTest.result != null,
            value: labTest.result ?? "",
        },
    ];
}

export function ForMedicines(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForSurgeries(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForVaccines(vaccine: VaccineDataType) {
    return [
        { label: "Vacuna", show: true, value: vaccine.name },
        {
            label: "Descripción",
            show: vaccine.description != null,
            value: vaccine.description ?? "",
        },
        {
            label: "Fecha",
            show: vaccine.date != null,
            value: Dates.format(vaccine.date),
        },
        { label: "Lote", show: true, value: vaccine.batch },
        { label: "Marca", show: true, value: vaccine.brand },
    ];
} 
----- Archivo: index.ts ----- 
export * as Empty from "./empty";
export * as FieldData from "./entityFieldData"; 
----- Archivo: petdata.ts ----- 
// app/data/petdata.tsx
import { v4 } from "uuid";
import { Metadata } from "next";
import {
  BasicDataType,
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  OwnerDataType,
  PetType,
  SurgeryDataType,
  VaccineDataType
} from "@/types/index";

export const metadata: Metadata = {
  title: "Lampo",
  description: "Lampo es una herramienta para que ayudará a TU MASCOTA en sus proceso clínicos y veterinarios",
};

export const andresData: OwnerDataType = {
  owner_id: '8933eed8-daea-4e6c-b4db-44906b9f44f9',
  name: 'Andrés',
  last_name: 'Aulestia',
  phone: '+57 3146061490',
  address: 'Cra. 74 #152b-70 Torre 3 Apto. 1704',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'a.aulestia@exe.com.co'
}

export const johnnyData: OwnerDataType = {
  owner_id: '41095adf-27a6-48f8-ada1-d8c7d3dd265a',
  name: 'Johnnatan',
  last_name: 'Ruiz',
  phone: '+57 3112849616',
  address: 'Calle 82 #19A-29 Apt 401',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'excellent.exeqtion@gmail.com'
}

export const ownersData: OwnerDataType[] = [
  andresData,
  johnnyData
];

export const PetsData: PetType[] = [
  { id: 'A001', name: 'Camus', image: '/pets/camus.png', owner_id: andresData.owner_id },
  { id: 'A002', name: 'Polar', image: '/pets/polar.png', owner_id: johnnyData.owner_id },
  { id: 'A003', name: 'Toby', image: '/pets/toby.png', owner_id: johnnyData.owner_id }
];

export const camusData: BasicDataType =
{
  pet_id: 'A001', pet_type: 'Gato', gender: 'Macho', weight: '5.5 Kg', race: 'Mestizo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: false,
  main_food: 'Taste the Wild', has_vaccine: true, last_vaccine_name: 'Parvigen', last_vaccine_date: new Date('2024-07-25'),
  is_castrated: true, castration_date: new Date('2023-12-02'), has_anti_flea: true, anti_flea_date: new Date('2023-12-15'),
  uses_medicine: false, special_condition: false
}

export const polarData: BasicDataType =
{
  pet_id: 'A002', pet_type: 'Perro', gender: 'Macho', weight: '7 Kg', race: 'Criollo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true,
  main_food: 'Pro Plan', has_vaccine: false,
  is_castrated: true, castration_date: new Date('2023-06-30'), has_anti_flea: false,
  uses_medicine: false, special_condition: false
};

export const tobyData: BasicDataType =
{
  pet_id: 'A003', pet_type: 'Perro', gender: 'Macho', weight: '9 Kg', race: 'Criollo', has_allergies: true,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true,
  main_food: 'Vet Life', has_vaccine: false,
  is_castrated: true, castration_date: new Date('2019-05-03'), has_anti_flea: false,
  uses_medicine: false, special_condition: true
};

export const petsData: BasicDataType[] =
  [
    camusData,
    polarData,
    tobyData
  ];


export const vaccinesMock: VaccineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Rabia", description: "Vacuna contra la rabia", date: new Date('2025-03-15'), batch: "RAB12345", brand: "Nobivac" },
  { id: v4(), pet_id: 'A001', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
  { id: v4(), pet_id: 'A002', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
];

export const surgeriesMock: SurgeryDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Castración", date: new Date("2024-11-20"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A001', name: "Extracción dental", date: new Date("2024-12-05"), description: "Tooth extraction" },
  { id: v4(), pet_id: 'A002', name: "Castración", date: new Date("2023-06-30"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A003', name: "Castración", date: new Date("2019-05-03"), description: "Castración preventiva" },
];

export const medicinesMock: MedicineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Antibiótico X", dosage: "250mg", frequency: "Cada 12 horas" },
  { id: v4(), pet_id: 'A001', name: "Vitamina C", dosage: "100mg", frequency: "Diaria" },
];

export const conditionsMock: ConditionDataType[] = [
  { id: v4(), pet_id: 'A001', condition: "Esterilidad aórtica", severity: "Moderada" },
  { id: v4(), pet_id: 'A001', condition: "Alergia alimentaria", severity: "Leve" },
  { id: v4(), pet_id: 'A003', condition: "Insuficiencia renal", severity: "Leve" },
];

export const labTestsMock: LabTestDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Hemograma completo", type: "Blood", date: new Date("2025-01-10"), result: "Normal" },
  { id: v4(), pet_id: 'A001', name: "Ultrasonido abdominal", type: "Ultrasound", date: new Date("2024-12-22"), result: "Sin hallazgos" },
];

export const petTypes = ['Perro', 'Gato', 'Ave', 'Reptil', 'Otro'];
export const genders = ['Macho', 'Hembra'];
export const weightUnits = ['Kg', 'Lb'];
export const breedOptions: Record<string, string[]> = {
  Perro: ['Labrador', 'Pastor Alemán', 'Bulldog', 'Otro'],
  Gato: ['Siamés', 'Persa', 'Maine Coon', 'Otro'],
  Ave: ['Loro', 'Canario', 'Periquito', 'Otro'],
  Reptil: ['Iguana', 'Tortuga', 'Otro'],
  Otro: ['Otro'],
};
export const foodOptions = [
  'Royal Canin',
  'Purina Pro Plan',
  'Whiskas',
  'Dog Chow',
  'Eukanuba',
  'Nutra Nuggets',
  'Pedigree',
  'Otro'
];
export const weightConditionOptions = ['Bajo peso', 'Peso ideal', 'Sobrepeso'];
export const sizeOptions = ['Pequeño', 'Mediano', 'Grande', 'Extra Grande']; 
----- Archivo: useAppStorage.ts ----- 
// hooks/useAppStorage.ts
import { useLocalStorage } from "@/hooks/useLocalStorage";
import { PetType, PetCodeType, VeterinaryAccessType, BasicDataType, OwnerDataType, VaccineDataType, ConditionDataType, LabTestDataType, MedicineDataType, SurgeryDataType, VeterinarianType, PlanType } from "@/types/index";
import { Empty } from "@/data/index";
export interface StorageContextType {
  resetSession: () => void;
  resetPet: () => void;
  storedPet: PetType;
  setStoredPet: (value: PetType) => void;
  storedBasicData: BasicDataType;
  setStoredBasicData: (value: BasicDataType) => void;
  storedOwnerData: OwnerDataType;
  setStoredOwnerData: (value: OwnerDataType) => void;
  storedVetData: VeterinarianType;
  setStoredVetData: (value: VeterinarianType) => void;
  storedVetAccess: VeterinaryAccessType;
  setStoredVetAccess: (value: VeterinaryAccessType) => void;
  storedPetCode: PetCodeType;
  setStoredPetCode: (value: PetCodeType) => void;
  storedOwnerPets: PetType[];
  setStoredOwnerPets: (value: PetType[]) => void;
  storedVaccineData: VaccineDataType[],
  setStoredVaccineData: (value: VaccineDataType[] | null) => void,
  storedConditionData: ConditionDataType[],
  setStoredConditionData: (value: ConditionDataType[] | null) => void,
  storedLabTestData: LabTestDataType[],
  setStoredLabTestData: (value: LabTestDataType[] | null) => void,
  storedMedicineData: MedicineDataType[],
  setStoredMedicineData: (value: MedicineDataType[] | null) => void,
  storedSurgeryData: SurgeryDataType[],
  setStoredSurgeryData: (value: SurgeryDataType[] | null) => void,
  storedPlanData: PlanType,
  setStoredPlanData: (value: PlanType | null) => void,
}

export function useAppStorage() {
  const [storedPet, setStoredPet] = useLocalStorage<PetType>(
    "selectedPet",
    Empty.Pet()
  );

  const [storedBasicData, setStoredBasicData] = useLocalStorage<BasicDataType>(
    "petBasicData",
    Empty.BasicData()
  );

  const [storedOwnerData, setStoredOwnerData] = useLocalStorage<OwnerDataType>(
    "petOwnerData",
    Empty.OwnerData()
  );

  const [storedOwnerPets, setStoredOwnerPets] = useLocalStorage<PetType[]>(
    "ownerPets",
    []
  );

  const [storedVaccineData, setStoredVaccineData] = useLocalStorage<VaccineDataType[] | null>(
    "petVaccineData",
    null
  );

  const [storedConditionData, setStoredConditionData] = useLocalStorage<ConditionDataType[] | null>(
    "petConditionData",
    null
  );

  const [storedLabTestData, setStoredLabTestData] = useLocalStorage<LabTestDataType[] | null>(
    "petLabTestData",
    null
  );

  const [storedMedicineData, setStoredMedicineData] = useLocalStorage<MedicineDataType[] | null>(
    "petMedicineData",
    null
  );

  const [storedSurgeryData, setStoredSurgeryData] = useLocalStorage<SurgeryDataType[] | null>(
    "petSurgeryData",
    null
  );

  const [storedVetAccess, setStoredVetAccess] = useLocalStorage<VeterinaryAccessType>(
    "vetAccess",
    Empty.VetAccess()
  );

  const [storedPetCode, setStoredPetCode] = useLocalStorage<PetCodeType>(
    "petCode",
    Empty.PetCode()
  );

  const [storedVetData, setStoredVetData] = useLocalStorage<VeterinarianType>(
    "vetData",
    Empty.VetData()
  );

  const [storedPlanData, setStoredPlanData] = useLocalStorage<PlanType | null>(
    "planType",
    null
  );

  const resetPet = () => {
    setStoredBasicData(Empty.BasicData());
    setStoredConditionData(null);
    setStoredLabTestData(null);
    setStoredMedicineData(null);
    setStoredSurgeryData(null);
    setStoredVaccineData(null);
  }

  const resetSession = () => {
    resetPet();
    setStoredPetCode(Empty.PetCode());
    setStoredVetAccess(Empty.VetAccess());
    setStoredOwnerData(Empty.OwnerData());
    setStoredOwnerPets([]);
    setStoredPet(Empty.Pet());
  }

  return {
    resetSession,
    resetPet,
    storedPet,
    setStoredPet,
    storedBasicData,
    setStoredBasicData,
    storedOwnerData,
    setStoredOwnerData,
    storedVetData,
    setStoredVetData,
    storedOwnerPets,
    setStoredOwnerPets,
    storedVaccineData,
    setStoredVaccineData,
    storedConditionData,
    setStoredConditionData,
    storedLabTestData,
    setStoredLabTestData,
    storedMedicineData,
    setStoredMedicineData,
    storedSurgeryData,
    setStoredSurgeryData,
    storedVetAccess,
    setStoredVetAccess,
    storedPetCode,
    setStoredPetCode,
    storedPlanData, 
    setStoredPlanData
  } as StorageContextType;
} 
----- Archivo: useAuthRedirect.ts ----- 
// src/hooks/useAuthRedirect.ts
"use client";

import { useEffect } from "react";
import { usePathname, useRouter } from "next/navigation";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider"; // Para storedVetAccess si es relevante aquí
import { useRoleContext } from "@/context/RoleProvider"; // Para la lógica de roles

export default function useAuthRedirect() {
    const router = useRouter();
    const pathname = usePathname();
    const { db: session, isLoading: isSessionLoading } = useSessionContext(); // Obtener isLoading
    const { storedVetAccess } = useStorageContext(); // Aunque su uso directo aquí podría disminuir
    const { isVetWithoutUserSession } = useRoleContext();

    useEffect(() => {
        // 1. No hacer nada si la sesión aún está cargando
        if (isSessionLoading) {
            return;
        }

        // 2. Definición de rutas especiales
        const isLoginRoute = pathname === "/login";
        const isVerifyAuthRoute = pathname.startsWith("/pages/auth/verify"); // Ruta de verificación de email
        const isCallbackAuthRoute = pathname.startsWith("/auth/callback"); // Ruta de callback de Supabase (OTP)
        const isPublicRoute = isLoginRoute || isVerifyAuthRoute || isCallbackAuthRoute; // Rutas que no requieren sesión
        const isVetAccessUIRoute = pathname.startsWith("/vet-access"); // Rutas UI para acceso veterinario sin cuenta

        // 3. Lógica de Redirección
        if (session) {
            // ----- HAY SESIÓN -----
            if (isLoginRoute) {
                router.replace("/");
                return;
            }

        } else {
            // ----- NO HAY SESIÓN -----
            if (isVetWithoutUserSession && !isVetAccessUIRoute && !isPublicRoute) {
                router.replace("/vet-access");
                return;
            }

            if (!isPublicRoute && !isVetAccessUIRoute) {
                router.replace("/login");
                return;
            }
        }

    }, [session, isSessionLoading, pathname, router, storedVetAccess, isVetWithoutUserSession]); // Añadir storedVetAccess e isVetWithoutUserSession si son cruciales para la lógica de redirección inmediata.
} 
----- Archivo: useDeviceDetect.ts ----- 
// hooks/useDeviceDetect.ts
import { useState, useEffect } from 'react'

export function useDeviceDetect() {
  const [isMobile, setIsMobile] = useState(false)
  const [isTablet, setIsTablet] = useState(false)
  const [isDesktop, setIsDesktop] = useState(false)

  useEffect(() => {
    const onResize = () => {
      const w = window.innerWidth
      setIsMobile(w <= 767)
      setIsTablet(w > 767 && w <= 1024)
      setIsDesktop(w > 1024)
    }

    onResize() // run once on mount
    window.addEventListener('resize', onResize)
    return () => window.removeEventListener('resize', onResize)
  }, [])

  return { isMobile, isTablet, isDesktop }
}
 
----- Archivo: useEffectDebugger.ts ----- 
/* eslint-disable @typescript-eslint/no-explicit-any */

import { useRef, useEffect } from "react";

const usePrevious = (value: any, initialValue: any) => {
    const ref = useRef(initialValue);
    useEffect(() => {
        ref.current = value;
    });
    return ref.current;
};

export const useEffectDebugger = (processName: string, effectHook: any, dependencies: any, dependencyNames = []) => {
    const previousDeps = usePrevious(dependencies, []);

    const changedDeps = dependencies.reduce((accum: any, dependency: any, index: any) => {
        if (dependency !== previousDeps[index]) {
            const keyName = dependencyNames[index] || index;
            return {
                ...accum,
                [keyName]: {
                    before: previousDeps[index],
                    after: dependency
                }
            };
        }

        return accum;
    }, {});

    if (Object.keys(changedDeps).length) {
        console.log(`[use-effect-debugger] ${processName}:`, changedDeps);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(effectHook, dependencies);
};

 
----- Archivo: useEntityList.ts ----- 
// src/hooks/useEntityList.ts
"use client";

import { deleteFetch } from '@/app/api';
import { ApiError, StepsStateType } from '@/types/lib';
import { Dispatch, SetStateAction } from 'react';

export function useEntityList<T extends { id: string | undefined }>(
    emptyFactory: (id: string) => Partial<T>,
    id: string,
    setList: Dispatch<SetStateAction<Partial<T>[]>>,
    setError: Dispatch<SetStateAction<string | null>>,
    stepNumber: number,
    stepStates: StepsStateType[]
) {
    const addItem = () => setList(prev => [...prev, emptyFactory(id)]);
    const removeItem = (id?: string) => {
        const getUrl = () =>
            stepStates.find(x => x.step == stepNumber)?.url;
        if (id) {
            try {
                deleteFetch(`${getUrl()}${id}`);
            }
            catch {
                throw new ApiError("Error al consumir la api de delete");
            }
        }
        setList(prev => {
            const items = prev.filter(item => item.id !== id);
            if (items.length == 0) {
                setError('');
            }
            return items;
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateItem = (index: number, field: keyof T, value: any) =>
        setList(prev => prev.map((item, idx) => (idx === index ? { ...item, [field]: value } : item)));

    return { addItem, removeItem, updateItem };
}
 
----- Archivo: useEntitySubmit.ts ----- 
// src/hooks/useEntitySubmit.ts
"use client";

import { Dispatch, SetStateAction, useState } from 'react';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { Steps, Validations } from '@/utils/index';
import { FieldConfig } from '../types/lib/index';
import { postFetch } from '@/app/api';

export function useEntitySubmit<T>(
    id: string,
    entities: Partial<T>[],
    entityName: string,
    setStoredList: (list: T[]) => void,
    setDataCallback: (data: T[]) => void,
    fieldConfig: FieldConfig<T>[],
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: React.Dispatch<React.SetStateAction<StepsStateType[]>>,
    error: string | null,
    setError: Dispatch<SetStateAction<string | null>>
) {
    const [submitting, setSubmitting] = useState(false);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x => x.step === stepNumber)?.url;

    const submit = async (onNext: () => void) => {
        setSubmitting(false);
        const validationError = Validations.forFields(entities, entityName, fieldConfig);
        if (validationError) {
            setError(validationError);
            return;
        }
        setError(null);
        try {
            if (stateEq(StepStateEnum.Modified)) {
                if (entities.length > 0) {
                    const basicDataResponse = await postFetch(`${getUrl()}${id}`, undefined, entities);
                    if (!basicDataResponse.ok) throw new ApiError(`Error actualizado ${entityName}.`);
                    setDataCallback(entities as T[]);
                    setStoredList(entities as T[]);
                }
                setState(StepStateEnum.Saved);
            }
            onNext();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (err: any) {
            setError(err.message);
            setState(StepStateEnum.Error, err.message);
        } finally {
            setSubmitting(true);
        }
    };

    return { submit, loading: submitting, error };
} 
----- Archivo: useLoadEntities.ts ----- 

// src/hooks/useLoadEntities.ts
"use client";

import { useState, useEffect, Dispatch, SetStateAction } from 'react';
import { Steps } from '@/utils/index';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { getFetch } from '@/app/api';

export function useLoadEntities<T>(
    id: string,
    entityName: string,
    storedList: T[],
    setStoredList: (list: T[] | null) => void,
    initialData: T[],
    setDataCallback: (data: T[]) => void,
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: Dispatch<SetStateAction<StepsStateType[]>>
) {
    const [list, setList] = useState<Partial<T>[]>(initialData);
    const [savedData, setSavedData] = useState<T[]>(initialData);
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(true);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x => x.step == stepNumber)?.url;

    useEffect(() => {
        const fetch = async () => {
            if (stateEq(StepStateEnum.NotInitialize)) {
                setState(StepStateEnum.Initialize);
                let saved: T[] = [];
                if (storedList == null) {
                    const response = await getFetch(`${getUrl()}}${id}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener información de ${entityName}`);
                    if (saved.length > 0) {
                        setStoredList(saved);
                    }
                }
                else {
                    saved = storedList;
                }
                if (saved) {
                    setSavedData(saved);
                    setDataCallback(saved);
                    setList(saved);
                }
            }
            setLoading(false);
        }
        fetch();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [id]);

    useEffect(() => {
        if (JSON.stringify(savedData) !== JSON.stringify(list) && !stateEq(StepStateEnum.NotInitialize) && loading == false) {
            setState(StepStateEnum.Modified);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [list]);

    return { list, setList, error, setError, loading, setState, stateEq };
}
 
----- Archivo: useOwnerSession.ts ----- 
import { getFetch } from "@/app/api";
import { useRoleContext } from "@/context/RoleProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";
import { ApiError } from "@/types/lib";
import { useEffect, useState } from "react";
import { Empty } from "../data";
import { PetType } from "../types";
import { useSessionContext } from "@/context/SessionProvider";
import { usePlanContext } from "@/context/PlanProvider";

export function useOwnerSession(): { isLoading: boolean } {
    const { db: session } = useSessionContext();
    const storage = useStorageContext();
    const { setShowAddPetModal } = useUI();
    const { isOwner } = useRoleContext();
    const { hasSelectedPlan } = usePlanContext();

    const [loadingOwnerPets, setLoadingOwnerPets] = useState(true);
    const [loadingSelectedPet, setLoadingSelectedPet] = useState(true);

    useEffect(() => {
        const ownerId = session?.user?.id;
        if (!session || !ownerId) return;

        (async () => {
            if (isOwner) {
                if (storage.storedOwnerPets.length === 0) {
                    const response = await getFetch(`/api/owners/pets/${ownerId}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener las mascotas del dueño: ${ownerId}`);
                    const data = await response.json();
                    storage.setStoredOwnerPets(data as PetType[]);
                }
            }
            setLoadingOwnerPets(false);
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session, session?.user?.id]);

    useEffect(() => {
        let initialPet = Empty.Pet();
        if (storage.storedOwnerPets.length > 0) initialPet = storage.storedOwnerPets[0];
        if (storage.storedPet.id) initialPet = storage.storedPet;
        if (JSON.stringify(initialPet) !== JSON.stringify(storage.storedPet)) {
            storage.setStoredPet(initialPet);
        }
        if (!initialPet.id && isOwner && hasSelectedPlan) {
            setShowAddPetModal(true);
        }
        setLoadingSelectedPet(false);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedOwnerPets]);

    return { isLoading: loadingOwnerPets || loadingSelectedPet }
} 
----- Archivo: useRole.ts ----- 
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";

export function useRole() {
  const { db: session } = useSessionContext();
  const { storedVetAccess } = useStorageContext();

  const isOwner = session?.user.user_metadata.role === "owner";
  const isVetWithSession = session?.user.user_metadata.role === "veterinarian";
  const hasVetAccessWithoutSession = !session && Boolean(storedVetAccess?.id);
  const isVetWithUserSession = Boolean(storedVetAccess?.id) && isOwner;
  const isVetWithoutUserSession =
    (isVetWithSession || hasVetAccessWithoutSession) && !isVetWithUserSession;
  const isVet =
    isVetWithSession || 
    isVetWithoutUserSession || 
    isVetWithUserSession;
  return {
    isOwner,
    isVet,
    isVetWithSession,
    isVetWithoutSession: hasVetAccessWithoutSession,
    isVetWithUserSession,
    isVetWithoutUserSession,
  } as const;
}
 
----- Archivo: useSelectedPlan.ts ----- 
import { getFetch } from "@/app/api";
import { useRoleContext } from "@/context/RoleProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { ApiError } from "@/types/lib";
import { useState, useEffect } from "react";
import { PlanType } from "../types";

export function useSelectedPlan(): {
    isLoading: boolean;
    hasSelectedPlan: boolean;
    hasFreePlan: boolean;
    hasStandardPlan: boolean;
    hasAdvancedPlan: boolean;
    hasLifetimePlan: boolean;
    doesNotRequiresPlan: boolean;
} {
    const { db: session } = useSessionContext();
    const storage = useStorageContext();
    const { isOwner } = useRoleContext();

    const [loadingPlan, setLoadingPlan] = useState(true);
    const [hasSelectedPlan, setHasSelectedPlan] = useState(false);
    const [hasFreePlan, setHasFreePlan] = useState(false);
    const [hasStandardPlan, setHasStandardPlan] = useState(false);
    const [hasAdvancedPlan, setHasAdvancedPlan] = useState(false);
    const [hasLifetimePlan, setHasLifetimePlan] = useState(false);
    const [doesNotRequiresPlan, setDoesNotRequiresPlan] = useState(false);

    useEffect(() => {
        const ownerId = session?.user?.id;
        if (!session || !ownerId) return;

        (async () => {
            if (isOwner) {
                if (!storage.storedPlanData) {
                    const response = await getFetch(`/api/plans/subscriptions/${ownerId}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener la suscripción actual del dueño: ${ownerId}`);
                    const data = await response.json();
                    if (data == null) {
                        setHasSelectedPlan(false);
                    }
                    storage.setStoredPlanData(data as PlanType);
                }
            }
            setLoadingPlan(false);
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session, session?.user?.id]);

    useEffect(() => {
        if (hasSelectedPlan) {
            if (storage.storedPlanData) {
                switch (storage.storedPlanData.slug) {
                    case 'lifetime': {
                        setHasLifetimePlan(true);
                    }
                    case 'advanced': {
                        setHasAdvancedPlan(true);
                    }
                    case 'standard': {
                        setHasStandardPlan(true);
                    }
                    default:
                    case 'free': {
                        setHasFreePlan(true);
                    }
                }
            }
            else {
                setDoesNotRequiresPlan(true);
            }
        }
        else {
            setHasLifetimePlan(false);
            setHasAdvancedPlan(false);
            setHasStandardPlan(false);
            setHasFreePlan(false);
            setDoesNotRequiresPlan(false);
        }
    }, [storage.storedPlanData, hasSelectedPlan])

    return {
        isLoading: loadingPlan,
        hasSelectedPlan,
        hasFreePlan,
        hasStandardPlan,
        hasAdvancedPlan,
        hasLifetimePlan,
        doesNotRequiresPlan
    };

}
 
----- Archivo: useLocalStorage.tsx ----- 
// app/lib/db/hooks/useLocalStorage.tsx
import { useState, useEffect } from "react";
import CryptoJS from "crypto-js";

/**
 * Hook para manejar un valor en localStorage con encriptación opcional y hash de clave,
 * implementando hidratación para evitar lectura antes del montaje.
 * @param key Clave original para identificar item en storage.
 * @param initialValue Valor inicial si no existe valor en storage.
 * @param options.secret Secreto para encriptar/hashear clave y valor.
 * @returns [valor, setter] donde setter actualiza estado y storage.
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T,
  options?: { secret?: string }
): [T, (value: T | null) => void] {
  const secret = options?.secret || (process.env.NEXT_PUBLIC_ENABLE_ENCRYPTION == 'false' ? '' : process.env.NEXT_PUBLIC_STORAGE_SECRET!);
  // Generar clave de storage hasheada si hay secreto
  const storageKey = secret
    ? CryptoJS.SHA256(key + secret).toString()
    : key;

  // Estado del valor almacenado
  const [storedValue, setStoredValue] = useState<T>(initialValue);

  // Al hidratar, leer de localStorage
  useEffect(() => {
    try {
      const item = window.localStorage.getItem(storageKey);
      if (item === null) {
        setStoredValue(initialValue);
      } else {
        const raw = secret
          ? CryptoJS.AES.decrypt(item, secret).toString(CryptoJS.enc.Utf8)
          : item;
        setStoredValue(JSON.parse(raw) as T);
      }
    } catch {
      setStoredValue(initialValue);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storageKey, secret]);

  /**
   * Setter que guarda en estado y en localStorage (o elimina si value es null).
   */
  const setValue = (value: T | null) => {
    if (typeof window === "undefined") {
      setStoredValue(value as T);
      return;
    }
    try {
      if (value === null) {
        window.localStorage.removeItem(storageKey);
        setStoredValue(initialValue);
      } else {
        const stringValue = JSON.stringify(value);
        const encrypted = secret
          ? CryptoJS.AES.encrypt(stringValue, secret).toString()
          : stringValue;
        window.localStorage.setItem(storageKey, encrypted);
        setStoredValue(value);
      }
    } catch {
      // Ignorar errores de storage
    }
  };

  return [storedValue, setValue];
}
 
----- Archivo: useSession.tsx ----- 
// src/hooks/useSession.tsx
"use client";
import { useState, useEffect } from "react";
import type { Session as SupabaseSession, AuthChangeEvent } from "@supabase/supabase-js";
import { authClient } from "@/lib/auth";

export function useSession(): {
  session: SupabaseSession | null;
  setSession: (session: SupabaseSession) => Promise<void>;
  isLoading: boolean;
} {
  const [session, setSession] = useState<SupabaseSession | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    let mounted = true;

    const { data: authSubscription } = authClient.onAuthStateChange(
      (event: AuthChangeEvent, sessionState: SupabaseSession | null) => {
        if (mounted) {
          setSession(sessionState);

          if (event === 'INITIAL_SESSION' || event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
            if (isLoading) {
              setIsLoading(false);
            }
          }
        } else {
          console.log('hooks/useSession: onAuthStateChange FIRED but component unmounted (Full App Context).');
        }
      });

    authClient.getSession().then(currentSession => {
      if (mounted) {
        setSession(prev => JSON.stringify(prev) === JSON.stringify(currentSession) ? prev : currentSession);

        if (isLoading) {
          setIsLoading(false);
        }
      }
    }).catch(error => {
      if (mounted) {
        console.error("hooks/useSession: authClient.getSession() PROMISE REJECTED (Full App Context):", error);
        if (isLoading) {
          setIsLoading(false);
        }
      }
    });

    return () => {
      mounted = false;
      authSubscription.unsubscribe();
    };
  }, [isLoading]);

  const setAppSession = async (session: SupabaseSession) =>{
    await authClient.setSession(session);
    setIsLoading(false);
    setSession(session);
  }

  return { session, setSession: setAppSession, isLoading };
} 
----- Archivo: index.ts ----- 
// lib/auth/index.ts
import type { AuthChangeEvent, AuthError, Session as SupabaseSession, User } from "@supabase/supabase-js";
import { SupabaseAuthClient } from "./supabase/authClient";
//import { createServerClient as SupabaseServerClient } from "./supabase/serverClient"; // Usar el cliente de servidor real
import { updateSession as SupabaseUpdateSession } from "./supabase/middleware"; // Usar el middleware real
import { NextRequest, NextResponse } from "next/server"; // NextResponse añadido

export type SignInResponse = { data?: { session: AuthSession; user: User } | null; error?: AuthError | null };
export type SignUpResponse = { data: { user: User | null, /* session?: AuthSession | null */ }; error: AuthError | null }; // session es opcional en signup
export type ResetPasswordResponse = { data: object | null; error: AuthError | null };
export type AuthSession = SupabaseSession;
export type AuthClientError = AuthError;
export type AuthClientChangeEvent = AuthChangeEvent; // Asumiendo que es el tipo de Supabase

export interface AuthClient {
    getSession(): Promise<AuthSession | null>;
    onAuthStateChange(
        cb: (event: AuthChangeEvent, session: AuthSession | null) => void // event puede ser AuthChangeEvent de supabase
    ): { data: { unsubscribe: () => void } };
    signIn(email: string, password: string): Promise<SignInResponse>;
    signOut(): Promise<void>;
    resetPassword(email: string): Promise<ResetPasswordResponse>;
    signUp(email: string, password: string, role: string): Promise<SignUpResponse>;
    setSession(session: { access_token: string; refresh_token: string; }): Promise<void>;
}

const authClientImpl = new SupabaseAuthClient();
export { authClientImpl as authClient };
/*
// Este 'createClient' es para obtener el cliente de autenticación del SERVIDOR (para API Routes o Server Components)
// Lo renombré a createAuthServerClient para evitar confusión si en otro lado se crea un cliente de datos.
const createAuthServerClient = async () => {
    // createServerClient ya devuelve el cliente Supabase completo, accedemos a .auth
    const serverSupabaseClient = await SupabaseServerClient(); // Esta función ya está en serverClient.ts
    return serverSupabaseClient.auth;
};
export { createAuthServerClient as createClient }; // Exportar con el nombre que usabas si es necesario
*/
// Este 'updateSession' es el que se usa en el middleware
const updateSessionImpl = async (req: NextRequest): Promise<NextResponse> => { // Debe devolver NextResponse
    return SupabaseUpdateSession(req); // Esta función ya está en middleware.ts
}
export { updateSessionImpl as updateSession }; 
----- Archivo: authClient.ts ----- 
// lib/auth/supabase/authClient.ts
import type { AuthClient, AuthSession, SignInResponse, SignUpResponse, ResetPasswordResponse } from ".."; // Asegúrate que la ruta a index.ts sea correcta
import type { AuthChangeEvent, User } from "@supabase/supabase-js";
import { supabase } from "./browserClient"; // Importa la instancia ÚNICA del browserClient

export class SupabaseAuthClient implements AuthClient {
    // No necesitamos las propiedades this.browser o this.server aquí,
    // ya que usaremos directamente la instancia 'supabase' importada para operaciones de cliente.

    async getSession(): Promise<AuthSession | null> {
        const { data, error } = await supabase.auth.getSession();
        if (error) {
            console.error("Error getting session:", error);
            return null;
        }
        return data.session;
    }

    onAuthStateChange(
        cb: (event: AuthChangeEvent, session: AuthSession | null) => void
    ): { data: { unsubscribe(): void } } {
        const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
            // El 'event' de Supabase puede ser diferente al 'AuthClientChangeEvent' si lo definiste distinto.
            // Asumimos que son compatibles o que AuthChangeEvent es un alias de Supabase['AuthChangeEvent']
            cb(event as AuthChangeEvent, session as AuthSession | null);
        });
        return { data: { unsubscribe: () => subscription.unsubscribe() } };
    }

    async signIn(email: string, password: string): Promise<SignInResponse> {
        const { data, error } = await supabase.auth.signInWithPassword({ email, password });
        if (error) {
            return { error };
        }
        // Aseguramos que la estructura de retorno coincida con SignInResponse
        return {
            data: data ? { session: data.session as AuthSession, user: data.user as User } : null,
        };
    }

    async signOut(): Promise<void> {
        const { error } = await supabase.auth.signOut();
        if (error) {
            console.error("Error signing out:", error);
            // Podrías decidir lanzar el error o manejarlo aquí
        }
    }

    async resetPassword(email: string): Promise<ResetPasswordResponse> {
        const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
            // redirectTo: 'tu-url-de-reset-password-si-es-diferente-a-la-configurada-en-supabase'
        });
        return { data, error };
    }

    async signUp(email: string, password: string, role = 'owner'): Promise<SignUpResponse> {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: { role },
                // emailRedirectTo: 'tu-url-de-verificacion-de-email-si-es-diferente'
            },
        });
        // Aseguramos que la estructura de retorno coincida con SignUpResponse
        return {
            data: data ? { user: data.user as User | null, /* session: data.session as AuthSession | null */ } : { user: null },
            error,
        };
    }

    async setSession(session: { access_token: string; refresh_token: string }): Promise<void> {
        const { error } = await supabase.auth.setSession(session);
        if (error) {
            console.error("Error setting session:", error);
            // Podrías decidir lanzar el error o manejarlo aquí
        }
    }
} 
----- Archivo: middleware.ts ----- 
// src/lib/auth/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse
} 
----- Archivo: serverClient.ts ----- 
// lib/auth/supabase/serverClient.ts
import { createServerClient as supabaseCreateServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

// Cliente Supabase para Server Components, API Routes y Middleware
export async function createServerClient() {
  const cookieStore = await cookies(); // Obtiene la instancia de cookies de Next.js

  return supabaseCreateServerClient( // Usa la función importada directamente
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        // El método `get` toma el nombre de la cookie y devuelve su valor o undefined.
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        // El método `set` toma el nombre, valor y opciones de la cookie.
        set(name: string, value: string, options: CookieOptions) {
          try {
            // `cookieStore.set` puede tomar un objeto o argumentos separados.
            // La versión más reciente de Next.js prefiere un objeto.
            cookieStore.set({ name, value, ...options });
          } catch (error) {
            // Esto puede ocurrir si `set` se llama desde un Server Component.
            // Se puede ignorar si tienes un middleware refrescando las sesiones.
            // (Como es tu caso, esta captura está bien).
            console.warn(`ServerClient: Failed to set cookie ${name} from a Server Component context. Error: ${error}`);
          }
        },
        // El método `remove` toma el nombre y opciones de la cookie.
        // Para eliminar una cookie, se suele establecer un valor vacío y una fecha de expiración pasada.
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options });
          } catch (error) {
            // Similar a `set`, esto puede ocurrir en Server Components.
            console.warn(`ServerClient: Failed to remove cookie ${name} from a Server Component context. Error: ${error}`);
          }
        },
      },
    }
  );
} 
----- Archivo: browserClient.tsx ----- 
// lib/auth/supabase/browserClient.ts
import { createBrowserClient } from '@supabase/ssr';

export const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  { // Añadir opciones explícitas
    auth: {
      persistSession: true, // Forzar la persistencia, aunque es el default
      autoRefreshToken: true, // Default, bueno tenerlo explícito
      // detectSessionInUrl: true, // Default, para manejar tokens en hash de URL
    }
  }
); 
----- Archivo: basicData.repository.ts ----- 
// src/repositories/basicData.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { BasicDataType } from '@/types/index';

export default class BasicDataRepository {
  static async upsert(basicData: BasicDataType) {
    const { data, error } = await supabase.from('basic_data')
      .upsert(basicData, { onConflict: 'pet_id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  static async findByPetId(pet_id: string): Promise<BasicDataType | null> {
    const { data, error } = await supabase.from('basic_data').select('*').eq('pet_id', pet_id);
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  static async update(data: BasicDataType) {
    return supabase.from('basic_data').update(data).eq('pet_id', data.pet_id);
  }
}
 
----- Archivo: condition.repository.ts ----- 
// src/repositories/condition.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { ConditionDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class ConditionRepository implements FormRepository<ConditionDataType> {
    async createAll(conditions: ConditionDataType[]) {
        const { data, error } = await supabase
            .from('conditions')
            .upsert(conditions, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<ConditionDataType[] | null> {
        const { data, error } = await supabase.from('conditions').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('conditions').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch(err) {
            console.log(err);
            return false;
        }
    }
}
 
----- Archivo: consultation.repository.ts ----- 
// src/repos/consultation.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { ConsultationType, CreateConsultationPayload } from '@/types/index';

export default class ConsultationRepository {
    static async create(payload: CreateConsultationPayload): Promise<{ data: ConsultationType | null; error: Error | null }> {
        // Separar los campos principales para el JSONB y los arrays
        const {
            pet_id, // Este va como parámetro separado
            veterinarian_id, // Este va como parámetro separado
            veterinary_access_id, // Este va como parámetro separado
            procedures, // Este va como parámetro de array separado
            medications, // Este va como parámetro de array separado
            ...consultation_data_fields // El resto va en el JSONB
        } = payload;

        // El objeto `consultation_data_fields` ya debería tener la estructura correcta
        // si `CreateConsultationPayload` se define adecuadamente.
        // Asegúrate de que las claves en `consultation_data_fields` coincidan con los
        // nombres de campo en tu `CREATE TYPE public.consultation_input_type AS (...)`.
        // Por ejemplo, si tu tipo tiene `consultation_date DATE`, tu objeto JS debe tener una clave `consultation_date`.

        // Sanitización: Asegurar que los campos opcionales que no se envían sean null,
        // y que los tipos de datos sean compatibles con lo que espera el tipo compuesto.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const mainConsultDataForRPC: { [key: string]: any } = {};
        const typeFields = [ // Lista de campos definidos en consultation_input_type
            'p_consultation_date', 'p_consultation_time', 'p_hc_number', 'p_institution_name',
            'p_reason_for_consultation', 'p_current_diet', 'p_previous_illnesses', 'p_previous_surgeries',
            'p_vaccination_history', 'p_last_deworming_product', 'p_recent_treatments', 'p_recent_travels',
            'p_animal_behavior_owner_description', 'p_lives_with_other_animals_details',
            'p_sterilized_status', 'p_birth_count', 'p_body_condition_score', 'p_temperature_celsius',
            'p_heart_rate_bpm', 'p_respiratory_rate_rpm', 'p_capillary_refill_time_sec', 'p_pulse_description',
            'p_mucous_membranes_description', 'p_hydration_percentage_description', 'p_sense_organs_description',
            'p_skin_and_coat_description', 'p_lymph_nodes_description', 'p_digestive_system_findings',
            'p_respiratory_system_findings', 'p_endocrine_system_findings', 'p_musculoskeletal_system_findings',
            'p_nervous_system_findings', 'p_urinary_system_findings', 'p_reproductive_system_findings',
            'p_rectal_palpation_findings', 'p_other_physical_findings', 'p_problem_list', 'p_master_problem_list',
            'p_differential_diagnoses', 'p_complementary_exams_summary', 'p_presumptive_diagnosis',
            'p_definitive_diagnosis', 'p_therapeutic_plan', 'p_prognosis', 'p_evolution_notes',
            'p_general_observations', 'p_signature_confirmation'
        ];

        for (const key of typeFields) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const value = (consultation_data_fields as any)[key.replace('p_', '')];
            if (value === undefined || value === '') {
                // Para campos numéricos o de fecha que son opcionales, un string vacío puede causar error en el CAST de SQL.
                // Es mejor enviar `null` si el campo es opcional y está vacío.
                if (['p_birth_count', 'p_body_condition_score', 'p_temperature_celsius', /* otros numéricos/fecha */].includes(key) && value === '') {
                    mainConsultDataForRPC[key] = null;
                } else if (value === undefined) {
                    mainConsultDataForRPC[key] = null;
                } else {
                    mainConsultDataForRPC[key] = value; // Mantener string vacío si el tipo SQL es TEXT y se permite
                }
            } else {
                mainConsultDataForRPC[key] = value;
            }
        }

        const proceduresForRPC = procedures?.map(p => ({
            procedure_name: p.procedure_name,
            description: p.description ?? null
        })) || [];

        const medicationsForRPC = medications?.map(m => ({
            medication_name: m.medication_name,
            dosage: m.dosage,
            frequency: m.frequency,
            duration_days: m.duration_days ?? null,
            notes: m.notes ?? null
        })) || [];

        const rpcParams = {
            p_pet_id: pet_id,
            p_veterinarian_id: veterinarian_id || null,
            p_veterinary_access_id: veterinary_access_id || null,
            p_consultation_main_data: mainConsultDataForRPC, 
            p_procedures: proceduresForRPC,
            p_medications: medicationsForRPC
        };

        try {
            console.log("Parámetros enviados a RPC insert_consultation_with_type:", JSON.stringify(rpcParams, null, 2));
            const { data, error } = await supabase.rpc('insert_consultation_with_type', rpcParams);

            if (error) throw error;

            return { data: data as ConsultationType, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.create (RPC call):', error);
            return { data: null, error: new Error(error.message || 'RPC call to insert_consultation_with_type failed') };
        }

    }

    // ... (tus otros métodos findByPetId, findById) ...
    static async findByPetId(petId: string): Promise<{ data: ConsultationType[] | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .from('consultations')
                .select(`
                *,
                procedures:consultation_procedures(*),
                medications:consultation_medications(*),
                files:consultation_files(*)
            `)
                .eq('pet_id', petId)
                .order('consultation_date', { ascending: false, nullsFirst: false })
                .order('consultation_time', { ascending: false, nullsFirst: false });


            if (error) throw error;
            return { data, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.findByPetId:', error);
            return { data: null, error };
        }
    }

    static async findById(consultationId: string): Promise<{ data: ConsultationType | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .from('consultations')
                .select(`
                *,
                procedures:consultation_procedures(*),
                medications:consultation_medications(*),
                files:consultation_files(*)
            `)
                .eq('id', consultationId)
                .single();

            if (error) throw error;
            return { data, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.findById:', error);
            return { data: null, error };
        }
    }
} 
----- Archivo: consultationFile.repository.ts ----- 
// src/repos/consultationFile.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { ConsultationFileType } from '@/types/index';

const CONSULTATION_FILES_BUCKET = 'consultation-files'; // Define tu bucket

export default class ConsultationFileRepository {
    static async uploadAndCreateRecord(
        consultationId: string,
        petId: string, // Necesario para la ruta del archivo
        file: File,
        uploadedByUserId?: string | null
    ): Promise<{ data: ConsultationFileType | null; error: Error | null }> {
        const fileName = `${file.name}`; // Podrías añadir un timestamp o UUID para unicidad
        const filePath = `${petId}/${consultationId}/${fileName}`;

        try {
            // 1. Subir archivo a Supabase Storage
            const { error: uploadError } = await supabase.storage
                .from(CONSULTATION_FILES_BUCKET)
                .upload(filePath, file);

            if (uploadError) throw uploadError;

            // 2. Crear registro en la tabla consultation_files
            const fileRecord: Omit<ConsultationFileType, 'id' | 'created_at'> = {
                consultation_id: consultationId,
                file_name: fileName,
                file_path: filePath,
                file_type: file.type,
                file_size_bytes: file.size,
                uploaded_by_user_id: uploadedByUserId || undefined,
            };

            const { data: dbData, error: dbError } = await supabase
                .from('consultation_files')
                .insert(fileRecord)
                .select()
                .single();

            if (dbError) {
                // Si falla la inserción en BD, intentar eliminar el archivo de Storage (rollback)
                await supabase.storage.from(CONSULTATION_FILES_BUCKET).remove([filePath]);
                throw dbError;
            }

            return { data: dbData, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.uploadAndCreateRecord:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string): Promise<{ data: ConsultationFileType[] | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .from('consultation_files')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }

    static async delete(fileId: string): Promise<{ error: Error | null }> {
        try {
            // 1. Obtener el path del archivo para eliminarlo de Storage
            const { data: fileRecord, error: findError } = await supabase
                .from('consultation_files')
                .select('file_path')
                .eq('id', fileId)
                .single();

            if (findError) throw findError;
            if (!fileRecord) throw new Error('File record not found for deletion.');

            // 2. Eliminar de la base de datos
            const { error: dbDeleteError } = await supabase
                .from('consultation_files')
                .delete()
                .eq('id', fileId);

            if (dbDeleteError) throw dbDeleteError;

            // 3. Eliminar de Supabase Storage
            const { error: storageDeleteError } = await supabase.storage
                .from(CONSULTATION_FILES_BUCKET)
                .remove([fileRecord.file_path]);

            // Incluso si la eliminación de storage falla, el registro en BD ya se fue.
            // Podrías loggear el error de storage.
            if (storageDeleteError) {
                console.warn('Failed to delete file from storage, but DB record removed:', storageDeleteError);
            }

            return { error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.delete:', error);
            return { error };
        }
    }

    /**
     * Genera una URL firmada para descargar un archivo.
     * La URL tiene un tiempo de expiración.
     */
    static async getSignedUrl(filePath: string, expiresInSeconds = 3600): Promise<{ signedURL: string | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .storage
                .from(CONSULTATION_FILES_BUCKET)
                .createSignedUrl(filePath, expiresInSeconds);

            if (error) throw error;
            return { signedURL: data?.signedUrl || null, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error creating signed URL:', error);
            return { signedURL: null, error };
        }
    }
} 
----- Archivo: consultationMedication.repository.ts ----- 
// src/repos/consultationMedication.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { ConsultationMedicationType } from '@/types/index';

export default class ConsultationMedicationRepository {
    static async createAll(
        consultationId: string,
        medications: Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>[]
    ): Promise<{ data: ConsultationMedicationType[] | null; error: Error | null }> {
        const medicationsToInsert = medications.map(med => ({
            ...med,
            consultation_id: consultationId,
        }));

        try {
            const { data, error } = await supabase
                .from('consultation_medications')
                .insert(medicationsToInsert)
                .select();

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.createAll:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string): Promise<{ data: ConsultationMedicationType[] | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .from('consultation_medications')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }
     static async delete(medicationId: string): Promise<{ error: Error | null }> {
        try {
            const { error } = await supabase
                .from('consultation_medications')
                .delete()
                .eq('id', medicationId);

            if (error) throw error;
            return { error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.delete:', error);
            return { error };
        }
    }
} 
----- Archivo: consultationProcedure.repository.ts ----- 
// src/repos/consultationProcedure.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { ConsultationProcedureType } from '@/types/index';

export default class ConsultationProcedureRepository {
    static async createAll(
        consultationId: string,
        procedures: Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>[]
    ): Promise<{ data: ConsultationProcedureType[] | null; error: Error | null }> {
        const proceduresToInsert = procedures.map(proc => ({
            ...proc,
            consultation_id: consultationId,
        }));

        try {
            const { data, error } = await supabase
                .from('consultation_procedures')
                .insert(proceduresToInsert)
                .select();

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.createAll:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string): Promise<{ data: ConsultationProcedureType[] | null; error: Error | null }> {
        try {
            const { data, error } = await supabase
                .from('consultation_procedures')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }

    static async delete(procedureId: string): Promise<{ error: Error | null }> {
        try {
            const { error } = await supabase
                .from('consultation_procedures')
                .delete()
                .eq('id', procedureId);

            if (error) throw error;
            return { error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.delete:', error);
            return { error };
        }
    }
} 
----- Archivo: index.ts ----- 
export { default as BasicDataRepository } from './basicData.repository';
export { default as ConditionRepository } from './condition.repository';
export { default as LabTestRepository } from './labTest.repository';
export { default as MedicineRepository } from './medicine.repository';
export { default as OwnerRepository } from './owner.repository';
export { default as PetRepository } from './pet.repository';
export { default as PetCodeRepository } from './petCode.repository';
export { default as PlanRepository } from './plan.repository';
export { default as SubscriptionRepository } from './subscription.repository';
export { default as SurgeryRepository } from './surgery.repository';
export { default as VaccineRepository } from './vaccine.repository';
export { default as VeterinaryAccessRepository } from './veterinaryAccess.repository';

export { default as ConsultationRepository } from './consultation.repository';
export { default as ConsultationProcedureRepository } from './consultationProcedure.repository';
export { default as ConsultationMedicationRepository } from './consultationMedication.repository';
export { default as ConsultationFileRepository } from './consultationFile.repository'; 
----- Archivo: labTest.repository.ts ----- 
// src/repositories/labTest.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { LabTestDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class LabTestRepository implements FormRepository<LabTestDataType> {
    async createAll(tests: LabTestDataType[]) {
        const { data, error } = await supabase
            .from('lab_tests')
            .upsert(tests, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<LabTestDataType[] | null> {
        const { data, error } = await supabase.from('lab_tests').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('lab_tests').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: medicine.repository.ts ----- 
// src/repositories/medicine.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { MedicineDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class MedicineRepository implements FormRepository<MedicineDataType> {
    async createAll(medicines: MedicineDataType[]) {
        const { data, error } = await supabase
            .from('medicines')
            .upsert(medicines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<MedicineDataType[] | null> {
        const { data, error } = await supabase.from('medicines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('medicines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: owner.repository.ts ----- 
// src/repositories/owner.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { OwnerDataType } from '@/types/index';

export default class OwnerRepository {
    static async create(owner: OwnerDataType) {
        return supabase.from('owners').insert(owner);
    }

    static async findById(owner_id: string): Promise<OwnerDataType | null> {
        if(owner_id == undefined){
            return null;
        }
        const { data, error } = await supabase.from('owners').select('*').eq('owner_id', owner_id);
        if (error) throw new Error(error.message);
        if (!data || data.length === 0) return null;
        return data[0];
    }

    static async update(owner: OwnerDataType) {
        return supabase.from('owners').update(owner).eq('owner_id', owner.owner_id);
    }

    static async delete(owner_id: string) {
        return supabase.from('owners').delete().eq('owner_id', owner_id);
    }
}
 
----- Archivo: pet.repository.ts ----- 
// src/repositories/pet.repository.ts
import { supabase } from "@/lib/auth/supabase/browserClient";
import { PetType } from "@/types/index";

export default class PetRepository {
  static async upsert(pet: PetType) {
    const { data, error } = await supabase.from('pets')
      .upsert(pet, { onConflict: 'id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  /** Busca la mascota por ID */
  static async findById(id: string): Promise<PetType> {
    const { data, error } = await supabase
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("id", id)
      .single();
    if (error) throw new Error(error.message);
    return data;
  }
  /** Busca la mascota por ID */
  static async existsById(id: string): Promise<boolean> {
    const { data, error } = await supabase
      .from("pets")
      .select("*", { count: 'exact', head: true })
      .eq("deleted", false)
      .eq("id", id);
    if (error) throw new Error(error.message);
    return data != null;
  }

  /** Actualiza campos de la mascota */
  static async updateById(
    id: string,
    updates: Partial<Pick<PetType, "image" | "name">>
  ): Promise<boolean> {
    const { data, error } = await supabase
      .from("pets")
      .update(updates)
      .eq("id", id);
    if (error) throw new Error(error.message);
    if (!data) return false;
    return true;
  }

  /** Verifica que el usuario loggeado y la mascota seleccionada se encuentren en la base de datos  */
  static async findByOwnerIdAndPetId(ownerId: string, pet_id: string): Promise<{ id: string } | null> {
    const { data, error } = await supabase
      .from("pets")
      .select("id")
      .eq("deleted", false)
      .eq("owner_id", ownerId)
      .eq("id", pet_id);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data[0];
  }

  /** Retorna la primera mascota del owner, o null */
  static async findByOwnerId(ownerId: string): Promise<PetType[]> {
    const { data, error } = await supabase
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("owner_id", ownerId);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return [];

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data ?? [];
  }

  /**
   * Marca una mascota como eliminada (soft delete).
   * @param id ID de la mascota a borrar
   * @returns true si la operación no falló
   */
  static async deleteById(id: string): Promise<boolean> {
    const now = new Date().toISOString();
    try {
      const { error } = await supabase
        .from("pets")
        .update({ deleted: true, deleted_at: now })
        .eq("id", id);

      if (error) {
        console.error("Error al eliminar mascota:", error);
        throw new Error(error.message);
      }
      return true;
    }
    catch {
      return false;
    }
  }
} 
----- Archivo: petCode.repository.ts ----- 
// src/repositories/petCode.repository.ts

import { supabase } from "@/lib/auth/supabase/browserClient";
import { PetCodeType } from "@/types/index";
import { Random } from "@/utils/index";

export default class PetCodeRepository {
  /** Busca un código activo */
  static async find(code: string): Promise<PetCodeType | null> {
    const { data, error } = await supabase
      .from("pet_codes")
      .select("*")
      .eq("code", code)
      .overrideTypes<PetCodeType[], { merge: false }>();
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  /** Invalida (marca used=true) todos los códigos previos de una mascota */
  static async invalidateAll(petId: string): Promise<void> {
    const { error } = await supabase
      .from("pet_codes")
      .delete()
      .eq("pet_id", petId);
    if (error) throw new Error(error.message);
  }

  /** Genera e inserta un nuevo código, devolviéndolo */
  static async create(
    petId: string,
    ttlMinutes: number
  ): Promise<string> {
    const code = Random.generateCode();
    const expiresAt = new Date(Date.now() + ttlMinutes * 60_000).toISOString();
    const { error } = await supabase
      .from("pet_codes")
      .insert({ pet_id: petId, code, expires_at: expiresAt });
    if (error) throw new Error(error.message);
    return code;
  }

  /** Marca un código como usado */
  static async markUsed(code: string): Promise<void> {
    const { error } = await supabase
      .from("pet_codes")
      .update({ used: true })
      .eq("code", code);
    if (error) throw new Error(error.message);
  }
}
 
----- Archivo: plan.repository.ts ----- 
// src/repositories/plan.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import { PlanVersionType } from '../types/index';

export default class PlanRepository {
  /**
   * Trae todas las versiones vigentes (effective_to IS NULL)
   */
  static async getAllCurrent(): Promise<PlanVersionType[]> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)

    if (error) throw error
    // Mapear para llevar slug al root
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return data.map((row: any) => ({
      ...row,
      slug: row.plans.slug
    }))
  }

  /**
   * Busca la versión actual de un plan por su slug
   */
  static async getBySlug(slug: string): Promise<PlanVersionType | null> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)
      .eq('plans.slug', slug)
      .overrideTypes<PlanVersionType[], { merge: false }>()

    if (error) {
      if (error.code === 'PGRST116') return null // sin datos
      throw error
    }

    return {
      ...data[0],
      slug: data[0].plans.slug
    }
  }

  /**
   * Trae todas las versiones históricas de un plan
   */
  static async getVersions(planId: number): Promise<PlanVersionType[]> {
    const { data, error } = await supabase
      .from('plans_versions')
      .select('*')
      .eq('plan_id', planId)
      .order('version', { ascending: false })

    if (error) throw error
    return data
  }
}
 
----- Archivo: subscription.repository.ts ----- 
// src/repositories/subscription.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import { CreateSubscriptionType, SubscriptionType } from '@/types/index';


export default class SubscriptionRepository {
    /**
     * Crea una suscripción en estado pending
     */
    static async create(params: CreateSubscriptionType): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .insert([{
                owner_id: params.ownerId,
                plan_version_id: params.planVersionId,
                cycle: params.cycle,
                status: 'pending',
                price_at_purchase: params.priceAtPurchase,
                discount_applied: params.discountApplied
            }])
            .select()

        if (error) throw error
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Obtiene la suscripción activa de un owner
     */
    static async getActiveByOwner(ownerId: string): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .select('*')
            .eq('owner_id', ownerId)
            .eq('status', 'active')

        if (error) {
            if (error.code === 'PGRST116') return null
            throw error
        }
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Lista todas las suscripciones de un owner
     */
    static async getByOwner(ownerId: string): Promise<SubscriptionType[] | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .select('*')
            .eq('owner_id', ownerId)
            .order('started_at', { ascending: false })

        if (error) throw error
        if (!data || data.length === 0) return null;
        return data
    }

    /**
     * Actualiza el estado y fechas de una suscripción
     */
    static async updateStatus(params: {
        subscriptionId: number
        status: 'active' | 'canceled' | 'expired'
        externalId?: string
        expiresAt?: string
    }): Promise<SubscriptionType | null> {
        const { data, error } = await supabase
            .from('subscriptions')
            .update({
                status: params.status,
                external_id: params.externalId,
                expires_at: params.expiresAt,
                updated_at: new Date().toISOString()
            })
            .eq('id', params.subscriptionId)
            .select()

        if (error) throw error

        if (!data || data.length === 0) return null;
        return data[0]
    }
}
 
----- Archivo: surgery.repository.ts ----- 
// src/repositories/surgery.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { SurgeryDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class SurgeryRepository implements FormRepository<SurgeryDataType> {
    async createAll(surgeries: SurgeryDataType[]) {
        const { data, error } = await supabase
            .from('surgeries')
            .upsert(surgeries, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<SurgeryDataType[] | null> {
        const { data, error } = await supabase.from('surgeries').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('surgeries').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: vaccine.repository.ts ----- 
// src/repositories/vaccine.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { VaccineDataType } from '@/types/index';
import { FormRepository } from '@/types/lib';

export default class VaccineRepository implements FormRepository<VaccineDataType> {
    async createAll(vaccines: VaccineDataType[]) {
        const { data, error } = await supabase
            .from('vaccines')
            .upsert(vaccines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string): Promise<VaccineDataType[] | null> {
        const { data, error } = await supabase.from('vaccines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string) {
        try {
            const currentTimestamp = new Date().toISOString();
            await supabase.from('vaccines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: veterinarian.repository.ts ----- 
// src/repositories/veterinarian.repository.ts
import { supabase } from '@/lib/auth/supabase/browserClient';
import type { VeterinarianType } from '@/types/index';

export default class VeterinarianRepository {
    /** Inserta un nuevo veterinario */
    static async create(vet: VeterinarianType) {
        return supabase.from('veterinarians').insert(vet);
    }

    /** Busca un veterinario por su ID */
    static async findById(vet_id: string): Promise<VeterinarianType | null> {
        if (!vet_id) return null;
        const { data, error } = await supabase
            .from('veterinarians')
            .select('*')
            .eq('vet_id', vet_id);
        if (error) throw new Error(error.message);
        return data && data.length > 0 ? data[0] : null;
    }

    /** Actualiza todos los campos de un veterinario */
    static async update(vet: VeterinarianType) {
        return supabase
            .from('veterinarians')
            .update(vet)
            .eq('vet_id', vet.vet_id);
    }

    /** Elimina un veterinario por su ID */
    static async delete(vet_id: string) {
        return supabase
            .from('veterinarians')
            .delete()
            .eq('vet_id', vet_id);
    }
}
 
----- Archivo: veterinaryAccess.repository.ts ----- 
// src/repositories/veterinaryAccess.repository.ts
import { supabase } from "@/lib/auth/supabase/browserClient";
import { VeterinaryAccessType } from "../types";
import PetCodeRepository from "./petCode.repository";

export default class VeterinaryAccessRepository {
    /** Registra un nuevo acceso de veterinario */
    static async create(access: Omit<
        VeterinaryAccessType,
        "id" | "created_at"
    >): Promise<VeterinaryAccessType> {
        const { data, error } = await supabase
            .from("veterinary_accesses")
            .insert(access)
            .select("*")
            .single();

        if (error) throw new Error(error.message);
        return data;
    }

    /** Obtiene datos de acceso por código (para validaciones o historial) */
    static async findByCodeAndByPetId(
        code: string,
        pet_id: string
    ): Promise<VeterinaryAccessType | null> {
        try {
            const petCode = await PetCodeRepository.find(code);
            if (!petCode) return null;
            const { data, error } = await supabase
                .from("veterinary_accesses")
                .select("*")
                .eq("pet_code_id", petCode.id)
                .eq("pet_id", pet_id)


            if (error) throw new Error(error.message);
            if (!data || data.length === 0) return null;
            return data[0];
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        catch (errCode: any) {
            if (errCode) throw new Error(errCode.message);
            return null;
        }

    }
}
 
----- Archivo: validationSchemas.ts ----- 
// src/schemas/validationSchemas.ts
import { z } from 'zod';

// PetType
export const PetTypeSchema = z.object({
  id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  image: z.string().nullable().optional(),
  owner_id: z.string(),
});

// PetCodeType
export const PetCodeTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  code: z.string(),
  used: z.boolean(),
  expires_at: z.string(),
});

// OwnerDataType
export const OwnerDataTypeSchema = z.object({
  owner_id: z.string(),
  name: z.string(),
  last_name: z.string(),
  phone: z.string(),
  address: z.string(),
  city: z.string(),
  country: z.string(),
  email: z.string(),
});

// BasicDataType
export const BasicDataTypeSchema = z.object({
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  pet_type: z.string(),
  gender: z.string(),
  weight: z.string(),
  race: z.string(),
  has_allergies: z.boolean(),
  weight_condition: z.string(),
  size: z.string(),
  lives_with_others: z.boolean(),
  main_food: z.string(),
  has_vaccine: z.boolean(),
  last_vaccine_name: z.string().optional().nullable(),
  last_vaccine_date: z.string().optional().nullable(),
  is_castrated: z.boolean(),
  castration_date: z.string().optional().nullable(),
  has_anti_flea: z.boolean(),
  anti_flea_date: z.string().optional().nullable(),
  uses_medicine: z.boolean(),
  special_condition: z.boolean(),
});

// InitialBasicDataType
export const InitialBasicDataTypeSchema = z.object({
  petType: z.string(),
  food: z.string(),
  race: z.string(),
  otherPetType: z.string(),
  otherFood: z.string(),
  otherRace: z.string(),
});

// VaccineDataType
export const VaccineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  description: z.string().optional().nullable(),
  date: z.string().optional().nullable(),
  batch: z.string(),
  brand: z.string(),
});

// SurgeryDataType
export const SurgeryDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  date: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
});

// MedicineDataType
export const MedicineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  dosage: z.string(),
  frequency: z.string(),
});

// ConditionDataType
export const ConditionDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  condition: z.string(),
  severity: z.string(),
});

// LabTestDataType
export const LabTestDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  type: z.string(),
  date: z.string().optional().nullable(),
  result: z.string().optional().nullable(),
});

// VeterinaryAccessType
export const VeterinaryAccessTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  pet_code_id: z.string(),
  vet_first_name: z.string(),
  vet_last_name: z.string(),
  professional_registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
  created_at: z.string(),
});

//Veterinarian
export const VeterinarianTypeSchema = z.object({
  vet_id: z.string().uuid(),
  first_name: z.string(),
  last_name: z.string(),
  email: z.string().email(),
  registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
});

// FeatureType
export const FeatureTypeSchema = z.object({
  text: z.string(),
  badge: z.string().optional(),
});

// PlanType
export const PlanTypeSchema = z.object({
  id: z.number(),
  slug: z.string(),
});

// PlanVersionType
export const PlanVersionTypeSchema = z.object({
  id: z.number(),
  plan_id: z.number(),
  slug: z.string(),
  version: z.number(),
  title: z.string(),
  description: z.string(),
  price_month: z.number(),
  price_year: z.number(),
  discount_month: z.number(),
  discount_year: z.number(),
  features: z.array(FeatureTypeSchema),
  effective_from: z.string(),
  effective_to: z.string().nullable(),
  plans: PlanTypeSchema,
});

// SubscriptionType
export const SubscriptionTypeSchema = z.object({
  id: z.number(),
  owner_id: z.string(),
  plan_version_id: z.number(),
  cycle: z.enum(['monthly', 'annual']),
  status: z.enum(['pending', 'active', 'canceled', 'expired']),
  external_id: z.string().nullable(),
  price_at_purchase: z.number(),
  discount_applied: z.number(),
  started_at: z.string(),
  expires_at: z.string().nullable(),
  updated_at: z.string(),
});


export const ConsultationProcedurePayloadSchema = z.object({
  procedure_name: z.string().min(1, "El nombre del procedimiento es requerido."),
  description: z.string().optional().nullable(),
  // No incluyas consultation_id aquí, se añade en el backend
});

export const ConsultationMedicationPayloadSchema = z.object({
  medication_name: z.string().min(1, "El nombre del medicamento es requerido."),
  dosage: z.string().min(1, "La dosis es requerida."),
  frequency: z.string().min(1, "La frecuencia es requerida."),
  duration_days: z.number().int().positive().optional().nullable(),
  notes: z.string().optional().nullable(),
});

export const CreateConsultationPayloadSchema = z.object({
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  consultation_date: z.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Fecha de consulta inválida.",
  }), // o z.date() si envías objetos Date
  reason_for_consultation: z.string().min(1, "El motivo de la consulta es requerido."),
  current_diet: z.string().optional().nullable(),
  previous_illnesses: z.string().optional().nullable(),
  previous_surgeries: z.string().optional().nullable(),
  vaccination_history: z.string().optional().nullable(), // Podría ser más estructurado
  last_deworming_product: z.string().optional().nullable(),
  recent_treatments: z.string().optional().nullable(),
  recent_travels: z.string().optional().nullable(),
  animal_behavior_owner_description: z.string().optional().nullable(),

  // Examen Físico General
  body_condition_score: z.number().min(1).max(5).optional().nullable(), // Asumiendo escala 1-5
  temperature_celsius: z.number().optional().nullable(),
  heart_rate_bpm: z.number().int().positive().optional().nullable(),
  respiratory_rate_rpm: z.number().int().positive().optional().nullable(),
  capillary_refill_time_sec: z.number().positive().optional().nullable(),
  mucous_membranes_description: z.string().optional().nullable(),
  hydration_percentage: z.number().min(0).max(100).optional().nullable(), // O descripción
  sense_organs_description: z.string().optional().nullable(),
  skin_and_coat_description: z.string().optional().nullable(),
  lymph_nodes_description: z.string().optional().nullable(),
  digestive_system_findings: z.string().optional().nullable(),
  respiratory_system_findings: z.string().optional().nullable(),
  endocrine_system_findings: z.string().optional().nullable(),
  musculoskeletal_system_findings: z.string().optional().nullable(),
  nervous_system_findings: z.string().optional().nullable(),
  urinary_system_findings: z.string().optional().nullable(),
  reproductive_system_findings: z.string().optional().nullable(),
  rectal_palpation_findings: z.string().optional().nullable(),
  other_physical_findings: z.string().optional().nullable(),

  // Abordaje Diagnóstico
  problem_list: z.string().optional().nullable(), // Podría ser un array de strings
  master_problem_list: z.string().optional().nullable(),
  differential_diagnoses: z.string().optional().nullable(), // Podría ser un array

  // Exámenes Complementarios (se manejan con subida de archivos, o podrían ser campos de texto)
  // Aquí solo información textual si no se suben archivos para todo
  complementary_exams_summary: z.string().optional().nullable(),

  presumptive_diagnosis: z.string().min(1, "El diagnóstico presuntivo es requerido."),
  definitive_diagnosis: z.string().optional().nullable(),
  therapeutic_plan: z.string().min(1, "El plan terapéutico es requerido."),
  prognosis: z.string().optional().nullable(),
  evolution_notes: z.string().optional().nullable(), // Para la evolución inicial si aplica
  general_observations: z.string().optional().nullable(),

  // Campos para identificar al veterinario, opcionales si se infieren de la sesión
  veterinarian_id: z.string().uuid("ID de veterinario inválido.").optional().nullable(),
  veterinary_access_id: z.string().uuid("ID de acceso veterinario inválido.").optional().nullable(),

  // Arrays para procedimientos y medicamentos que se crearán junto con la consulta
  procedures: z.array(ConsultationProcedurePayloadSchema).optional(),
  medications: z.array(ConsultationMedicationPayloadSchema).optional(),
}); 
----- Archivo: apiService.ts ----- 
import { QueryParamError, StepStateError, RepositoryError, ValidationResult } from "@/types/lib";
import { AuthError } from "@supabase/supabase-js";
import { NextRequest, NextResponse } from "next/server";
import { ZodSchema, ZodError } from "zod";

/** 
 * Envuelve la ejecución de un handler de API, capturando cualquier excepción
 * y devolviendo un 500 en caso de error interno.
 *
 * @param req    – el NextRequest que llega
 * @param handler– Función que ejecuta la lógica de negocio y devuelve un NextResponse
 */
export async function getWithErrorHandling(
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        return await handler()
    } catch (err: unknown) {
        console.error(`[GET] Error en ${req.url} —`, err);
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * Extrae un parámetro de query y lanza QueryParamError si no existe.
 */
export function getRequiredQueryParam(req: NextRequest, name: string): string {
    const value = req.nextUrl.searchParams.get(name)
    if (!value) {
        throw new QueryParamError(`${name} es requerido`)
    }
    return value
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withErrorHandling(
    method: string,
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 2) Lógica de negocio con body ya parseado
        return await handler();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withValidationAndErrorHandling<T>(
    method: string,
    req: NextRequest,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schema: ZodSchema<any>,
    handler: (data: T) => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 1) Validación del body
        const { data, error } = await validateBody(req, schema);
        if (error) {
            return error;
        }

        // 2) Lógica de negocio con body ya parseado
        return await handler(data);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Valida y parsea el body de la request según el esquema.
 * @param req NextRequest
 * @param schema ZodSchema que define la forma esperada
 * @returns Un objeto { data } si parseó bien, o { error } con NextResponse si falló.
 */
async function validateBody<T>(
    req: NextRequest,
    schema: ZodSchema<T>
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
): Promise<ValidationResult<any>> {
    try {
        const body = await req.json();
        if (Array.isArray(body)) {
            body.forEach((e: T) => {
                const parsed = schema.safeParse(e);
                if (!parsed.success) {
                    // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                        console.log(parsed.error);
                    return {
                        error: NextResponse.json(
                            {
                                success: false,
                                message: "Payload inválido",
                                errors: (parsed.error as ZodError).format(),
                            },
                            { status: 400 }
                        ),
                    };
                }
            });
        }
        else {
            const parsed = schema.safeParse(body);
            if (!parsed.success) {
                        console.log(parsed.error);
                // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                return {
                    error: NextResponse.json(
                        {
                            success: false,
                            message: "Payload inválido",
                            errors: (parsed.error as ZodError).format(),
                        },
                        { status: 400 }
                    ),
                };
            }
        }
        return { data: body };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        // JSON inválido u otro error de lectura
        return {
            error: NextResponse.json(
                { success: false, message: err.message || "No se pudo leer el body" },
                { status: 400 }
            ),
        };
    }
} 
----- Archivo: authService.ts ----- 
// src/services/authService.ts
import { StorageContextType } from "@/hooks/useAppStorage";
import { authClient } from '@/lib/auth';
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";

export const handleLogout = async (storage: StorageContextType, router: AppRouterInstance): Promise<void> => {
  try {
    await authClient.signOut();
  } catch (error) {
    console.error("Error during sign out in authService:", error);
  } finally {
    storage.resetSession();
    router.replace("/login");
    router.refresh();
  }
}; 
----- Archivo: emailService.ts ----- 
// src/services/emailService.ts

export interface SendEmailOptions {
  subject: string;
  text: string;
  from?: string;
  to?: string;
}

export async function sendEmail({ subject, text, from, to }: SendEmailOptions) {
  const MAILTRAP_URL = process.env.MAILTRAP_URL;
  const MAILTRAP_TOKEN = process.env.MAILTRAP_TOKEN;
  const MAILTRAP_FROM = from || process.env.MAILTRAP_FROM;
  const MAILTRAP_TO = to || process.env.MAILTRAP_TO;

  // Validación de configuración
  if (!MAILTRAP_URL || !MAILTRAP_TOKEN || !MAILTRAP_FROM || !MAILTRAP_TO) {
    throw new Error('Configuración de email incompleta');
  }

  // Envío de correo vía API
  const response = await fetch(MAILTRAP_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${MAILTRAP_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from: { email: MAILTRAP_FROM },
      to: [{ email: MAILTRAP_TO }],
      subject,
      text,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Error al enviar correo: ${response.status} - ${errorText}`);
  }
} 
----- Archivo: consultations.sql ----- 
-- 1. Tabla Principal de Consultas
CREATE TABLE consultations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pet_id varchar(4) NOT NULL REFERENCES pets(id) ON DELETE CASCADE, -- Si se borra la mascota, se borran sus consultas
    veterinarian_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Quién hizo la consulta (si es usuario vet)
    veterinary_access_id UUID REFERENCES veterinary_accesses(id) ON DELETE SET NULL, -- Si se usó código de acceso
    
    consultation_date DATE NOT NULL,
    consultation_time TIME WITHOUT TIME ZONE,
    hc_number TEXT,
    institution_name TEXT,

    -- Anamnesis
    reason_for_consultation TEXT NOT NULL,
    current_diet TEXT,
    previous_illnesses TEXT,
    previous_surgeries TEXT,
    vaccination_history TEXT,
    last_deworming_product TEXT,
    recent_treatments TEXT,
    recent_travels TEXT,
    animal_behavior_owner_description TEXT,
    lives_with_other_animals_details TEXT,
    sterilized_status TEXT CHECK (sterilized_status IN ('yes', 'no', 'unknown')),
    birth_count INTEGER,

    -- Examen Físico General
    body_condition_score NUMERIC(2,1), -- ej: 3.5
    temperature_celsius NUMERIC(4,1), -- ej: 38.5
    heart_rate_bpm INTEGER,
    respiratory_rate_rpm INTEGER,
    capillary_refill_time_sec NUMERIC(3,1),
    pulse_description TEXT,
    mucous_membranes_description TEXT,
    hydration_percentage_description TEXT,
    sense_organs_description TEXT,

    -- Examen Físico por Sistemas
    skin_and_coat_description TEXT,
    lymph_nodes_description TEXT,
    digestive_system_findings TEXT,
    respiratory_system_findings TEXT,
    endocrine_system_findings TEXT,
    musculoskeletal_system_findings TEXT,
    nervous_system_findings TEXT,
    urinary_system_findings TEXT,
    reproductive_system_findings TEXT,
    rectal_palpation_findings TEXT,
    other_physical_findings TEXT,

    -- Abordaje Diagnóstico
    problem_list TEXT,
    master_problem_list TEXT,
    differential_diagnoses TEXT,

    -- Exámenes Complementarios (Resumen textual)
    complementary_exams_summary TEXT,

    -- Diagnóstico y Plan
    presumptive_diagnosis TEXT NOT NULL,
    definitive_diagnosis TEXT,
    therapeutic_plan TEXT NOT NULL,
    prognosis TEXT,
    evolution_notes TEXT,
    general_observations TEXT,
    signature_confirmation TEXT,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT check_vet_responsible CHECK (veterinarian_id IS NOT NULL OR veterinary_access_id IS NOT NULL)
);

-- Trigger para actualizar 'updated_at'
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_consultations_modtime
    BEFORE UPDATE ON consultations
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

-- Índices
CREATE INDEX idx_consultations_pet_id ON consultations(pet_id);
CREATE INDEX idx_consultations_veterinarian_id ON consultations(veterinarian_id);
CREATE INDEX idx_consultations_veterinary_access_id ON consultations(veterinary_access_id);


-- 2. Tabla de Procedimientos de Consulta
CREATE TABLE consultation_procedures (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    procedure_name TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_procedures_consultation_id ON consultation_procedures(consultation_id);


-- 3. Tabla de Medicamentos de Consulta
CREATE TABLE consultation_medications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    medication_name TEXT NOT NULL,
    dosage TEXT NOT NULL,
    frequency TEXT NOT NULL,
    duration_days INTEGER,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_medications_consultation_id ON consultation_medications(consultation_id);


-- 4. Tabla de Archivos Adjuntos de Consulta
CREATE TABLE consultation_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL UNIQUE, -- Ruta en Supabase Storage, ej: 'pet_uuid/consultation_uuid/filename.pdf'
    file_type TEXT, -- MIME type
    file_size_bytes BIGINT,
    uploaded_by_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_files_consultation_id ON consultation_files(consultation_id);

-- Asegúrate de crear un BUCKET en Supabase Storage para los archivos, por ejemplo, 'consultation-files'
-- y configura sus políticas. Generalmente, el bucket es privado y se accede mediante URLs firmadas.

--- POLÍTICAS RLS (Row Level Security) ---

-- Habilitar RLS para cada tabla
ALTER TABLE consultations ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_procedures ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_medications ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_files ENABLE ROW LEVEL SECURITY;

-- Función auxiliar para verificar si el usuario actual es el dueño de la mascota asociada a una consulta
CREATE OR REPLACE FUNCTION is_pet_owner(p_consultation_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    is_owner BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM consultations c
        JOIN pets p ON c.pet_id = p.id
        WHERE c.id = p_consultation_id AND p.owner_id = auth.uid()
    ) INTO is_owner;
    RETURN is_owner;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; -- SECURITY DEFINER es importante para que pueda acceder a tablas necesarias

-- Función auxiliar para verificar si el veterinario actual creó la consulta o tiene acceso a través de veterinary_access
CREATE OR REPLACE FUNCTION veterinarian_has_access_to_consultation(p_consultation_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    has_access BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM consultations c
        WHERE c.id = p_consultation_id
          AND (
            c.veterinarian_id = auth.uid() -- Vet creó la consulta
            OR EXISTS ( -- Vet tiene un acceso activo para esta mascota (más complejo, simplificado aquí)
                SELECT 1
                FROM veterinary_accesses va
                WHERE va.id = c.veterinary_access_id
                  AND va.pet_id = c.pet_id
                  -- AND va.expires_at > NOW() -- (Si los códigos de acceso tienen expiración y el vet_access se liga al usuario)
                  -- Esta parte es más compleja si el acceso es por código y no por sesión de veterinario.
                  -- Si veterinary_access_id es solo una referencia al código usado, la validación del código
                  -- debe ocurrir en la capa de API antes de la inserción/actualización.
                  -- Para RLS de SELECT, podría ser suficiente si la API ya validó.
            )
          )
    ) INTO has_access;
    RETURN has_access;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Políticas para 'consultations'
CREATE POLICY "Owners can view their pets consultations"
    ON consultations FOR SELECT
    USING (is_pet_owner(id));

CREATE POLICY "Veterinarians can view consultations they are linked to"
    ON consultations FOR SELECT
    USING (veterinarian_has_access_to_consultation(id));

CREATE POLICY "Authenticated veterinarians can insert consultations"
    ON consultations FOR INSERT
    WITH CHECK (
        (auth.role() = 'authenticated') AND
        (
            -- El ID del veterinario en el payload coincide con el usuario autenticado Y el rol del usuario es 'veterinarian'
            (veterinarian_id = auth.uid() AND (SELECT raw_user_meta_data->>'role' FROM auth.users WHERE id = auth.uid()) = 'veterinarian')
            OR
            -- O se proporciona un veterinary_access_id válido (la validez del código en sí se manejaría en la API)
            (veterinary_access_id IS NOT NULL) -- La API debe validar que este access_id es legítimo para la mascota y el vet.
        )
    );
    
CREATE POLICY "Veterinarians can update consultations they created"
    ON consultations FOR UPDATE
    USING (veterinarian_id = auth.uid() AND (SELECT raw_user_meta_data->>'role' FROM auth.users WHERE id = auth.uid()) = 'veterinarian')
    WITH CHECK (veterinarian_id = auth.uid()); -- No pueden cambiar el vet_id a otro

-- DELETE: Nadie puede eliminar directamente (según requerimiento)
CREATE POLICY "Consultations are protected from direct deletion"
    ON consultations FOR DELETE
    USING (false); -- O más restrictivo: TO none;

-- Políticas para 'consultation_procedures', 'consultation_medications'
-- Asumimos que si puedes ver/editar la consulta, puedes ver/editar sus detalles.
CREATE POLICY "Users can manage procedures of consultations they have access to"
    ON consultation_procedures FOR ALL
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)); -- Re-evalúa RLS de la tabla 'consultations'

CREATE POLICY "Users can manage medications of consultations they have access to"
    ON consultation_medications FOR ALL
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id));

-- DELETE para procedures/medications: Solo si el veterinario que creó la consulta lo hace.
-- Esto podría ser más granular. Por ahora, si pueden actualizar la consulta, pueden borrar sub-items.
-- Podrías hacerla más restrictiva:
CREATE POLICY "Procedures can only be deleted by the creating veterinarian"
    ON consultation_procedures FOR DELETE
    USING (EXISTS (SELECT 1 FROM consultations c WHERE c.id = consultation_id AND c.veterinarian_id = auth.uid()));

CREATE POLICY "Medications can only be deleted by the creating veterinarian"
    ON consultation_medications FOR DELETE
    USING (EXISTS (SELECT 1 FROM consultations c WHERE c.id = consultation_id AND c.veterinarian_id = auth.uid()));


-- Políticas para 'consultation_files'
CREATE POLICY "Users can view files of consultations they have access to"
    ON consultation_files FOR SELECT
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)); -- Re-evalúa RLS

CREATE POLICY "Authenticated users (vets) can upload files to consultations they have access to"
    ON consultation_files FOR INSERT
    WITH CHECK (
        (auth.role() = 'authenticated') AND
        (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)) AND -- Implícitamente verifica acceso a consulta
        (uploaded_by_user_id = auth.uid()) -- Quien sube es el usuario actual
    );

CREATE POLICY "Users can delete files they uploaded"
    ON consultation_files FOR DELETE
    USING (uploaded_by_user_id = auth.uid());

-- Políticas de Supabase Storage para el bucket 'consultation-files' (Ejemplos conceptuales):
-- Estas se configuran en la UI de Supabase Storage, no directamente con SQL aquí.
-- 1. SELECT: Permitir a usuarios autenticados que tengan una RLS de SELECT en `consultation_files` para el `file_path` correspondiente.
   -- ( (bucket_id = 'consultation-files') AND (ROLE() = 'authenticated') AND (EXISTS (SELECT 1 FROM public.consultation_files WHERE consultation_files.file_path = storage.objectid((storage.objects.name)::text) AND auth.uid() = consultation_files.uploaded_by_user_id /* O reglas de acceso a la consulta */ )) )
-- 2. INSERT: Permitir a usuarios autenticados que puedan hacer INSERT en `consultation_files` y que `uploaded_by_user_id` sea su `auth.uid()`.
-- 3. UPDATE: Generalmente no se permite para evitar corrupción, se sube una nueva versión.
-- 4. DELETE: Permitir a usuarios autenticados que puedan hacer DELETE en `consultation_files` y que `uploaded_by_user_id` sea su `auth.uid()`.


GRANT REFERENCES (id) ON TABLE auth.users TO authenticated;

CREATE OR REPLACE FUNCTION create_consultation_secure(
    p_pet_id UUID,
    p_veterinarian_id UUID,
    p_reason TEXT
    -- ... otros parámetros ...
)
RETURNS UUID -- o el ID de la consulta creada
LANGUAGE plpgsql
SECURITY DEFINER -- ¡Importante!
-- SET search_path = public, auth; -- Asegura que los esquemas correctos estén en el path
AS $$
DECLARE
    new_consultation_id UUID;
BEGIN
    -- Aquí puedes añadir validaciones adicionales si es necesario,
    -- como verificar que p_veterinarian_id (si es auth.uid()) realmente es un veterinario.
    -- Esta validación es importante ya que la función se ejecuta con altos privilegios.

    INSERT INTO public.consultations (pet_id, veterinarian_id, reason_for_consultation /*, ...otros campos... */)
    VALUES (p_pet_id, p_veterinarian_id, p_reason /*, ...otros valores... */)
    RETURNING id INTO new_consultation_id;

    RETURN new_consultation_id;
END;
$$;

-- Luego, otorgas permiso de EXECUTE en esta función a los roles necesarios:
GRANT EXECUTE ON FUNCTION create_consultation_secure(UUID, UUID, TEXT) TO authenticated;

CREATE POLICY "Allow individual user access"
ON auth.users
FOR SELECT
USING (auth.uid() = id);

-- Tipo para los procedimientos que se pasarán como array
CREATE TYPE consultation_procedure_input AS (
    procedure_name TEXT,
    description TEXT
);

-- Tipo para los medicamentos que se pasarán como array
CREATE TYPE consultation_medication_input AS (
    medication_name TEXT,
    dosage TEXT,
    frequency TEXT,
    duration_days INTEGER,
    notes TEXT
);

CREATE TYPE consultation_input_type AS (
    p_consultation_date DATE,
    p_consultation_time TIME WITHOUT TIME ZONE,
    p_hc_number TEXT,
    p_institution_name TEXT,
    p_reason_for_consultation TEXT,
    p_current_diet TEXT,
    p_previous_illnesses TEXT,
    p_previous_surgeries TEXT,
    p_vaccination_history TEXT,
    p_last_deworming_product TEXT,
    p_recent_treatments TEXT,
    p_recent_travels TEXT,
    p_animal_behavior_owner_description TEXT,
    p_lives_with_other_animals_details TEXT,
    p_sterilized_status TEXT,
    p_birth_count INTEGER,
    p_body_condition_score NUMERIC,
    p_temperature_celsius NUMERIC,
    p_heart_rate_bpm INTEGER,
    p_respiratory_rate_rpm INTEGER,
    p_capillary_refill_time_sec NUMERIC,
    p_pulse_description TEXT,
    p_mucous_membranes_description TEXT,
    p_hydration_percentage_description TEXT,
    p_sense_organs_description TEXT,
    p_skin_and_coat_description TEXT,
    p_lymph_nodes_description TEXT,
    p_digestive_system_findings TEXT,
    p_respiratory_system_findings TEXT,
    p_endocrine_system_findings TEXT,
    p_musculoskeletal_system_findings TEXT,
    p_nervous_system_findings TEXT,
    p_urinary_system_findings TEXT,
    p_reproductive_system_findings TEXT,
    p_rectal_palpation_findings TEXT,
    p_other_physical_findings TEXT,
    p_problem_list TEXT,
    p_master_problem_list TEXT,
    p_differential_diagnoses TEXT,
    p_complementary_exams_summary TEXT,
    p_presumptive_diagnosis TEXT,
    p_definitive_diagnosis TEXT,
    p_therapeutic_plan TEXT,
    p_prognosis TEXT,
    p_evolution_notes TEXT,
    p_general_observations TEXT,
    p_signature_confirmation TEXT
);


-- Tipos para los inputs de arrays (si ya los tienes, no necesitas volver a crearlos)
-- CREATE TYPE consultation_procedure_input AS (...);
-- CREATE TYPE consultation_medication_input AS (...);

CREATE OR REPLACE FUNCTION insert_consultation_with_type(
    p_pet_id TEXT,
    p_veterinarian_id UUID, -- Puede ser NULL
    p_veterinary_access_id UUID, -- Puede ser NULL
    p_consultation_main_data consultation_input_type,
    p_procedures consultation_procedure_input[],
    p_medications consultation_medication_input[]
)
RETURNS JSON -- Devolvemos la consulta creada como JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    new_consultation_id UUID;
    full_consultation_json JSON;
    proc_input consultation_procedure_input;
    med_input consultation_medication_input;
BEGIN
    IF p_veterinarian_id IS NULL AND p_veterinary_access_id IS NULL THEN
        RAISE EXCEPTION 'Se requiere veterinarian_id o veterinary_access_id para crear una consulta.';
    END IF;

    INSERT INTO public.consultations (
        pet_id, veterinarian_id, veterinary_access_id,
        consultation_date, consultation_time, hc_number, institution_name,
        reason_for_consultation, current_diet, previous_illnesses, previous_surgeries,
        vaccination_history, last_deworming_product, recent_treatments, recent_travels,
        animal_behavior_owner_description, lives_with_other_animals_details,
        sterilized_status, birth_count, body_condition_score, temperature_celsius,
        heart_rate_bpm, respiratory_rate_rpm, capillary_refill_time_sec, pulse_description,
        mucous_membranes_description, hydration_percentage_description, sense_organs_description,
        skin_and_coat_description, lymph_nodes_description, digestive_system_findings,
        respiratory_system_findings, endocrine_system_findings, musculoskeletal_system_findings,
        nervous_system_findings, urinary_system_findings, reproductive_system_findings,
        rectal_palpation_findings, other_physical_findings, problem_list, master_problem_list,
        differential_diagnoses, complementary_exams_summary, presumptive_diagnosis,
        definitive_diagnosis, therapeutic_plan, prognosis, evolution_notes,
        general_observations, signature_confirmation
    ) VALUES (
        p_pet_id, p_veterinarian_id, p_veterinary_access_id,
        (p_consultation_main_data).p_consultation_date,
        (p_consultation_main_data).p_consultation_time,
        (p_consultation_main_data).p_hc_number,
        (p_consultation_main_data).p_institution_name,
        (p_consultation_main_data).p_reason_for_consultation,
        (p_consultation_main_data).p_current_diet,
        (p_consultation_main_data).p_previous_illnesses,
        (p_consultation_main_data).p_previous_surgeries,
        (p_consultation_main_data).p_vaccination_history,
        (p_consultation_main_data).p_last_deworming_product,
        (p_consultation_main_data).p_recent_treatments,
        (p_consultation_main_data).p_recent_travels,
        (p_consultation_main_data).p_animal_behavior_owner_description,
        (p_consultation_main_data).p_lives_with_other_animals_details,
        (p_consultation_main_data).p_sterilized_status,
        (p_consultation_main_data).p_birth_count,
        (p_consultation_main_data).p_body_condition_score,
        (p_consultation_main_data).p_temperature_celsius,
        (p_consultation_main_data).p_heart_rate_bpm,
        (p_consultation_main_data).p_respiratory_rate_rpm,
        (p_consultation_main_data).p_capillary_refill_time_sec,
        (p_consultation_main_data).p_pulse_description,
        (p_consultation_main_data).p_mucous_membranes_description,
        (p_consultation_main_data).p_hydration_percentage_description,
        (p_consultation_main_data).p_sense_organs_description,
        (p_consultation_main_data).p_skin_and_coat_description,
        (p_consultation_main_data).p_lymph_nodes_description,
        (p_consultation_main_data).p_digestive_system_findings,
        (p_consultation_main_data).p_respiratory_system_findings,
        (p_consultation_main_data).p_endocrine_system_findings,
        (p_consultation_main_data).p_musculoskeletal_system_findings,
        (p_consultation_main_data).p_nervous_system_findings,
        (p_consultation_main_data).p_urinary_system_findings,
        (p_consultation_main_data).p_reproductive_system_findings,
        (p_consultation_main_data).p_rectal_palpation_findings,
        (p_consultation_main_data).p_other_physical_findings,
        (p_consultation_main_data).p_problem_list,
        (p_consultation_main_data).p_master_problem_list,
        (p_consultation_main_data).p_differential_diagnoses,
        (p_consultation_main_data).p_complementary_exams_summary,
        (p_consultation_main_data).p_presumptive_diagnosis,
        (p_consultation_main_data).p_definitive_diagnosis,
        (p_consultation_main_data).p_therapeutic_plan,
        (p_consultation_main_data).p_prognosis,
        (p_consultation_main_data).p_evolution_notes,
        (p_consultation_main_data).p_general_observations,
        (p_consultation_main_data).p_signature_confirmation
    ) RETURNING id INTO new_consultation_id;

    IF p_procedures IS NOT NULL AND array_length(p_procedures, 1) > 0 THEN
        FOREACH proc_input IN ARRAY p_procedures LOOP
            INSERT INTO public.consultation_procedures (consultation_id, procedure_name, description)
            VALUES (new_consultation_id, proc_input.procedure_name, proc_input.description);
        END LOOP;
    END IF;

    IF p_medications IS NOT NULL AND array_length(p_medications, 1) > 0 THEN
        FOREACH med_input IN ARRAY p_medications LOOP
            INSERT INTO public.consultation_medications (consultation_id, medication_name, dosage, frequency, duration_days, notes)
            VALUES (new_consultation_id, med_input.medication_name, med_input.dosage, med_input.frequency, med_input.duration_days, med_input.notes);
        END LOOP;
    END IF;

    -- Devolver la consulta completa como JSON
    SELECT json_build_object(
        'id', c.id, 'pet_id', c.pet_id, 'veterinarian_id', c.veterinarian_id, 'veterinary_access_id', c.veterinary_access_id,
        'consultation_date', c.consultation_date, 'consultation_time', c.consultation_time, 'hc_number', c.hc_number, 'institution_name', c.institution_name,
        'reason_for_consultation', c.reason_for_consultation, 'current_diet', c.current_diet, 'previous_illnesses', c.previous_illnesses, 'previous_surgeries', c.previous_surgeries,
        'vaccination_history', c.vaccination_history, 'last_deworming_product', c.last_deworming_product, 'recent_treatments', c.recent_treatments, 'recent_travels', c.recent_travels,
        'animal_behavior_owner_description', c.animal_behavior_owner_description, 'lives_with_other_animals_details', c.lives_with_other_animals_details,
        'sterilized_status', c.sterilized_status, 'birth_count', c.birth_count, 'body_condition_score', c.body_condition_score, 'temperature_celsius', c.temperature_celsius,
        'heart_rate_bpm', c.heart_rate_bpm, 'respiratory_rate_rpm', c.respiratory_rate_rpm, 'capillary_refill_time_sec', c.capillary_refill_time_sec, 'pulse_description', c.pulse_description,
        'mucous_membranes_description', c.mucous_membranes_description, 'hydration_percentage_description', c.hydration_percentage_description, 'sense_organs_description', c.sense_organs_description,
        'skin_and_coat_description', c.skin_and_coat_description, 'lymph_nodes_description', c.lymph_nodes_description, 'digestive_system_findings', c.digestive_system_findings,
        'respiratory_system_findings', c.respiratory_system_findings, 'endocrine_system_findings', c.endocrine_system_findings, 'musculoskeletal_system_findings', c.musculoskeletal_system_findings,
        'nervous_system_findings', c.nervous_system_findings, 'urinary_system_findings', c.urinary_system_findings, 'reproductive_system_findings', c.reproductive_system_findings,
        'rectal_palpation_findings', c.rectal_palpation_findings, 'other_physical_findings', c.other_physical_findings, 'problem_list', c.problem_list, 'master_problem_list', c.master_problem_list,
        'differential_diagnoses', c.differential_diagnoses, 'complementary_exams_summary', c.complementary_exams_summary, 'presumptive_diagnosis', c.presumptive_diagnosis,
        'definitive_diagnosis', c.definitive_diagnosis, 'therapeutic_plan', c.therapeutic_plan, 'prognosis', c.prognosis, 'evolution_notes', c.evolution_notes,
        'general_observations', c.general_observations, 'signature_confirmation', c.signature_confirmation,
        'created_at', c.created_at, 'updated_at', c.updated_at,
        'procedures', (SELECT COALESCE(json_agg(cp), '[]'::json) FROM consultation_procedures cp WHERE cp.consultation_id = new_consultation_id),
        'medications', (SELECT COALESCE(json_agg(cm), '[]'::json) FROM consultation_medications cm WHERE cm.consultation_id = new_consultation_id),
        'files', '[]'::json
    )
    INTO full_consultation_json
    FROM consultations c
    WHERE c.id = new_consultation_id;

    RETURN full_consultation_json;

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error en create_consultation_secure: %', SQLERRM;
        RAISE;
END;
$$;

GRANT EXECUTE ON FUNCTION insert_consultation_with_type(
	TEXT, -- p_pet_id
    UUID, -- p_veterinarian_id
    UUID, -- p_veterinary_access_id
    consultation_input_type, -- p_consultation_data
    consultation_procedure_input[], -- p_procedures
    consultation_medication_input[]  -- p_medications
) TO authenticated; 
----- Archivo: pets.sql ----- 
create table public.pets (
  id            varchar(4)                           not null
                   constraint pets_pk
                     primary key,
  -- enforce format like A001, B123, etc.
  constraint pets_id_format
    check (id ~ '^[A-Za-z]\d{3}$'),

  owner_id      uuid                                 not null
                   references auth.users (id)
                     on delete cascade,

  name          text                                 not null,
  species       text,
  breed         text,
  birth_date    date,

  created_at    timestamp with time zone default now()  not null,
  updated_at    timestamp with time zone default now()  not null
);

-- trigger to auto-update updated_at on row modification
create function update_updated_at_column()
  returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger trigger_update_pets_updated_at
  before update
  on public.pets
  for each row
  execute procedure update_updated_at_column(); 
----- Archivo: pet_codes.sql ----- 
-- Puedes ejecutarlo en el SQL editor de Supabase
create table public.pet_codes (
  id          uuid        default uuid_generate_v4() primary key,
  pet_id      varchar     not null references public.pets(id),
  code        varchar     not null unique,
  expires_at  timestamp   not null,
  used        boolean     not null default false,
  created_at  timestamp   not null default now()
);
 
----- Archivo: plans.sql ----- 
-- --------------------------------------------------
-- 2. Master de Planes
-- --------------------------------------------------
create table if not exists public.plans (
  id    serial      primary key,
  slug  text        not null unique    -- por ej: 'free','standard','advanced','lifetime'
);

-- --------------------------------------------------
-- 3. Versiones de Planes
-- --------------------------------------------------
create table if not exists public.plans_versions (
  id             serial      primary key,
  plan_id        integer     not null
    references public.plans(id) on delete cascade,
  version        integer     not null,
  title          text        not null,
  description    text,
  price_month    integer     not null,   -- en dolares
  price_year     integer     not null,
  discount_month integer     not null default 0,   -- % de descuento mensual aplicado
  discount_year  integer     not null default 0,   -- % de descuento anual aplicado
  features       jsonb       not null,   -- lista de strings o { text, badge }
  effective_from timestamptz default now(),
  effective_to   timestamptz
);

-- índice para evitar versiones duplicadas
create unique index if not exists idx_plans_versions_unique
  on public.plans_versions(plan_id, version);

-- --------------------------------------------------
-- 4. Suscripciones de Owners a PlanVersions
-- --------------------------------------------------
create table if not exists public.subscriptions (
  id                  serial      primary key,
  owner_id            uuid        not null
    references public.owners(owner_id) on delete cascade,
  plan_version_id     integer     not null
    references public.plans_versions(id) on delete restrict,
  cycle               text        not null
    check (cycle in ('monthly','annual')),
  status              text        not null
    check (status in ('pending','active','canceled','expired')),
  external_id         text,       -- id de transacción en Bold
  price_at_purchase   integer     not null,   -- snapshot del precio al momento
  discount_applied    integer     not null default 0,
  started_at          timestamptz default now(),
  expires_at          timestamptz,
  updated_at          timestamptz default now()
);

-- --------------------------------------------------
-- 5. Opcional: RLS para que cada owner solo vea sus suscripciones
-- --------------------------------------------------
alter table public.subscriptions
  enable row level security;

create policy "Owners can view own subscriptions"
  on public.subscriptions for select
  using ( owner_id = auth.uid() );

create policy "Owners can insert subscriptions"
  on public.subscriptions for insert
  with check ( owner_id = auth.uid() );

create policy "Owners can update own subscriptions"
  on public.subscriptions for update
  using ( owner_id = auth.uid() )
  with check ( owner_id = auth.uid() );
  
  
  -- --------------------------------------------------
-- 6. Inserción de datos iniciales en public.plans y public.plans_versions
-- --------------------------------------------------

-- 1. Insertar los slugs maestros en public.plans
INSERT INTO public.plans (slug)
VALUES
  ('free'),
  ('standard'),
  ('advanced'),
  ('lifetime');

-- 2. Insertar la versión 1 de cada plan en public.plans_versions

-- 2.1 Plan gratuito
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'free'),
  1,
  'Modelo Gratuito',
  'Para personas nuevas y con necesidades básicas de gestión de Historias clínicas para tu mascota',
  0,
  0,
  0,
  0,
  '[
    {"text":"1 perfil de mascota"},
    {"text":"Carga de examenes hasta 500MB"},
    {"text":"Información de contacto"},
    {"text":"Acceso a la APP"},
    {"text":"Plataforma de gestión para tu VET"},
    {"text":"Seguridad de doble factor"}
  ]'::jsonb
);

-- 2.2 Plan estándar
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'standard'),
  1,
  'Modelo estándar',
  'Especial para quienes tienen más de una mascota y quieren utilizar todos nuestros servicios.',
  500,    -- $5.00 USD en centavos
  5400,   -- $54.00 USD en centavos
  0,
  10,     -- 10% de descuento
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Perfiles de 3 mascotas"},
    {"text":"Carga de examenes sin límites"},
    {"text":"Función de pérdida de mascota"},
    {"text":"Múltiples sesiones activas en la app"},
    {"text":"Soporte personalizado"},
    {"text":"Plan de recomendados"},
    {"text":"Descargas de copias de historial"},
    {"text":"Lectura en múltiples idiomas","badge":"Pronto"}
  ]'::jsonb
);

-- 2.3 Plan avanzado
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'advanced'),
  1,
  'Modelo avanzado',
  'Diseñado para quien tiene más de una mascota y quiere agregar collares a la suscripción.',
  900,    -- $9.00 USD en centavos
  8640,   -- $86.40 USD en centavos
  0,
  20,     -- 20% de descuento
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Todas las funciones del plan estándar"},
    {"text":"Perfiles de mascotas ilimitados"},
    {"text":"Plan de recomendados plus"},
    {"text":"Hasta 5 Tags información"},
    {"text":"IA de pre-diagnóstico","badge":"Coming Soon"},
    {"text":"Sistema de alertas","badge":"Coming Soon"}
  ]'::jsonb
);

-- 2.4 Plan vitalicio
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'lifetime'),
  1,
  'Vitalicio',
  'OFERTA ÚNICA POR TIEMPO LIMITADO SOLO VÁLIDO PARA LOS PRIMEROS 1000 USUARIOS',
  15000,  -- $150.00 USD en centavos
  15000,  -- $150.00 USD en centavos
  0,
  0,
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Todas las funciones del plan estándar"},
    {"text":"Todas las funciones del plan avanzado"},
    {"text":"Hasta 10 Tags información"},
    {"text":"Acceso a nuestra versión Beta"},
    {"text":"Recibes nuevas funcionalidades antes"},
    {"text":"Descuentos únicos en LAMPO"},
    {"text":"Ingreso a nuestro plan fundadores"}
  ]'::jsonb
);
 
----- Archivo: tables.sql ----- 
-- 1) Habilitar extensión para UUID si no está
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 2) Tabla de dueños
CREATE TABLE owners (
  owner_id UUID PRIMARY KEY,
  name        TEXT    NOT NULL,
  phone       TEXT    NOT NULL,
  address     TEXT    NOT NULL,
  city        TEXT    NOT NULL,
  country     TEXT    NOT NULL,
  email       TEXT    NOT NULL UNIQUE
);

-- 3) Tabla de datos básicos de la mascota
CREATE TABLE basic_data (
  pet_id            TEXT      PRIMARY KEY REFERENCES pets(id) ON DELETE CASCADE,
  pet_type          TEXT      NOT NULL,
  gender            TEXT      NOT NULL,
  weight            TEXT      NOT NULL,
  race              TEXT      NOT NULL,
  has_allergies     BOOLEAN   NOT NULL,
  weight_condition  TEXT      NOT NULL,
  size              TEXT      NOT NULL,
  lives_with_others BOOLEAN   NOT NULL,
  main_food         TEXT      NOT NULL,
  has_vaccine       BOOLEAN   NOT NULL,
  last_vaccine_name TEXT,
  last_vaccine_date TIMESTAMP,
  is_castrated      BOOLEAN   NOT NULL,
  castration_date   TIMESTAMP,
  has_anti_flea     BOOLEAN   NOT NULL,
  anti_flea_date    TIMESTAMP,
  uses_medicine     BOOLEAN   NOT NULL,
  special_condition BOOLEAN   NOT NULL
);

-- 4) Vacunas
CREATE TABLE vaccines (
  id          UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id      TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name        TEXT      NOT NULL,
  description TEXT,
  date        TIMESTAMP,
  batch       TEXT      NOT NULL,
  brand       TEXT      NOT NULL
);

-- 5) Cirugías
CREATE TABLE surgeries (
  id          UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id      TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name        TEXT      NOT NULL,
  date        TIMESTAMP,
  description TEXT
);

-- 6) Medicinas
CREATE TABLE medicines (
  id        UUID    PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id    TEXT    REFERENCES pets(id) ON DELETE CASCADE,
  name      TEXT    NOT NULL,
  dosage    TEXT    NOT NULL,
  frequency TEXT    NOT NULL
);

-- 7) Condiciones especiales
CREATE TABLE conditions (
  id        UUID    PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id    TEXT    REFERENCES pets(id) ON DELETE CASCADE,
  condition TEXT    NOT NULL,
  severity  TEXT    NOT NULL
);

-- 8) Exámenes de laboratorio
CREATE TABLE lab_tests (
  id     UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name   TEXT      NOT NULL,
  type   TEXT      NOT NULL,
  date   TIMESTAMP,
  result TEXT
);


-- Owners
INSERT INTO owners(owner_id, name, phone, address, city, country, email) VALUES
  ('8933eed8-daea-4e6c-b4db-44906b9f44f9','Andrés Aulestia','+57 3146061490','Cra. 74 #152b-70 Torre 3 Apto. 1704','Bogotá','Colombia','a.aulestia@exe.com.co'),
  ('41095adf-27a6-48f8-ada1-d8c7d3dd265a','Johnnatan Ruiz','+57 3112849616','Calle 82 #19A-29 Apt 401','Bogotá','Colombia','excellent.exeqtion@gmail.com');

-- Basic data
INSERT INTO basic_data(
  pet_id, pet_type, gender, weight, race, has_allergies,
  weight_condition, size, lives_with_others, main_food,
  has_vaccine, last_vaccine_name, last_vaccine_date,
  is_castrated, castration_date, has_anti_flea, anti_flea_date,
  uses_medicine, special_condition
) VALUES
  (
    'A001','Gato','Macho','5.5 Kg','Mestizo',false,
    'Normal','Mediano',false,'Taste the Wild',
    true,'Parvigen','2024-07-25',
    true,'2023-12-02',true,'2023-12-15',
    false,false
  ),
  (
    'A002','Perro','Macho','7 Kg','Criollo',false,
    'Normal','Mediano',true,'Pro Plan',
    false,NULL,NULL,
    true,'2023-06-30',false,NULL,
    false,false
  ),
  (
    'A003','Perro','Macho','9 Kg','Criollo',true,
    'Normal','Mediano',true,'Vet Life',
    false,NULL,NULL,
    true,'2019-05-03',false,NULL,
    false,true
  );

-- Vacunas
INSERT INTO vaccines(pet_id, name, description, date, batch, brand) VALUES
  ('A001','Rabia','Vacuna contra la rabia','2025-03-15','RAB12345','Nobivac'),
  ('A001','Parvovirus','Prevención de parvovirus','2025-02-10','PARV67890','Canigen'),
  ('A002','Parvovirus','Prevención de parvovirus','2025-02-10','PARV67890','Canigen');

-- Cirugías
INSERT INTO surgeries(pet_id, name, date, description) VALUES
  ('A001','Castración','2024-11-20','Castración preventiva'),
  ('A001','Extracción dental','2024-12-05','Tooth extraction'),
  ('A002','Castración','2023-06-30','Castración preventiva'),
  ('A003','Castración','2019-05-03','Castración preventiva');

-- Medicinas
INSERT INTO medicines(pet_id, name, dosage, frequency) VALUES
  ('A001','Antibiótico X','250mg','Cada 12 horas'),
  ('A001','Vitamina C','100mg','Diaria');

-- Condiciones especiales
INSERT INTO conditions(pet_id, condition, severity) VALUES
  ('A001','Esterilidad aórtica','Moderada'),
  ('A001','Alergia alimentaria','Leve'),
  ('A003','Insuficiencia renal','Leve');

-- Exámenes de laboratorio
INSERT INTO lab_tests(pet_id, name, type, date, result) VALUES
  ('A001','Hemograma completo','Blood','2025-01-10','Normal'),
  ('A001','Ultrasonido abdominal','Ultrasound','2024-12-22','Sin hallazgos');
 
----- Archivo: veterinarians.sql ----- 
-- migrations/20250529_create_veterinarians.sql

create table if not exists veterinarians (
  vet_id uuid primary key,
  first_name text not null,
  last_name text not null,
  email text not null,
  registration text not null,
  clinic_name text not null,
  city text not null,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- (Opcional) Trigger para actualizar updated_at en cada modificación
create or replace function set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_veterinarians_updated_at on veterinarians;
create trigger trg_veterinarians_updated_at
  before update on veterinarians
  for each row execute function set_updated_at();
 
----- Archivo: veterinary_access.sql ----- 
-- Crear entidad para registrar accesos de veterinarios
create table if not exists veterinary_accesses (
  id uuid primary key default gen_random_uuid(),
  pet_id uuid not null references pets(id) on delete cascade,
  pet_code_id uuid not null references pet_codes(id),
  vet_first_name text not null,
  vet_last_name text not null,
  professional_registration text not null,
  clinic_name text not null,
  city text not null,
  created_at timestamp with time zone default now()
);

-- Índice para optimizar búsquedas por código
create index if not exists idx_vet_accesses_code on veterinary_accesses(code); 
----- Archivo: geist.ts ----- 
import { Geist, Geist_Mono } from "next/font/google";

export const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
export const geistMono = Geist_Mono({ variable: "--font-geist-mono", subsets: ["latin"] }); 
----- Archivo: tooltip.ts ----- 
// app/css/tooltip.tsx
export const tooltipStyles =
  `
        .tooltip-container {
          position: relative;
          display: inline-block;
        }
        .tooltip-container .tooltip-text {
          visibility: hidden;
          width: max-content;
          background-color: white;
          color:rgb(1, 114, 173);
          border: 1px solid rgb(1, 114, 173);
          text-align: center;
          padding: 4px 8px;
          border-radius: 4px;
          position: absolute;
          font-size: 0.75rem;
          white-space: nowrap;
          z-index: 1600;
          font-weight: bold;
          opacity: 0;
        }
        .tooltip-left {
          top: 18%;
          right: 100%;
          margin-right: 0.5rem;
          transition: opacity 0.2s !important;
        }
        .tooltip-right {
          left: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-left: 0.5rem;
        }
        .tooltip-container:hover .tooltip-text {
          visibility: visible;
          opacity: 1;
        }
      `; 
----- Archivo: veterinary.ts ----- 
// app/css/veterinary.tsx
export const veterinaryStyles =
`
        .overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2000;
        }
        .modal {
          background: #fff;
          border-radius: 1rem;
          padding: 2rem;
          width: 90%;
          max-width: 400px;
          position: relative;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .close-btn {
          position: absolute;
          top: 0.5rem;
          right: 0.5rem;
          background: none;
          border: none;
          font-size: 1.25rem;
          color: #333;
          cursor: pointer;
        }
        .label {
          font-size: 1.1rem;
          margin-bottom: 0.5rem;
          color: #333;
        }
        .input-code {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          border: 1px solid #ccc;
          border-radius: 0.25rem;
          text-transform: uppercase;
          margin-bottom: 1rem;
          transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-code:focus {
          outline: none;
          border-color: #007bff;
          box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2);
        }
        .error {
          color: #dc3545;
          font-size: 0.875rem;
          margin-bottom: 1rem;
        }
        .submit-btn {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          background-color: #007bff;
          color: #fff;
          border: none;
          border-radius: 0.25rem;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        .submit-btn:disabled {
          background-color: #6c757d;
          cursor: not-allowed;
        }
        .submit-btn:not(:disabled):hover {
          background-color: #0056b3;
        }
      `; 
----- Archivo: index.ts ----- 
export interface PetType {
    id: string;
    name: string;
    image?: string | null;
    owner_id: string;
}
export interface PetCodeType {
    id: string;
    pet_id: string;
    code: string;
    used: boolean;
    expires_at: string;
}
export interface OwnerDataType {
    owner_id: string;
    name: string;
    last_name: string;
    phone: string;
    address: string;
    city: string;
    country: string;
    email: string;
}
export interface BasicDataType {
    pet_id: string;
    pet_type: string;
    gender: string;
    weight: string;
    race: string;
    has_allergies: boolean;
    weight_condition: string;
    size: string;
    lives_with_others: boolean;
    main_food: string;
    has_vaccine: boolean;
    last_vaccine_name?: string;
    last_vaccine_date?: Date;
    is_castrated: boolean;
    castration_date?: Date;
    has_anti_flea: boolean;
    anti_flea_date?: Date;
    uses_medicine: boolean;
    special_condition: boolean;
}
export interface InitialBasicDataType {
    petType: string,
    food: string,
    race: string,
    otherPetType: string,
    otherFood: string,
    otherRace: string
}
export interface VaccineDataType {
    id: string;
    pet_id: string;
    name: string;
    description?: string;
    date?: Date;
    batch: string;
    brand: string;
}
export interface SurgeryDataType {
    id: string;
    pet_id: string;
    name: string;
    date?: Date;
    description?: string;
}
export interface MedicineDataType {
    id: string;
    pet_id: string;
    name: string;
    dosage: string;
    frequency: string;
}
export interface ConditionDataType {
    id: string;
    pet_id: string;
    condition: string;
    severity: string;
}
export interface LabTestDataType {
    id: string;
    pet_id: string;
    name: string;
    type: string;
    date?: Date;
    result?: string;
}
export interface VeterinaryAccessType {
    id: string;
    pet_id: string;
    pet_code_id: string;
    vet_first_name: string;
    vet_last_name: string;
    professional_registration: string;
    clinic_name: string;
    city: string;
}

export interface VeterinarianType {
    vet_id: string;
    first_name: string;
    last_name: string;
    email: string;
    registration: string;
    clinic_name: string;
    city: string;
}

export interface FeatureType {
    text: string;
    badge?: string;
}
export interface PlanType {
    id: number;
    slug: string;
}
export interface PlanVersionType {
    id: number;
    plan_id: number;
    slug: string;
    version: number;
    title: string;
    description: string;
    price_month: number;
    price_year: number;
    discount_month: number;
    discount_year: number;
    features: FeatureType[];
    effective_from: string;
    effective_to: string | null;
    plans: PlanType;
}
export interface SubscriptionType {
    id: number;
    owner_id: string;
    plan_version_id: number;
    cycle: 'monthly' | 'annual';
    status: 'pending' | 'active' | 'canceled' | 'expired';
    external_id: string | null;
    price_at_purchase: number;
    discount_applied: number;
    started_at: string;
    expires_at: string | null;
    updated_at: string;
}

export interface CreateSubscriptionType {
    ownerId: string;
    planVersionId: number;
    cycle: 'monthly' | 'annual';
    priceAtPurchase: number;
    discountApplied: number;
}

export enum PetStep {
    Name = 0,
    BasicData = 1,
    Vaccines = 2,
    Medicines = 3,
    LabTests = 4,
    Conditions = 5,
    Surgeries = 6
}

export interface ConsultationProcedureType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    procedure_name: string;
    description?: string | null;
    created_at: string; // timestamptz
}

export interface ConsultationMedicationType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    medication_name: string;
    dosage: string;
    frequency: string;
    duration_days?: number | null;
    notes?: string | null;
    created_at: string; // timestamptz
}

export interface ConsultationFileType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    file_name: string;
    file_path: string; // Path en Supabase Storage
    file_type?: string | null; // MIME type
    file_size_bytes?: number | null;
    uploaded_by_user_id?: string | null; // uuid, FK to auth.users (quien subió el archivo)
    created_at: string; // timestamptz
}

export interface ConsultationType {
    id: string; // uuid, PK
    pet_id: string; // uuid, FK to pets
    veterinarian_id?: string | null; // uuid, FK to auth.users (si es un vet con cuenta)
    veterinary_access_id?: string | null; // uuid, FK to veterinary_accesses (si se usó código)

    consultation_date: string; // date
    consultation_time?: string | null; // time
    hc_number?: string | null; // Número de historia clínica si aplica
    institution_name?: string | null; // Nombre de la clínica/institución

    // Anamnesis (basado en el formato)
    reason_for_consultation: string;
    current_diet?: string | null;
    previous_illnesses?: string | null;
    previous_surgeries?: string | null;
    vaccination_history?: string | null; // Podría ser un resumen, los detalles están en su propia sección
    last_deworming_product?: string | null;
    recent_treatments?: string | null;
    recent_travels?: string | null;
    animal_behavior_owner_description?: string | null;
    lives_with_other_animals_details?: string | null; // ej: "Sí, un perro y un gato"
    sterilized_status?: 'yes' | 'no' | 'unknown' | null; // o booleano si es más simple
    birth_count?: number | null;

    // Examen Físico General
    body_condition_score?: number | null; // Escala 1-5 o 1-9
    temperature_celsius?: number | null;
    heart_rate_bpm?: number | null; // FC
    respiratory_rate_rpm?: number | null; // FR
    capillary_refill_time_sec?: number | null; // TRPC / TLLC
    pulse_description?: string | null; // Descripción del pulso (fuerte, débil, rítmico)
    mucous_membranes_description?: string | null;
    hydration_percentage_description?: string | null; // Descripción o % estimado
    sense_organs_description?: string | null;

    // Examen Físico por Sistemas
    skin_and_coat_description?: string | null;
    lymph_nodes_description?: string | null;
    digestive_system_findings?: string | null;
    respiratory_system_findings?: string | null;
    endocrine_system_findings?: string | null;
    musculoskeletal_system_findings?: string | null;
    nervous_system_findings?: string | null;
    urinary_system_findings?: string | null;
    reproductive_system_findings?: string | null;
    rectal_palpation_findings?: string | null;
    other_physical_findings?: string | null;

    // Abordaje Diagnóstico
    problem_list?: string | null; // Podría ser un array de strings JSON.stringify
    master_problem_list?: string | null;
    differential_diagnoses?: string | null; // Podría ser un array de strings JSON.stringify

    // Exámenes Complementarios (Resumen textual, los archivos van en otra tabla)
    complementary_exams_summary?: string | null;

    // Diagnóstico y Plan
    presumptive_diagnosis: string;
    definitive_diagnosis?: string | null;
    therapeutic_plan: string;
    prognosis?: string | null;
    evolution_notes?: string | null; // Evolución durante la consulta o plan de seguimiento inmediato
    general_observations?: string | null; // Observaciones generales, recomendaciones de egreso, etc.
    signature_confirmation?: string | null; // Campo para que el vet confirme digitalmente (texto)


    // Relaciones (pobladas al hacer fetch si se usa SELECT anidado)
    procedures?: ConsultationProcedureType[];
    medications?: ConsultationMedicationType[];
    files?: ConsultationFileType[];

    created_at: string; // timestamptz
    updated_at: string; // timestamptz
}

// Payload para crear una consulta, puede ser un subconjunto o incluir arrays para sub-registros
export type CreateConsultationPayload = Omit<ConsultationType, 'id' | 'created_at' | 'updated_at' | 'procedures' | 'medications' | 'files'> & {
    procedures?: Array<Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>>;
    medications?: Array<Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>>;
    // Los archivos se manejarán con un endpoint separado después de crear la consulta,
    // o podrías tener un array de `File` objects aquí si tu API lo maneja en un solo paso.
}; 
----- Archivo: index.ts ----- 
import { StorageContextType } from "@/hooks/useAppStorage";
import { PostgrestError, Session } from "@supabase/supabase-js";
import { NextResponse } from "next/server";
import { Dispatch, SetStateAction } from "react";
import { ZodObject } from "zod";

export interface AppContextType {
  session: AppSession | null;
  logout: () => object;
  storage: StorageContextType;
  showEditPetModal: boolean;
}

export interface AppSession {
  db: Session | null;
}

export interface FormType {
  id: string,
  fields: FieldType[]
}

export interface FieldType {
  label: string;
  show: boolean;
  value?: string;
}

export interface MenuType {
  label: string;
  icon: React.JSX.Element,
  url: string;
  showModal?: Dispatch<SetStateAction<boolean>>,
  show: boolean;
}

export interface StepsStateType {
  step: number;
  state: StepStateEnum;
  url?: string;
  error?: string | null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  schema: ZodObject<any>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  repository?: FormRepository<any>
}

export enum StepStateEnum {
  NotInitialize = 0,
  Initialize = 1,
  Saved = 2,
  Modified = 3,
  Skipped = 4,
  Error = 5,
}

export type StepConfig<T> = {
  entityName: string;
  storedList: T[];
  setStoredList: (list: T[] | null) => void;
  emptyFactory: (petId: string) => T;
  fieldsConfig: FieldConfig<T>[];
};

export interface FieldConfig<T> {
  label: string;
  name: keyof T;
  type: "text" | "date";
  mandatory?: boolean;
  className?: string;
}

export interface FormRepository<T> {
  createAll: (list: T[]) => Promise<{
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    data: any[] | null;
    error: PostgrestError | null;
  }>;
  findByParentId: (parent_id: string) => Promise<T[] | null>;
  delete: (id: string) => Promise<boolean>
}

export interface LogInType {
  email: string;
  password: string;
  role: 'owner' | 'veterinarian';
}
export interface SetSesionType {
  access_token: string;
  refresh_token: string;
}

export interface ApiParams {
  params: Record<string, string>;
};

export type ApiResponse = Promise<NextResponse<{ message: string; success: boolean }>>;

export type ValidationResult<T> =
  | { data: T; error?: undefined }
  | { data?: undefined; error: NextResponse };


/**
 * Excepción que lanzamos cuando falta un parámetro obligatorio en la query.
 */
export class QueryParamError extends Error { }

/**
 * Excepción que lanzamos cuando falta alguna configuración en los steps.
 */
export class StepStateError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema en el repositorio.
 */
export class RepositoryError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema consumiendo un api.
 */
export class ApiError extends Error { }
/**
 * Excepción que lanzamos cuando hay un problema con el cliente de autenticación.
 */
export class AuthError extends Error { } 
----- Archivo: dates.ts ----- 
export function format(date: string | Date | undefined | null): string {
    if (date == undefined || date == null) {
        return '';
    }
    if(typeof(date) == typeof("")){
        return (date as string).split('T')[0];
    }
    return (date as Date).toISOString().split('T')[0];
} 
----- Archivo: factories.ts ----- 
// src/utils/factories.ts
"use client";

import { v4 } from 'uuid';
import type {
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  SurgeryDataType,
  VaccineDataType
} from '@/types/index';

export const emptyVaccine = (petId: string): Partial<VaccineDataType> => ({
    pet_id: petId,
    id: v4(),
    name: "",
    description: "",
    date: undefined,
    batch: "",
    brand: "",
});

export const emptyCondition = (petId: string): Partial<ConditionDataType> => ({
  id: v4(),
  pet_id: petId,
  condition: '',
  severity: '',
});

export const emptyLabTest = (petId: string): Partial<LabTestDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  type: '',
  date: undefined,
  result: '',
});

export const emptyMedicine = (petId: string): Partial<MedicineDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  dosage: '',
  frequency: '',
});

export const emptySurgery = (petId: string): Partial<SurgeryDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  date: undefined,
  description: '',
}); 
----- Archivo: index.ts ----- 
export * as Dates from "@/utils/dates";
export * as Factores from "@/utils/factories";
export * as Random from "@/utils/random";
export * as Steps from "@/utils/steps";
export * as Strings from "@/utils/strings";
export * as Validations from "@/utils/validations"; 
----- Archivo: random.ts ----- 
// src/utils/random.tsx
import { customAlphabet } from "nanoid";

// Define un alfabeto con dígitos y letras (mayúsculas + minúsculas)
const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

// Crea un generador de IDs de 6 caracteres
export const generateCode = customAlphabet(ALPHABET, 6);


/**
 * Genera un ID aleatorio que cumple el patrón: letra + 3 dígitos (e.g. A012, z999).
 */
function randomPetId(): string {
  const letter = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
  const number = Math.floor(Math.random() * 1000)
    .toString()
    .padStart(3, '0');
  return `${letter}${number}`;
}

/**
 * Genera un ID único para mascota, repitiendo hasta que no exista en la base de datos.
 */
export async function generateUniquePetId(): Promise<string> {
  let candidate: string;
  let exists: boolean;

  do {
    candidate = randomPetId();

    const res = await fetch(`/api/pets/exists?id=${candidate}`);
    const data = await res.json();
    exists = data.exists;
  } while (exists);

  return candidate;
} 
----- Archivo: steps.ts ----- 
// src/utils/steps.ts
import { StepsStateType, StepStateEnum } from '@/types/lib';
import { Dispatch } from 'react';

export function ChangeState(stepStates: StepsStateType[], setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>, stepNumber: number, stepState: StepStateEnum, stepError: string | null = null) {
    const step = stepStates.find(s => s.step == stepNumber);
    if (step) {
        step.state = stepState;
        step.error = stepError;
    }
    setStepStates(stepStates);
} 
----- Archivo: strings.ts ----- 
// src/utils/string.ts
import { ApiParams } from "@/types/lib";

export function titleCase(word: string) {
    if (!word) return word;
    return word[0].toUpperCase() + word.substr(1).toLowerCase();
}

/**
 * Convierte un objeto en un query string para URL.
 * Omite claves con valor undefined o null.
 *
 * @example
 * paramsToString({ a: 1, b: 'hola mundo', c: undefined }) 
 * // devuelve "?a=1&b=hola%20mundo"
 *
 * @param params Objeto cuyas claves/valores se desean serializar.
 * @returns Query string (incluye '?' si hay al menos un parámetro).
 */
export function fromParams(params: ApiParams): string {
  const entries = Object.entries(params)
    .filter(([, value]) => value !== undefined && value !== null)
    .map(([key, value]) => {
      // Si es array, repetimos key=valor por cada elemento
      if (Array.isArray(value)) {
        return value
          .map(v => `${encodeURIComponent(key)}=${encodeURIComponent(String(v))}`)
          .join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
    });

  if (entries.length === 0) {
    return '';
  }
  return `?${entries.join('&')}`;
} 
----- Archivo: validations.ts ----- 
// src/utils/validations.ts

import { FieldConfig } from "@/types/lib";

/**
 * Valida un array de entidades genericas contra su configuracion de campos.
 * Devuelve null si todo pasa, o un mensaje con los campos obligatorios faltantes.
 */
export function forFields<T>(
  items: Partial<T>[],
  entityName: string,
  fieldsConfig: FieldConfig<T>[]
): string | null {
  const missing: string[] = [];

  items.forEach((item, idx) => {
    fieldsConfig
      .filter(field => field.mandatory)
      .forEach(field => {
        if (!item[field.name]) {
          missing.push(`${field.label} en ${entityName} #${idx + 1}`);
        }
      });
  });

  if (missing.length > 0) {
    return `Faltan los campos obligatorios: ${missing.join(', ')}`;
  }
  return null;
}
 
