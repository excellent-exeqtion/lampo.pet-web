----- Archivo: middleware.ts ----- 
// middleware.ts
import { NextResponse, type NextRequest } from 'next/server';
import { createServerClient, updateSession } from '@/lib/auth';
import { cookies } from 'next/headers';

// Lista de rutas permitidas para veterinarios con acceso temporal
const VET_GUEST_ALLOWED_PATHS = [
    '/pages/pet/basic-data',
    '/pages/pet/vaccines',
    '/pages/pet/surgeries',
    '/pages/pet/medicines',
    '/pages/pet/conditions',
    '/pages/pet/lab-tests',
];

// Helper para validar si la ruta actual está permitida
function isVetGuestAllowedPath(pathname: string, petIdFromCookie: string): boolean {
    // 1. Revisa las rutas estáticas
    if (VET_GUEST_ALLOWED_PATHS.includes(pathname)) {
        return true;
    }
    // 2. Revisa las rutas dinámicas, como la de consultas
    const consultationMatch = pathname.match(/^\/pages\/pet\/consultations\/([^/]+)/);
    if (consultationMatch) {
        const petIdFromUrl = consultationMatch[1];
        // Comprueba si el ID de mascota en la URL coincide con el de la cookie
        return petIdFromUrl === petIdFromCookie;
    }

    // 3. Revisa la ruta para añadir una nueva consulta
    const newConsultationMatch = pathname.match(/^\/pages\/vet\/consultation\/([^/]+)/);
    if (newConsultationMatch) {
        const petIdFromUrl = newConsultationMatch[1];
        return petIdFromUrl === petIdFromCookie;
    }

    return false;
}


export async function middleware(request: NextRequest) {
    const { pathname } = request.nextUrl;
    const cookieStore = await cookies();

    // Rutas públicas que no necesitan validación de sesión ni de cookie
    const publicRoutes = ['/login', '/vet-access', '/pages/auth/verify', '/api/auth/logout'];
    if (pathname === '/' || publicRoutes.some(route => pathname.startsWith(route))) {
        return await updateSession(request);
    }

    const supabaseResponse = NextResponse.next({ request });
    const supabase = await createServerClient(cookieStore);

    const { data: { user } } = await supabase.getUser();

    // Si hay un usuario con sesión, la lógica de Supabase se encargará
    if (user) {
        return supabaseResponse;
    }

    // Si NO hay usuario, revisamos la cookie de acceso temporal de veterinario
    const vetAccessCookie = request.cookies.get('lampo-vet-access');
    if (vetAccessCookie) {
        try {
            const { petId } = JSON.parse(vetAccessCookie.value);
            if (petId && isVetGuestAllowedPath(pathname, petId)) {
                // El veterinario sin sesión tiene acceso a esta ruta
                return supabaseResponse;
            }
        } catch (error) {
            // La cookie está malformada, la ignoramos y procedemos a redirigir
            console.error("Error parsing vet access cookie:", error);
        }
    }

    // Si no hay usuario y no hay acceso de veterinario válido para esta ruta, redirigimos al login
    // Excluimos las API routes de esta redirección para no romper la app
    if (!pathname.startsWith('/api/')) {
        const url = request.nextUrl.clone();
        url.pathname = '/login';
        return NextResponse.redirect(url);
    }

    // Para todas las demás rutas (principalmente API), dejamos que Supabase maneje la sesión
    return supabaseResponse;
}

export const config = {
    matcher: [
        /*
         * Match all request paths except for the ones starting with:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * Feel free to modify this pattern to include more paths.
         */
        '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
    ],
}; 
----- Archivo: layout.tsx ----- 
// app/layout.tsx
"use client";
import React from "react";
import "./globals.css";
import "@picocss/pico";
import { tooltipStyles } from "@/styles/tooltip";
import { geistMono, geistSans } from "@/styles/geist";
import { ClientAppProvider } from "../components";
import { usePathname } from "next/navigation";
import { SessionProvider } from "@/context/SessionProvider";
import '../lib/i18n';
import { StorageProvider } from "@/context/StorageProvider";
import { RoleProvider } from "@/context/RoleProvider";
import { VetProvider } from "@/context/VetContext";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const noClientAppProviderRoutes = ["/", "/login", "/vet-access", "/pages/auth/verify"];
  const shouldUseClientAppProvider = !noClientAppProviderRoutes.includes(pathname);
  

  return (
    <html lang="es" data-theme="light" className="no-select">
      <head>
        <title>Lampo</title>
      </head>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <style>{tooltipStyles}</style>
        <SessionProvider>
          <StorageProvider>
            <RoleProvider>
              <VetProvider>
                {shouldUseClientAppProvider ? (
                  <ClientAppProvider>
                    {children}
                  </ClientAppProvider>
                ) : (
                  <>
                    {children}
                  </>
                )}

              </VetProvider>
            </RoleProvider>
          </StorageProvider>
        </SessionProvider>
      </body>
    </html >
  );
} 
----- Archivo: page.tsx ----- 
"use client";
import React from "react";
import "@picocss/pico";
import LandingPage from "./landing/page";

export default function Home() {
  return (
    <LandingPage />
  );
}

 
----- Archivo: globals.css ----- 
/**
 * Custom theme
*/
/* Red Light scheme (Default) */
/* Can be forced with data-theme="light" */
[data-theme="light"],
:root:not([data-theme="dark"]) {
  --primary: #e53935;
  --primary-hover: var(--primary-red);
  --primary-focus: rgba(229, 57, 53, 0.125);
  --primary-inverse: #FFF;
  --primary-yellow: #FBBF24;
  --primary-lightyellow: #fff3cd;
  --primary-darkblue: #0B1446;
  --primary-green: #10B981;
  --primary-red: #d73a49;
  --primary-lightgray: #ccc;
  --primary-darkgray: #888;
  --primary-skin: #e8f0fe;
  --primary-darkerskin: #f5f5f5;
  --primary-lighttransparent: rgba(0, 0, 0, 0.1);
  --primary-darkertransparent: rgba(0, 0, 0, 0.5);
  --primary--graytransparent: rgba(255, 255, 255, 0.1);

  --primary: var(--pico-primary);
  --primary-dark: var(--primary-darkblue);
  --section-bg: var(--primary-inverse);
  --hero-bg: var(--pico-primary);
  --footer-bg: var(--pico-contrast);
  --font-title: 'Poppins', Arial, sans-serif;
  --font-main: 'Poppins', Arial, sans-serif;
}

/* Red Dark scheme (Auto) */
/* Automatically enabled if user has Dark mode enabled */
@media only screen and (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --primary: #e53935;
    --primary-hover: #f44336;
    --primary-focus: rgba(229, 57, 53, 0.25);
    --primary-inverse: #FFF;
    --primary-yellow: #FBBF24;
    --primary-lightyellow: #fff3cd;
    --primary-darkblue: #0B1446;
    --primary-green: #10B981;
    --primary-red: #d73a49;
    --primary-lightgray: #ccc;
    --primary-darkgray: #888;
    --primary-skin: #e8f0fe;
    --primary-darkerskin: #f5f5f5;
    --primary-lighttransparent: rgba(0, 0, 0, 0.1);
    --primary-darkertransparent: rgba(0, 0, 0, 0.5);
    --primary--graytransparent: rgba(255, 255, 255, 0.1);

    --primary: var(--pico-primary);
    --primary-dark: var(--primary-darkblue);
    --section-bg: var(--primary-inverse);
    --hero-bg: var(--pico-primary);
    --footer-bg: var(--pico-contrast);
    --font-title: 'Poppins', Arial, sans-serif;
    --font-main: 'Poppins', Arial, sans-serif;
  }
}

/* Red Dark scheme (Forced) */
/* Enabled if forced with data-theme="dark" */
[data-theme="dark"] {
  --primary: #e53935;
  --primary-hover: #f44336;
  --primary-focus: rgba(229, 57, 53, 0.25);
  --primary-inverse: #FFF;
  --primary-yellow: #FBBF24;
  --primary-lightyellow: #fff3cd;
  --primary-darkblue: #0B1446;
  --primary-green: #10B981;
  --primary-red: #d73a49;
  --primary-lightgray: #ccc;
  --primary-darkgray: #888;
  --primary-skin: #e8f0fe;
  --primary-darkerskin: #f5f5f5;
  --primary-lighttransparent: rgba(0, 0, 0, 0.1);
  --primary-darkertransparent: rgba(0, 0, 0, 0.5);
  --primary--graytransparent: rgba(255, 255, 255, 0.1);

  --primary: var(--pico-primary);
  --primary-dark: var(--primary-darkblue);
  --section-bg: var(--primary-inverse);
  --hero-bg: var(--pico-primary);
  --footer-bg: var(--pico-contrast);
  --font-title: 'Poppins', Arial, sans-serif;
  --font-main: 'Poppins', Arial, sans-serif;

  /* Red (Common styles) */
  :root {
    --form-element-active-border-color: var(--primary);
    --form-element-focus-color: var(--primary-focus);
    --switch-color: var(--primary-inverse);
    --switch-checked-background-color: var(--primary);
    --primary-yellow: #FBBF24;
    --primary-lightyellow: #fff3cd;
    --primary-darkblue: #0B1446;
    --primary-green: #10B981;
    --primary-red: #d73a49;
    --primary-lightgray: #ccc;
    --primary-darkgray: #888;
    --primary-skin: #e8f0fe;
    --primary-darkerskin: #f5f5f5;
    --primary-lighttransparent: rgba(0, 0, 0, 0.1);
    --primary-darkertransparent: rgba(0, 0, 0, 0.5);
    --primary--graytransparent: rgba(255, 255, 255, 0.1);

    --primary: var(--pico-primary);
    --primary-dark: var(--primary-darkblue);
    --section-bg: var(--primary-inverse);
    --hero-bg: var(--pico-primary);
    --footer-bg: var(--pico-contrast);
    --font-title: 'Poppins', Arial, sans-serif;
    --font-main: 'Poppins', Arial, sans-serif;
  }

  .pet-dropdown {
    --pico-box-shadow: 'none' !important;
  }

  .pet-selection:hover {
    background-color: gray;
  }

  * {
    -webkit-user-select: none !important;
    -khtml-user-select: none !important;
    -moz-user-select: -moz-none !important;
    -o-user-select: none !important;
    user-select: none !important;
    box-sizing: border-box !important;
  }

  body {
    font-family: var(--font-main);
  }

  body {
    -webkit-touch-callout: none;
    /* iOS Safari */
    -webkit-user-select: none;
    /* Safari */
    -khtml-user-select: none;
    /* Konqueror HTML */
    -moz-user-select: none;
    /* Old versions of Firefox */
    -ms-user-select: none;
    /* Internet Explorer/Edge */
    user-select: none;
    /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
  }

  .modal-title {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    color: var(--pico-primary) !important;
  }

  .modal-description {
    font-size: 0.9rem;
    color: #555;
    margin-bottom: 1.5rem;
  }

  .text-error {
    color: var(--primary-red);
  }

  main {
    background-color: rgb(249, 250, 251);
  }


  .no-select {
    -webkit-user-select: none;
    /* Safari */
    -ms-user-select: none;
    /* IE 10 and IE 11 */
    user-select: none !important;
    /* Standard syntax */
  }
}

.city-suggestion-item:hover {
  background-color: var(--primary-skin);
}

/* 1. Fix for the marker icon's blue background */
.leaflet-marker-icon {
  background: none !important;
  border: none !important;
  padding: 0 !important;
}

/* 2. Fix for zoom control alignment and styling */
.leaflet-control-zoom a {
  color: var(--pico-primary) !important;
  background-color: var(--primary-inverse) !important;
  border-bottom: 1px solid var(--primary-lightgray) !important;
  text-align: center !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
}

.leaflet-control-zoom a:hover {
  background-color: var(--primary-darkerskin) !important;
}

/* 3. Ensure the map container itself is not affected by global styles */
.leaflet-container {
  font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif !important; /* Use Leaflet's default font */
  box-shadow: 0 1px 5px rgba(0,0,0,0.65); /* Optional: add a subtle shadow to the map */
} 
----- Archivo: page.module.css ----- 
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  background-color: rgb(249, 250, 251);
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer Image {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    background-color: rgb(249, 250, 251);
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
} 
----- Archivo: index.ts ----- 
import { ApiParams } from "@/types/lib";
import { Strings } from "@/utils/index";

export async function getFetch(url: string, params: ApiParams | undefined = undefined) {
    return await methodFetch("GET", url, params);
}

export async function putFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PUT", url, params, payload);
}

export async function postFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("POST", url, params, payload);
}

export async function patchFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("PATCH", url, params, payload);
}

export async function deleteFetch(url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    return await methodFetch("DELETE", url, params, payload);
}

async function methodFetch(method: string, url: string, params: ApiParams | undefined = undefined, payload: object | undefined = undefined) {
    let parameters = "";
    if (params) {
        parameters = Strings.fromParams(params);
    }
    let body = undefined;
    if (payload) {
        body = JSON.stringify(payload);
    }
    return await fetch(`${process.env.PROTOCOL}://${process.env.PRODUCTION_URL}${url}${parameters}`, {
        method: method,
        headers: method == "GET" ? undefined : { 'Content-Type': 'application/json' },
        body: body
    })
} 
----- Archivo: route.ts ----- 
// src/app/api/auth/logout/route.ts
import { NextResponse } from 'next/server';

export async function POST() {
    // Creamos una respuesta para poder manipular las cookies
    const response = NextResponse.json({ success: true, message: 'Logout successful' });

    // Eliminamos la cookie de acceso de veterinario
    response.cookies.delete('lampo-vet-access');

    return response;
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationRepository } from '@/repos/index';
import { getRequiredQueryParam, getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { CreateConsultationPayloadSchema } from '@/schemas/validationSchemas';
import type { CreateConsultationPayload } from '@/types/index';
import { RepositoryError } from '@/types/lib';
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/auth';

// POST /api/consultations : Crear una nueva consulta
export async function POST(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    const serverClient = await createServerClient(options.cookies);

    return withValidationAndErrorHandling(
        'POST',
        req,
        CreateConsultationPayloadSchema,
        async (payload: CreateConsultationPayload) => {
            const { data: { session }, error: sessionError } = await serverClient.getSession();

            if (sessionError) {
                console.error("Error obteniendo sesión en API:", sessionError);
                return NextResponse.json({ success: false, message: 'Error de autenticación al obtener sesión.' }, { status: 401 });
            }

            if (!payload.veterinarian_id && !payload.veterinary_access_id) {
                if (session?.user?.user_metadata?.role === 'veterinarian') {
                    payload.veterinarian_id = session.user.id;
                } else {
                    console.warn("Intento de crear consulta sin vet_id o vet_access_id, y sin sesión de veterinario.");
                    return NextResponse.json(
                        { success: false, message: 'Se requiere veterinarian_id o veterinary_access_id válido.' },
                        { status: 403 }
                    );
                }
            }

            const { data, error } = await ConsultationRepository.create(payload, options);
            if (error || !data) {
                console.error(`Error creando consulta desde API: ${error?.message || 'No data returned'}`);
                throw new RepositoryError(`Error creando consulta: ${error?.message || 'No data returned'}`);
            }
            return NextResponse.json({ success: true, consultation: data }, { status: 201 });
        }
    );
}

// GET /api/consultations?petId=mascota123 : Listar consultas de una mascota
export async function GET(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const petId = getRequiredQueryParam(req, 'petId');
            const { data, error } = await ConsultationRepository.findByPetId(petId, options);

            if (error) {
                throw new RepositoryError(`Error obteniendo consultas para la mascota ${petId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, consultations: data || [] });
        }
    );
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/[consultationId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

// GET /api/consultations/{consultationId} : Obtener una consulta específica
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { consultationId } = await params;
            if (!consultationId) {
                return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
            }

            const { data, error } = await ConsultationRepository.findById(consultationId, options);

            if (error) {
                throw new RepositoryError(`Error obteniendo consulta ${consultationId}: ${error.message}`);
            }
            if (!data) {
                return NextResponse.json({ success: false, message: `Consulta ${consultationId} no encontrada` }, { status: 404 });
            }
            return NextResponse.json({ success: true, consultation: data });
        }
    );
}

// TODO: PATCH /api/consultations/{consultationId} : Actualizar una consulta (más complejo)
// export async function PATCH(req: NextRequest, { params }: { params: { consultationId: string } }) { ... }

// TODO: DELETE /api/consultations/{consultationId} : Eliminar una consulta (considerar RLS)
// export async function DELETE(req: NextRequest, { params }: { params: { consultationId: string } }) { ... } 
----- Archivo: route.ts ----- 
// src/app/api/consultations/[consultationId]/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationFileRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";
import { createServerClient } from '@/lib/auth';

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB
const ALLOWED_FILE_TYPES = ['image/jpeg', 'image/png', 'application/pdf', 'image/webp', 'image/gif'];

// POST /api/consultations/{consultationId}/files : Subir un archivo a una consulta
export async function POST(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(req, async () => {
        const { consultationId } = await params;
        if (!consultationId) {
            return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
        }

        const formData = await req.formData();
        const file = formData.get('file') as File | null;
        const petId = formData.get('petId') as string | null; // Necesario para la ruta del archivo

        if (!file) {
            return NextResponse.json({ success: false, message: 'Archivo no proporcionado' }, { status: 400 });
        }
        if (!petId) {
            return NextResponse.json({ success: false, message: 'petId no proporcionado en el FormData' }, { status: 400 });
        }

        if (file.size > MAX_FILE_SIZE) {
            return NextResponse.json({ success: false, message: `El archivo excede el tamaño máximo de ${MAX_FILE_SIZE / (1024 * 1024)}MB` }, { status: 413 });
        }
        if (!ALLOWED_FILE_TYPES.includes(file.type)) {
            return NextResponse.json({ success: false, message: `Tipo de archivo no permitido. Permitidos: ${ALLOWED_FILE_TYPES.join(', ')}` }, { status: 415 });
        }

        const { data: { user } } = await (await createServerClient(options.cookies)).getUser();
        const uploadedByUserId = user?.id;

        const { data, error } = await ConsultationFileRepository.uploadAndCreateRecord(
            consultationId,
            petId,
            file,
            options,
            uploadedByUserId
        );
        console.log('error', error);

        if (error || !data) {
            console.log(`Error subiendo archivo: ${error?.message || 'No data returned'}`)
            if (error?.message.includes("new row violates row-level security policy")) {
                throw new Error("No tienes permisos para cargar el archivo");
            }
            throw new RepositoryError("Error subiendo archivo: ");
        }
        return NextResponse.json({ success: true, file: data }, { status: 201 });
    });
}

// GET /api/consultations/{consultationId}/files : Listar archivos de una consulta
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ consultationId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { consultationId } = await params;
            if (!consultationId) {
                return NextResponse.json({ success: false, message: 'consultationId es requerido' }, { status: 400 });
            }

            const { data, error } = await ConsultationFileRepository.findByConsultationId(consultationId, options);

            if (error) {
                throw new RepositoryError(`Error obteniendo archivos para consulta ${consultationId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, files: data || [] });
        }
    );
} 
----- Archivo: route.ts ----- 
// src/app/api/consultations/[consultationId]/files/[fileId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ConsultationFileRepository } from '@/repos/index';
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";


// GET /api/consultations/{consultationId}/files/{fileId} : Obtener URL firmada para descargar
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ fileId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(req, async () => {
        const { fileId } = await params;
        if (!fileId) {
            return NextResponse.json({ success: false, message: 'fileId es requerido' }, { status: 400 });
        }

        // Primero, necesitamos el filePath del registro del archivo
        const fileRecord = await ConsultationFileRepository.getFile(fileId, options);
        if (!fileRecord) {
            throw new RepositoryError(`Archivo con ID ${fileId} no encontrado o error al buscarlo.`);
        }

        const { signedURL, error: urlError } = await ConsultationFileRepository.getSignedUrl(fileRecord.file_path, options);

        if (urlError || !signedURL) {
            throw new RepositoryError(`Error generando URL firmada para archivo ${fileId}: ${urlError?.message || 'No URL returned'}`);
        }
        // Opción 1: Devolver la URL para que el cliente la use
        return NextResponse.json({ success: true, downloadUrl: signedURL });

        // Opción 2: Redirigir directamente a la URL firmada (el cliente descargará el archivo)
        // return NextResponse.redirect(signedURL);
    });
}


// DELETE /api/consultations/{consultationId}/files/{fileId} : Eliminar un archivo
export async function DELETE(
    req: NextRequest,
    { params }: { params: Promise<{ fileId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { fileId } = await params;
            if (!fileId) {
                return NextResponse.json({ success: false, message: 'fileId es requerido' }, { status: 400 });
            }

            // Aquí deberías verificar permisos (RLS debería manejar esto también)
            // Por ejemplo, solo el veterinario que subió el archivo o el dueño de la mascota
            // pueden eliminarlo, o solo dentro de un tiempo límite.

            const { error } = await ConsultationFileRepository.delete(fileId, options);

            if (error) {
                throw new RepositoryError(`Error eliminando archivo ${fileId}: ${error.message}`);
            }
            return NextResponse.json({ success: true, message: 'Archivo eliminado correctamente' });
        }
    );
} 
----- Archivo: route.ts ----- 

// src/app/api/feedback/route.ts
import { NextResponse } from 'next/server';
import { sendEmail } from '@/services/emailService';

export const runtime = 'nodejs';

export async function POST(req: Request) {
  try {
    const { feedback, anonymous, userEmail } = await req.json();
    if (!feedback || typeof feedback !== 'string') {
      return NextResponse.json({ error: 'Falta el texto del feedback' }, { status: 400 });
    }

    const subjectBase = process.env.MAILTRAP_SUBJECT || 'Feedback de Lampo';
    const subject = anonymous
      ? `${subjectBase} (Anonymous)`
      : `${subjectBase} (From ${userEmail})`;

    // Llamada al servicio de email
    await sendEmail({ subject, text: feedback });

    return NextResponse.json({ ok: true }, { status: 200 });
  } catch (err) {
    console.error('Error interno en /api/feedback:', err);
    const message = err instanceof Error ? err.message : 'Error interno del servidor';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
 
----- Archivo: route.ts ----- 
// app/api/owners/route.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { OwnerRepository } from '@/repos/index';
import type { OwnerDataType } from '@/types/index';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { OwnerDataTypeSchema } from '@/schemas/validationSchemas';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

// PUT /api/owner : crea o actualiza datos del dueño
export async function PUT(request: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    try {
        const payload: OwnerDataType = await request.json();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const ownerId = (payload as any).owner_id;
        if (!ownerId) {
            return NextResponse.json({ error: 'El campo owner_id es requerido' }, { status: 400 });
        }

        const existing = await OwnerRepository.findById(ownerId, options);
        if (existing) {
            await OwnerRepository.update(payload, options);
        }

        const saved = await OwnerRepository.findById(ownerId, options);
        return NextResponse.json({ owner: saved });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
        console.error('Error upserting owner:', error);
        return NextResponse.json({ error: error.message || 'Error interno del servidor' }, { status: 500 });
    }
}

export async function POST(req: NextRequest) {
    return withValidationAndErrorHandling(
        'POST',
        req,
        OwnerDataTypeSchema,
        async (ownerData: OwnerDataType) => {
            try {
                const { data, error } = await OwnerRepository.create(ownerData);
                if (error) {
                    throw new RepositoryError(`Error creating record: ${JSON.stringify(ownerData)}`);
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error creating record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/owners/by-pét/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { OwnerRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ petId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { petId } = await context.params;
            if (!petId) {
                throw new QueryParamError(`Falta parámetro PetId`);
            }

            const ownerData = await OwnerRepository.findByPetId(petId, options);
            if (!ownerData) {
                throw new RepositoryError(`Owner no encontrado para el petId: ${petId}`);
            }
            return NextResponse.json(ownerData);
        }
    );
}
 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { PetRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            try {
                const data = await PetRepository.findByOwnerId(id, options);
                return NextResponse.json(data);
            }
            catch {
                throw new RepositoryError("Error getting pets");
            }
        });
}
 
----- Archivo: route.ts ----- 
// src/app/api/owners/[ownerId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { OwnerRepository } from '@/repos/index'
import { getWithErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError(`Falta parámetro OwnerId`);
            }

            const ownerData = await OwnerRepository.findById(id, options);
            if (!ownerData) {
                throw new RepositoryError(`Owner no encontrado: ${id}`);
            }
            return NextResponse.json(ownerData);
        }
    );
}
 
----- Archivo: route.ts ----- 
// app/api/pets/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getRequiredQueryParam, withValidationAndErrorHandling, getWithErrorHandling } from '@/services/apiService'
import PetRepository from '@/repos/pet.repository'
import { z } from 'zod'
import { PetType } from '@/types/index'
import { cookies } from "next/headers";

const petSchema = z.object({
    id: z.string().optional(),
    name: z.string(),
    image: z.string().optional(),
    owner_id: z.string(),
})

export async function GET(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            // ahora delegamos la validación del ownerId
            const ownerId = getRequiredQueryParam(req, 'ownerId')
            const pets = await PetRepository.findByOwnerId(ownerId, options)
            return NextResponse.json(pets, { status: 200 })
        });
}

export async function POST(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    return withValidationAndErrorHandling(
        'POST',
        req,
        petSchema,
        async (pet) => {
            const { data, error } = await PetRepository.upsert(pet as PetType, options)
            if (error) {
                return NextResponse.json(
                    { success: false, message: error.message },
                    { status: 500 }
                )
            }
            return NextResponse.json(data, { status: 201 })
        }
    )
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { BasicDataRepository } from '@/repos/index'
import { getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { BasicDataTypeSchema } from '@/schemas/validationSchemas';
import { BasicDataType } from '@/types/index';
import { RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ petId: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { petId } = await params;
            const data = await BasicDataRepository.findByPetId(petId, options);
            return NextResponse.json(data);
        });
}

export async function POST(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    return withValidationAndErrorHandling(
        'POST',
        req,
        BasicDataTypeSchema,
        async (basicData) => {
            try {
                const { data, error } = await BasicDataRepository.upsert(basicData as BasicDataType, options);
                if (error) {
                    return NextResponse.json(
                        { success: false, message: `Error upserting record: ${error.message}` },
                        { status: 500 }
                    )
                }
                return NextResponse.json(data, { status: 201 });
            }
            catch {
                throw new RepositoryError("Error upserting record");
            }
        }
    )
} 
----- Archivo: route.ts ----- 
// src/app/api/pets/exists/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";
import { cookies } from "next/headers";

export async function GET(req: NextRequest) {
  const options = {
    cookies: await cookies()
  }

  return getWithErrorHandling(req, async () => {
    const id = getRequiredQueryParam(req, "id");

    const exists = await PetRepository.existsById(id, options);
    return NextResponse.json({ success: true, exists });
  });
}
 
----- Archivo: route.ts ----- 
// app/api/basic-data/[petId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getWithErrorHandling, withErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { Empty } from '@/data/index';
import { RepositoryError, StepsStateType, StepStateError } from '@/types/lib';
import { cookies } from "next/headers";

export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await params;
            const step = getStep(req);
            if (step.repository) {
                try {
                    const data = await step.repository.findByParentId(id, options);
                    return NextResponse.json(data);
                }
                catch {
                    throw new RepositoryError("Error getting records");
                }
            }
            throw new StepStateError("Missing repository");
        });
}

export async function POST(req: NextRequest) {
    const options = {
        cookies: await cookies()
    }

    const step = getStep(req);
    return withValidationAndErrorHandling(
        'POST',
        req,
        step.schema,
        async (list) => {
            if (step.repository) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const { data, error } = await step.repository.createAll(list as any[], options)
                    if (error) {
                        throw new RepositoryError(error.message);
                    }
                    return NextResponse.json(data, { status: 201 });
                }
                catch {
                    throw new RepositoryError("Error upserting records");
                }
            }
            throw new StepStateError("Missing repository");
        }
    );
}

export async function DELETE(req: NextRequest,
    { params }: { params: Promise<{ id: string; list: string }> }) {
    const options = {
        cookies: await cookies()
    }

    const step = getStep(req);
    return withErrorHandling(
        'DELETE',
        req,
        async () => {
            const { id } = await params;
            if (step.repository) {
                const response = await step.repository.delete(id, options);
                if (!response) {
                    throw new RepositoryError("Error deleting record");
                }
                return NextResponse.json({ success: true, message: "Se eliminó correctamente el registro" }, { status: 200 });
            }
            throw new StepStateError("Missing repository");
        }
    )
}

function getStep(req: NextRequest): StepsStateType {
    const filter = Empty.Steps().filter(s => req.url.includes(s.url || "") && s.repository);
    if (filter.length == 0) {
        throw new StepStateError("Missing step");
    }
    else if (filter.length > 1) {
        throw new StepStateError("Too many steps");
    }
    else {
        return filter[0];
    }
} 
----- Archivo: route.tsx ----- 
// app/api/pets/me/code/route.ts
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";
import { cookies } from "next/headers";

export async function POST(req: Request) {
  const options = {
    cookies: await cookies()
  }

  try {
    const { owner_id, pet_id } = await req.json();

    // 1) Mascota del owner
    const pet = await PetRepository.findByOwnerIdAndPetId(owner_id, pet_id, options);
    if (!pet) {
      return NextResponse.json(
        { error: "Mascota no encontrada" },
        { status: 404 }
      );
    }

    // 2) Invalida códigos anteriores
    await PetCodeRepository.invalidateAll(pet_id, options);

    // 3) Crea nuevo código
    const ttl = parseInt(process.env.CODE_EXPIRE_AT!);
    const code = await PetCodeRepository.create(pet_id, ttl, options);

    return NextResponse.json({ code });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    const msg = err.message.includes("No autorizado")
      ? { error: "No autorizado" }
      : { error: err.message || "Error interno" };
    const status = msg.error === "No autorizado" ? 401 : 500;
    return NextResponse.json(msg, { status });
  }
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.ts (resumiendo lo anterior)
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { PetRepository } from "@/repos/index";
import { getWithErrorHandling, withValidationAndErrorHandling } from "@/services/apiService";
import { PetType } from "@/types/index";
import { RepositoryError } from "@/types/lib";
import { cookies } from "next/headers";

const updatePetSchema = z.object({
  name: z.string().optional(),
  image: z.string().url().optional(),
});

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const options = {
    cookies: await cookies()
  }

  return getWithErrorHandling(
    req,
    async () => {
      const { id } = await params;
      const pets = await PetRepository.findById(id, options)
      return NextResponse.json(pets, { status: 200 })
    });
}

export async function PATCH(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const options = {
    cookies: await cookies()
  }

  return withValidationAndErrorHandling(
    "PATCH",
    req,
    updatePetSchema,
    async (updates) => {
      const { id } = await params;
      const updated = await PetRepository.updateById(id, updates as Partial<PetType>, options);
      if (!updated) {
        return NextResponse.json(
          { success: false, message: "Mascota no encontrada" },
          { status: 404 }
        );
      }
      return NextResponse.json(
        { success: true, message: "Actualizado correctamente" },
        { status: 200 }
      );
    }
  );
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const options = {
    cookies: await cookies()
  }

  return getWithErrorHandling(req, async () => {
    const { id } = await params;
    const deleted = await PetRepository.deleteById(id, options);
    if (!deleted) {
      throw new RepositoryError("Mascota no encontrada");
    }
    return NextResponse.json(
      { success: true, message: "Eliminado correctamente" },
      { status: 200 }
    );
  });
} 
----- Archivo: route.ts ----- 
// src/app/api/plans/current/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PlanRepository } from "@/repos/index";
import { getWithErrorHandling } from "@/services/apiService";
import { cookies } from "next/headers";

export async function GET(req: NextRequest) {
  const options = {
    cookies: await cookies()
  }

  return getWithErrorHandling(req, async () => {
    const plans = await PlanRepository.getAllCurrent(options);
    return NextResponse.json({ success: true, plans });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/plans/subscriptions/route.ts
import { NextRequest, NextResponse } from "next/server";
import { SubscriptionRepository } from "@/repos/index";
import { withValidationAndErrorHandling } from "@/services/apiService";
import { CreateSubscriptionType } from "@/types/index";
import { cookies } from "next/headers";
import { SubscriptionInsertSchema } from "@/schemas/validationSchemas";

export async function POST(req: NextRequest) {
  const options = {
    cookies: await cookies()
  }

  return withValidationAndErrorHandling("POST", req, SubscriptionInsertSchema, async (data: CreateSubscriptionType) => {
    const result = await SubscriptionRepository.create(data, options);
    return NextResponse.json({ success: true, subscription: result });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/plans/subscription/[ownerId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { SubscriptionRepository } from "@/repos/index";
import { getWithErrorHandling } from "@/services/apiService";
import { cookies } from "next/headers";

export async function GET(req: NextRequest, { params }: { params: Promise<{ ownerId: string }> }) {
    const options = {
        cookies: await cookies()
    }

  return getWithErrorHandling(req, async () => {
    const { ownerId } = await params;
    const subscription = await SubscriptionRepository.getActiveByOwner(ownerId, options);
    return NextResponse.json({ success: true, data: subscription });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/veterinarians/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withValidationAndErrorHandling } from '@/services/apiService';
import { RepositoryError } from '@/types/lib';
import type { VeterinarianType } from '@/types/index';
import { VeterinarianTypeSchema } from '@/schemas/validationSchemas';
import VeterinarianRepository from '@/repos/veterinarian.repository';
import { cookies } from "next/headers";

export async function POST(req: NextRequest) {
  const options = {
    cookies: await cookies()
  }

    return withValidationAndErrorHandling(
        'POST',
        req,
        VeterinarianTypeSchema,
        async (vetData: VeterinarianType) => {
            try {
                const { data, error } = await VeterinarianRepository.create(vetData, options);
                if (error) {
                    console.log(error);
                    throw new RepositoryError(
                        `Error creating veterinarian: ${JSON.stringify(vetData)}`
                    );
                }
                return NextResponse.json(data, { status: 201 });
            } catch (err) {
                console.log(err);
                throw new RepositoryError('Error creating veterinarian');
            }
        }
    );
}
 
----- Archivo: route.tsx ----- 
// app/api/pets/[id]/route.tsx
import { NextResponse } from "next/server";
import { PetRepository, PetCodeRepository } from "@/repos/index";
import { cookies } from "next/headers";

interface UpdateBody {
  code: string;
  name?: string;
  image?: string;
}
export async function PUT(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const options = {
    cookies: await cookies()
  }

  try {
    const { id } = await params;
    const { code, ...updates } = (await req.json()) as UpdateBody;
    if (!code) {
      return NextResponse.json({ error: "Código requerido." }, { status: 400 });
    }

    // 1) Validar código
    const codeData = await PetCodeRepository.find(code, options);
    if (!codeData) {
      return NextResponse.json({ error: "Código inválido." }, { status: 401 });
    }
    if (new Date(codeData.expires_at) < new Date()) {
      return NextResponse.json(
        { error: "Código expirado." },
        { status: 410 }
      );
    }
    if (codeData.pet_id !== id) {
      return NextResponse.json(
        { error: "Código no corresponde a esta mascota." },
        { status: 403 }
      );
    }

    // 2) Actualizar pet
    await PetRepository.updateById(id, updates, options);
    return NextResponse.json({ success: true });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
} 
----- Archivo: route.tsx ----- 
// app/api/vet/use-code/route.ts
import { NextResponse } from "next/server";
import { PetCodeRepository, VeterinaryAccessRepository } from "@/repos/index";

export async function POST(req: Request) {

  try {
    const {
      code,
      firstName,
      firstLastName,
      secondLastName,
      identification,
      registration,
      clinicName,
      city,
    } = await req.json();
    // 1) Obtener y validar código
    const data = await PetCodeRepository.find(code);
    if (!data) {
      return NextResponse.json({ error: "Código inválido" }, { status: 404 });
    }
    const now = new Date().toISOString();
    if (data.used) {
      return NextResponse.json({ error: "Código ya utilizado" }, { status: 410 });
    }
    if (data.expires_at < now) {
      return NextResponse.json({ error: "Código expirado" }, { status: 410 });
    }
    // 2) Marcar como usado
    await PetCodeRepository.markUsed(code);

    // 3) Registrar acceso veterinario
    const vetAccess = await VeterinaryAccessRepository.create({
      pet_id: data.pet_id,
      pet_code_id: data.id,
      vet_first_name: firstName,
      vet_first_last_name: firstLastName,
      vet_second_last_name: secondLastName,
      identification: identification,
      professional_registration: registration,
      clinic_name: clinicName,
      city,
    });

    // 4) Devolver petId
    const response = NextResponse.json({ success: true, pet_id: data.pet_id, pet_code: data.id, vet_access: vetAccess.id });

    // Establecemos una cookie con el acceso temporal
    response.cookies.set('lampo-vet-access', JSON.stringify({ petId: data.pet_id }), {
      path: '/',
      httpOnly: true, // La cookie no es accesible desde JS en el cliente
      sameSite: 'lax',
      maxAge: 3600, // La sesión temporal dura 1 hora
    });
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Error interno" },
      { status: 500 }
    );
  }
}
 
----- Archivo: route.ts ----- 
// src/app/api/validar-matricula/route.ts

import { NextRequest, NextResponse } from 'next/server';
import ComvezcolRepository from '@/repos/comvezcol.repository'; // Importa el nuevo repositorio

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const { matricula } = body as { matricula?: string };

        if (!matricula || typeof matricula !== 'string') {
            return NextResponse.json({ message: 'El campo "matricula" es requerido.' }, { status: 400 });
        }

        // Llama al método del repositorio
        const { data, error } = await ComvezcolRepository.validate(matricula);

        if (error) {
            // El repositorio ya nos da el mensaje y el status adecuado
            return NextResponse.json({ message: error.message }, { status: error.status });
        }

        return NextResponse.json(data, { status: 200 });

    } catch (e) {
        // Captura errores inesperados que no sean del repositorio
        console.error("Error inesperado en el handler:", e);
        return NextResponse.json({ message: 'Error interno del servidor.' }, { status: 500 });
    }
} 
----- Archivo: route.ts ----- 
// src/app/api/vet-access/validate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { PetCodeRepository, PetRepository, VeterinaryAccessRepository } from "@/repos/index";
import { getRequiredQueryParam, getWithErrorHandling } from "@/services/apiService";
import { cookies } from "next/headers";

export async function GET(req: NextRequest) {
  const options = {
    cookies: await cookies()
  }

  return getWithErrorHandling(req, async () => {
    const code = getRequiredQueryParam(req, "code");

    // 1. Validar código
    const codeRecord = await PetCodeRepository.find(code, options);
    if (!codeRecord) {
      return NextResponse.json({ success: false, message: "Código inválido." }, { status: 404 });
    }

    // 2. Validar expiración
    if (new Date(codeRecord.expires_at) < new Date()) {
      return NextResponse.json({ success: false, message: "Código expirado." }, { status: 403 });
    }

    // 3. Buscar mascota
    const pet = await PetRepository.findById(codeRecord.pet_id, options);
    if (!pet) {
      return NextResponse.json({ success: false, message: "Mascota no encontrada." }, { status: 404 });
    }

    // 4. Buscar acceso del veterinario (si existe)
    const vetAccess = await VeterinaryAccessRepository.findByCodeAndByPetId(code, pet.id, options);

    return NextResponse.json({
      success: true,
      pet,
      codeRecord,
      vetAccess
    });
  });
}
 
----- Archivo: route.ts ----- 
// src/app/api/vet/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import VeterinarianRepository from '@/repos/veterinarian.repository';
import { getWithErrorHandling, withValidationAndErrorHandling } from '@/services/apiService';
import { QueryParamError, RepositoryError } from '@/types/lib';
import { cookies } from "next/headers";
import { VeterinarianType } from '@/types/index';
import { VeterinarianTypeSchema } from '@/schemas/validationSchemas';
import { createServerClient } from '@/lib/auth';

export async function GET(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    const options = {
        cookies: await cookies()
    }

    return getWithErrorHandling(
        req,
        async () => {
            const { id } = await context.params;
            if (!id) {
                throw new QueryParamError('Falta parámetro VeterinarianId');
            }

            const vetData = await VeterinarianRepository.findById(id, options);
            if (!vetData) {
                throw new RepositoryError(`Veterinario no encontrado: ${id}`);
            }
            return NextResponse.json(vetData);
        }
    );
}


export async function PUT(
    req: NextRequest,
    context: { params: Promise<{ id: string }> }
) {
    const options = {
        cookies: await cookies()
    }
    const serverClient = await createServerClient(options.cookies);

    return withValidationAndErrorHandling(
        'PUT',
        req,
        VeterinarianTypeSchema, // Usamos el schema existente para validar el payload completo
        async (vetData: VeterinarianType) => {
            const { id } = await context.params;

            // Verificación de seguridad: el usuario logueado solo puede modificar su propio perfil.
            const { data: { user } } = await serverClient.getUser();
            if (!user || user.id !== id) {
                return NextResponse.json({ success: false, message: 'No autorizado para modificar este perfil.' }, { status: 403 });
            }

            // Aseguramos que el vet_id del payload sea el correcto
            vetData.vet_id = id;

            try {
                const { error } = await VeterinarianRepository.update(vetData, options);

                if (error) {
                    throw new RepositoryError(`Error actualizando veterinario: ${error.message}`);
                }

                // Devolvemos el objeto actualizado para que el frontend pueda usarlo
                return NextResponse.json({ success: true, veterinarian: vetData }, { status: 200 });

            } catch (err) {
                if (err instanceof Error) {
                    throw new RepositoryError(err.message);
                }
                throw new RepositoryError('Error desconocido al actualizar el veterinario');
            }
        }
    );
} 
----- Archivo: layout.tsx ----- 
// app/pages/auth/verify/layout.tsx
export default function AuthVerifyLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/pages/auth/verify/page.tsx
"use client";
import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { authClient } from "@/lib/auth";
import { Loading } from "@/components/index";

export default function VerifyEmailPage() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [message, setMessage] = useState("Verificando tu correo… Por favor espera.");
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const access_token = searchParams.get("access_token");
    const refresh_token = searchParams.get("refresh_token");
    //const type = searchParams.get("type"); // ej. 'signup', 'recovery', 'magiclink'
    const error_description = searchParams.get("error_description");

    if (error_description) {
      setMessage(`Error: ${error_description}`);
      setIsLoading(false);
      setTimeout(() => router.replace("/login"), 5000);
      return;
    }

    const handleSessionFromURL = async () => {
      if (access_token && refresh_token) {
        try {
          await authClient.setSession({ access_token, refresh_token });
          router.replace("/pages/owner/register");
        } catch (err) {
          console.error("Error al establecer sesión desde URL:", err);
          setMessage("Hubo un problema al verificar tu sesión. Serás redirigido al login.");
          setTimeout(() => router.replace("/login"), 3000);
        } finally {
          setIsLoading(false);
        }
      } else {
        checkExistingSession();
      }
    };

    const checkExistingSession = async () => {
      try {
        const session = await authClient.getSession();
        if (session) {
          router.replace("/pages/owner/register");
        } else {
          setMessage("No se pudo verificar la sesión. Es posible que el enlace haya expirado o ya haya sido utilizado. Serás redirigido al login.");
          setTimeout(() => router.replace("/login"), 5000);
        }
      } catch (err) {
        console.error("Error al verificar sesión existente:", err);
        setMessage("Error al verificar tu estado. Serás redirigido al login.");
        setTimeout(() => router.replace("/login"), 3000);
      } finally {
        setIsLoading(false);
      }
    };

    const { data: authListener } = authClient.onAuthStateChange(
      async (event, session) => {
        if (event === "SIGNED_IN" && session) {
          setIsLoading(false);
          router.replace("/pages/owner/register");
          authListener?.unsubscribe();
        } else if (event === "INITIAL_SESSION") {
          authListener?.unsubscribe();
          handleSessionFromURL();
        } else if (event === 'USER_UPDATED' && session) {
          setIsLoading(false);
          router.replace("/pages/home");
          authListener?.unsubscribe();
        }
      }
    );

    const fallbackTimer = setTimeout(() => {
      if (isLoading) {
        authListener?.unsubscribe();
        console.log("Fallback: onAuthStateChange no capturó SIGNED_IN por hash, intentando con query params.");
        handleSessionFromURL();
      }
    }, 1500); // Esperar 1.5 segundos

    return () => {
      authListener?.unsubscribe();
      clearTimeout(fallbackTimer);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [router, searchParams]);

  if (isLoading) {
    return <Loading />;
  }

  return (
    <div style={{ padding: "2rem", textAlign: "center", maxWidth: '500px', margin: 'auto' }}>
      <h1>Verificación</h1>
      <p>{message}</p>
      {!isLoading && <button onClick={() => router.push('/login')}>Ir a Iniciar Sesión</button>}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
import Navbar from "./components/Navbar";
import Hero from "./components/Hero";
import About from "./components/About";
import Carousel from "./components/Carousel";
import Categories from "./components/Categories";
import Experience from "./components/Experience";
import BenefitsTabs from "./components/BenefitsTabs";
import InfoSection from "./components/InfoSection";
import Footer from "./components/Footer";
import styles from "./landing.module.css";

export default function LandingPage() {
    return (
        <div className={styles.landing_wrapper} style={{ overflowX: 'hidden' }}>
            <Navbar />
            <main className="no-select">
                <Hero />
                <About>
                    <Carousel />
                </About>
                <Categories />
                <Experience />
                <BenefitsTabs />
                <InfoSection />
            </main>
            <Footer />
        </div>
    );
}
 
----- Archivo: landing.module.css ----- 
/* Header/Navbar */
.header_section {
    width: 100vw;
    background: #fff;
    border-bottom: 1px solid #eee;
    position: sticky;
    top: 0;
    z-index: 100;
    padding: 0;
}

.navbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 1280px;
    margin: 0 auto;
    padding: 1.5rem 2rem;
}

.brand {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary);
}

.nav_links {
    display: flex;
    gap: 2.5rem;
    list-style: none;
    margin: 0;
}

.nav_links a {
    color: var(--primary);
    font-weight: 500;
    text-decoration: none;
    letter-spacing: 0.5px;
    transition: color 0.2s;
}

.nav_links a:hover {
    color: var(--primary-dark);
}

/* Hero Section */
.hero_section {
    display: flex;
    min-height: 60vh;
    background: var(--pico-primary);
    color: #fff;
}

.hero_grid {
    display: flex;
    width: 100%;
    max-width: 1280px;
    margin: 0 auto;
    padding: 4rem 2rem 2rem 2rem;
    align-items: center;
    justify-content: space-between;
}

.hero_content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.hero_content h1 {
    font-family: var(--font-title);
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 0.8rem;
    color: #fff;
    line-height: 1.1;
}

.hero_content p {
    font-size: 1.15rem;
    color: #e9f4f4;
    max-width: 430px;
}

.hero_btns {
    margin-top: 1.5rem;
}

.btn2 {
    background-color: var(--primary-inverse);
    color: var(--pico-primary);
    padding: 0.75rem 2rem;
    border-radius: 24px;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1rem;
    border: none;
    transition: background 0.2s;
    cursor: pointer;
}

.btn2:hover {
    background: var(--primary-dark);
    color: var(--primary-inverse);
}

.btn3 {
    background-color: var(--pico-primary);
    color: var(--primary-inverse);
    padding: 0.75rem 2rem;
    border-radius: 24px;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1rem;
    border: none;
    transition: background 0.2s;
    cursor: pointer;
}

.btn3:hover {
    background: var(--primary-darkblue);
    color: var(--primary-inverse)
}

.hero_image {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 300px;
}

.hero_image img {
    max-width: 420px;
    width: 100%;
    height: auto;
    filter: drop-shadow(0 8px 30px rgba(44, 44, 100, 0.07));
    background-color: white;
    border-radius: 50%;
    padding: 2rem;
}

/* About Section */
.about_section {
    background: #fff;
    padding: 4rem 0 2rem 0;
    width: 100%;
    display: flex;
}

.about_inner {
    display: block;
    max-width: 1080px;
    margin: 0 auto;
    gap: 3rem;
    align-items: flex-start;
    width: 40%;
    padding: 0 0 0 1rem;
}

.about_carousel {
    padding: 0 10rem 0 0;
}


@media (max-width: 2200px) {
    .about_carousel {
        padding: 0 5rem 0 0;
    }
}

@media (max-width: 1600px) {

    .about_inner {
        width: 100%;
        display: flex;
        padding-top: 1rem;
        padding-bottom: 1rem;
    }

    .about_section {
        display: block;
    }

    .about_carousel {
        background-color: var(--pico-primary);
        padding-top: 1rem;
        padding-bottom: 1rem;
    }

    .carouselBtn {
        color: var(--primary-inverse) !important;
    }
}

.about_image {
    flex: 1;
    display: flex;
    justify-content: center;
}

.about_image img {
    width: 320px;
    max-width: 90vw;
}

.about_text {
    flex: 2;
    padding-right: 1.5rem;
}

.about_text h2 {
    font-size: 2rem;
    color: var(--primary-dark);
    font-weight: bold;
    margin-bottom: 0.3rem;
}

.about_text h3 {
    font-size: 1.1rem;
    font-weight: 600;
    color: #333;
    margin-bottom: 1rem;
}

.about_text p {
    font-size: 1rem;
    color: #2a2a2a;
    line-height: 1.7;
}

/* Carousel */
.carousel {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 900px;
    /* <--- Límite del carrusel en desktop */
    margin: 0 auto;
    gap: 0.5rem;
    /* Solo para las flechas */
}

.carouselBtn {
    background: none;
    border: none;
    color: var(--primary);
    font-size: 2rem;
    cursor: pointer;
    padding: 0 1rem;
    transition: color 0.2s;
}

.carouselBtn:hover {
    color: var(--primary-dark);
}

.carouselCard {
    background: #fff;
    border-radius: 24px;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.09);
    padding: 2rem;
    width: 100%;
    max-width: 680px;
    /* <--- Card MUCHO más grande */
    min-width: 280px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    transition: max-width 0.2s, padding 0.2s;
}

@media (max-width: 900px) {

    .carousel,
    .carouselCard {
        max-width: 98vw;
        padding: 1rem;
    }
}

@media (max-width: 650px) {
    .carouselCard {
        max-width: 98vw;
        min-width: 0;
        padding: 0.8rem;
    }
}


.carouselCard img {
    border-radius: 50%;
    margin-bottom: 1.2rem;
}

.carouselCard h2 {
    margin-bottom: 0.8rem;
    color: var(--primary);
    font-size: 1.4rem;
    font-weight: 700;
}

.carouselCard p {
    font-size: 1rem;
    color: #444;
}

.carouselIndicators {
    margin-top: 1.5rem;
    display: flex;
    gap: 0.4rem;
    justify-content: center;
    width: 100%;
}

.dot,
.activeDot {
    display: inline-block;
    width: 20px;
    height: 20px;
    border-radius: 999px;
    background: #ccc;
    cursor: pointer;
}

.activeDot {
    background: var(--pico-contrast);
    -webkit-user-select: none;
    /* Safari */
    -ms-user-select: none;
    /* IE 10 and IE 11 */
    user-select: none;
    /* Standard syntax */
}

/* Categories */
.category_section {
    background: var(--section-bg);
    padding: 4rem 0;
    width: 100%;
}

.heading_container {
    text-align: center;
    margin-bottom: 2.5rem;
}

.heading_container h2 {
    font-size: 2rem;
    color: var(--primary-dark);
    font-weight: 700;
}

.category_container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 2.5rem;
    max-width: 1000px;
    margin: 0 auto;
}

.category_box {
    background: #fff;
    border-radius: 18px;
    padding: 2rem 1rem;
    box-shadow: 0 2px 18px rgba(0, 0, 0, 0.07);
    text-align: center;
}

.category_box img {
    width: 90px;
    margin-bottom: 1.2rem;
}

.category_box h3 {
    color: var(--primary);
    font-size: 1.15rem;
    margin-bottom: 0.4rem;
}

.category_box p {
    font-size: 1rem;
    color: #555;
}

/* Experience */
.experience_section {
    background: #fff;
    padding: 4rem 0 2rem 0;
}

.experience_grid {
    display: flex;
    align-items: center;
    max-width: 1080px;
    margin: 0 auto;
    gap: 2.5rem;
    flex-wrap: wrap;
}

.experience_grid>div {
    flex: 1;
    min-width: 280px;
}

.experience_grid img {
    max-width: 340px;
    width: 100%;
    margin: 0 auto;
    display: block;
}

.experience_grid h2 {
    font-size: 1.7rem;
    color: var(--primary-dark);
    font-weight: 700;
    margin-bottom: 0.8rem;
}

.experience_grid p {
    color: #333;
    margin-bottom: 1rem;
}

.experience_btns {
    margin-top: 1.1rem;
}

/* Benefits (Tabs) */
.benefits_section {
    background: var(--section-bg);
    padding: 4rem 0;
}

.benefits_grid {
    display: flex;
    max-width: 1080px;
    margin: 0 auto;
    display: flex;
    gap: 3.5rem;
    align-items: center;
}

.benefits_tabs {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
    margin-bottom: 2rem;
}

.benefit_tab {
    display: flex;
    align-items: center;
    gap: 1.1rem;
    background: #fff;
    border-radius: 14px;
    padding: 1rem;
    cursor: pointer;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.07);
    transition: background 0.15s;
}

.benefit_tab img {
    width: 42px;
}

.benefit_tab h3 {
    font-size: 1rem;
    margin: 0;
    color: #222;
}

.benefit_tab.active,
.benefit_tab:hover {
    background: var(--primary);
    color: #fff;
}

.benefit_tab.active h3,
.benefit_tab:hover h3 {
    color: #fff;
}

.benefit_image_box img {
    width: 340px;
    max-width: 95vw;
    margin: 0 auto;
    display: block;
    border-radius: 10px;
}

/* Info Section */
.info_section {
    background: var(--footer-bg);
    color: #fff;
    padding: 2.2rem 0 0.5rem 0;
    margin: 0
}

.info_top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 1080px;
    margin: 0 auto 2.2rem auto;
    padding: 0 2rem;
}

.info_logo {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1.2rem;
}

.social_box {
    display: flex;
    gap: 1.2rem;
}

.social_box img {
    width: 28px;
    filter: grayscale(1) brightness(1.3);
    opacity: 0.92;
}

.info_links {
    max-width: 1080px;
    margin: 0 auto 1rem auto;
    padding: 0 2rem;
}

.info_links h5 {
    font-size: 1.08rem;
    color: #fff;
    font-weight: 600;
    margin-bottom: 0.6rem;
}

.info_links ul {
    list-style: none;
    padding: 0;
    display: flex;
    gap: 1.4rem;
}

.info_links li a {
    color: #fff;
    text-decoration: underline;
    font-size: 1rem;
    opacity: 0.9;
}

.info_contact {
    max-width: 1080px;
    margin: 1.2rem auto 0 auto;
    padding: 0 2rem 1.3rem 2rem;
    display: flex;
    gap: 2.4rem;
    flex-wrap: wrap;
}

.info_contact>div {
    display: flex;
    align-items: center;
    gap: 0.7rem;
    font-size: 1rem;
    opacity: 0.9;
}

.info_contact img {
    width: 20px;
}

/* Footer */
.footer_section {
    background: var(--primary-darkblue);
    color: var(--primary-inverse);
    padding: 1.2rem 0 0.6rem 0;
    text-align: center;
    width: 100%;
    font-size: 0.92rem;
    letter-spacing: 0.2px;
    margin: 0;
}

/* RESPONSIVE */
@media (max-width: 900px) {

    .hero_grid,
    .about_inner,
    .experience_grid,
    .benefits_grid {
        flex-direction: column;
        align-items: flex-start;
        gap: 2rem;
    }

    .hero_section {
        min-height: 50vh;
    }

    .hero_content h1 {
        font-size: 2rem;
    }
}

@media (max-width: 650px) {
    .navbar {
        flex-direction: column;
        gap: 1rem;
        padding: 1rem 0.4rem;
    }

    .hero_grid {
        padding: 2rem 0.6rem 1.2rem 0.6rem;
    }

    .about_inner,
    .experience_grid,
    .benefits_grid {
        padding: 0 0.4rem;
    }

    .category_container {
        grid-template-columns: repeat(4, 1fr);
        gap: 1.3rem;
    }

    .carouselCard {
        padding: 1rem;
        min-width: 180px;
        max-width: 98vw;
    }

    .footer_section {
        font-size: 0.88rem;
    }

    .info_top,
    .info_links,
    .info_contact {
        padding: 0 0.5rem;
    }

    .category_container{
        grid-template-columns: 'repeat(2, 1fr)';
    }

    .nav_links{
        display: 'block';
    }
} 
----- Archivo: About.tsx ----- 
// app/landing/components/About.tsx
import styles from "../landing.module.css";
import { ReactNode } from "react";

export default function About({ children }: { children: ReactNode }) {
    return (
        <section className={styles.about_section} id="about">
            <div className={styles.about_inner}>
                <div className={styles.about_image}>
                    <img src="/images/picnic.svg" alt="¿Qué es lampo?" width={400} />
                </div>
                <div className={styles.about_text}>
                    <h2>¿Qué es lampo?</h2>
                    <h3>¿Quiénes somos y por qué hacemos lo que hacemos?</h3>
                    <p>
                        Lampo es una plataforma que podrás usar desde una web o un teléfono, para almacenar, consultar y modificar las historias clínicas de tus mascotas, desde cualquier lugar con tu información en la nube segura, esta no permite alteraciones de la información con el tiempo, así tu mascota siempre tendrá toda su información completa y correcta. Podrás también crear alertas para controlar, cuándo administrar su medicina, sus consultas programadas, dieta, vacunas y hasta cuándo debes peinarlo. En lampo amamos nuestras mascotas y que más que eso son nuestros compañeros; y queremos verlos siempre saludables.<br /><br />
                        Somos un grupo de amigos que convive con sus amigos peludos, compañeros que nos inspiran a crear y mejorar por ellos, te los presentamos:
                    </p>
                </div>
            </div>
            <div className={styles.about_carousel}>
                {children}
            </div>
        </section>
    );
}
 
----- Archivo: BenefitsTabs.tsx ----- 
// app/landing/components/BenefitsTabs.tsx
"use client";
import { useState } from "react";
import styles from "../landing.module.css";

const tabs = [
    {
        title: "Control total sobre el historial de tu mascota",
        icon: "/images/admin-panel.png",
        image: "/images/report.svg",
    },
    {
        title: "Consultas desde cualquier lugar del mundo",
        icon: "/images/worldwide.png",
        image: "/images/globe.svg",
    },
    {
        title: "Registro inalterable, autorizado solo por veterinarios validados",
        icon: "/images/hyperlink.png",
        image: "/images/security.svg",
    },
    {
        title: "Tranquilidad para ti y bienestar para tu mascota",
        icon: "/images/pet.png",
        image: "/images/shelter.svg",
    },
];

export default function BenefitsTabs() {
    const [active, setActive] = useState(0);

    return (
        <section className={styles.benefits_section} id="features">
            <div className={styles.benefits_grid}>
                <div>
                    <h2>Beneficios</h2>
                    <div className={styles.benefits_tabs}>
                        {tabs.map((tab, idx) => (
                            <div
                                key={idx}
                                className={`${styles.benefit_tab} ${active === idx ? styles.active : ""}`}
                                onClick={() => setActive(idx)}
                                style={{ cursor: "pointer", marginBottom: "1rem" }}
                            >
                                <img src={tab.icon} alt="" width={48} />
                                <h3>{tab.title}</h3>
                            </div>
                        ))}
                    </div>
                </div>
                <div className={styles.benefit_image_box}>
                    <img src={tabs[active].image} alt={tabs[active].title} width={400} />
                </div>
            </div>
        </section>
    );
}
 
----- Archivo: Carousel.tsx ----- 
"use client";
import { useState } from "react";
import styles from "../landing.module.css";

const pets = [
    {
        name: "Camus",
        image: "/images/camus.png",
        description: (
            <>
                <b>Camus, el gato que maúlla con alma de trovador.</b><br />
                Camus no es un gato común, y él lo sabe. Un maullido que podría rivalizar con una ópera completa,
                Nació sin raza, pero con personalidad de sobra: miedoso cuando se enfrenta a lo desconocido,
                juguetón como un eterno cachorro. Aunque su tamaño pueda engañar, por dentro es todo corazón, con
                un alma dulce que busca caricias y atención a cada paso. Camus no es solo una mascota. Es un
                amigo, un compañero leal, un peludo filósofo que observa el mundo desde la ventana y luego lo
                comenta con un maullido. En esa casa no hay silencios incómodos, porque Camus siempre tiene algo
                que decir.
            </>
        ),
    },
    {
        name: "Polar",
        image: "/images/polar.png",
        description: (
            <>
                <b>Polar, es un perro escapista, un mago en todo aspecto.</b><br />
                Polar no es cualquier perrito, y créeme, él lo tiene clarísimo. Experto en besitos sorpresa, y
                detector oficial de manos libres para acariciar. La vida le puso a prueba desde los 20 días,
                cuando perdió a su mamá, pero fue alimentado cada dos horas, como si ya supiera que tenía un
                destino especial. Y desde pequeño dejó claro quién manda —spoiler: él— con esa energía, es un
                torbellino peludo que convierte cualquier rincón en una zona de amor. En casa, es puro amor. En el
                parque, el alma de la fiesta. Polar no es solo un perro, es una vibra: ternura, travesura y
                corazón en cuatro patas.
            </>
        ),
    },
    {
        name: "Arya",
        image: "/images/arya.png",
        description: (
            <>
                <b>Arya, una princesa saltarina que supera desafíos.</b><br />
                Arya no empezó la vida fácil. Con sus patitas de “perro nadador”, muchos pensaron que no
                caminaría. Pero ella decidió que no estaba aquí para rendirse. Superó eso, y cuando la vida le
                quitó el movimiento de la cola, también le plantó cara. Después fue madre. Perdió a uno, pero le
                dio amor infinito a los que quedaron. Arya es la princesa de la casa. Dulce, sí. Pero con
                carácter. Ama su pancita sobada, su historia no se cuenta con lástima, se celebra con orgullo.
                Porque Arya es eso: una historia de amor que no se rinde.
            </>
        ),
    },
    {
        name: "Toby",
        image: "/images/toby.png",
        description: (
            <>
                <b>Toby, un perro celosamente amoroso.</b><br />
                Toby es el sabio de la casa, el más viejo, el más tierno. Tiene una obsesión encantadora con los
                gatos y un corazón enorme, aunque no le pidas que comparta su cama o sus juguetes —esas son cosas
                sagradas. Vivió en la calle, sí, pero ahora vive en el amor. Desde que fue adoptado, no hay día
                que no agradezca con esa mirada tranquila, esa pata que pone encima tuyo para decirte: &quot;ya basta,
                es hora de quererme&quot;. Es el perro fiel que todos sueñan tener. Educado, juguetón, algo celoso, y
                con un ladrido raro que nadie le discute. Aunque sus riñones lo obliguen a una dieta especial, su
                alma es libre, feliz, y más viva que nunca. Toby es eso: el amor hecho perro.
            </>
        ),
    },
    {
        name: "Happy",
        image: "/images/happy.png",
        description: (
            <>
                <b>Happy, un gato amante de las delicatessen.</b><br />
                Happy no es cualquier gato. Es un sobreviviente con alma de drama y diente dulce: su debilidad, la
                sandía. Una vez lo encontraron con la boca roja, parado junto a la evidencia como si nada.
                Culpable, sí. Arrepentido, jamás. A veces exige mimos como una diva mimada, en otras simplemente
                observa con desdén felino. Tiene gustos peculiares (sí, de esos que no se comentan en cenas
                familiares), pero jamás pierde la elegancia. Happy es muchas cosas: extraño, encantador y
                ligeramente ridículo.
            </>
        ),
    },
    {
        name: "Pelusa",
        image: "/images/pelusa.png",
        description: (
            <>
                <b>Pelusa, la gata peligrosamente diva.</b><br />
                Pelusa nació en el campo, pero la ciudad le sienta como a una reina. Desde que llegó, dejó claro
                que no era una más: es la matrona, la diva, la que camina como si cada pasillo fuera pasarela.
                Siempre impecable, siempre altiva. Aprendió a defenderse desde pequeña y no le tiemblan los
                bigotes para poner límites. Tiene carácter: no le gusta compartir espacios, ni camas, ni
                protagonismo. Pelusa no es solo una gata, es presencia. Una reina sin corona —porque no la
                necesita.
            </>
        ),
    },
    {
        name: "Gaia",
        image: "/images/gaia.png",
        description: (
            <>
                <b>Gaia, la gatita atrevidamente cariñosa.</b><br />
                Gaia no llegó a la colonia con una bienvenida, pero eso a ella no le importó. Se ganó su lugar con
                garras, mirada fija y cero disculpas. Desde pequeña era una mezcla curiosa: cariñosa de a ratos,
                arisca cuando le daba la gana, pero siempre con esa elegancia felina que impone respeto. Le
                encantaba dar besitos y amasar el pecho de sus humanos como quien marca territorio con ternura.
                Hoy, es el alma de la fiesta: juguetona, preciosa, talento especial y nunca pasa desapercibida.
                Todos la aman, claro, pero también la respetan. Porque con ella, se juega cuando ella quiere... y
                se le adora sin condiciones.
            </>
        ),
    },
    {
        name: "Cherry",
        image: "/images/cherry.png",
        description: (
            <>
                <b>Cherry, la suave gata sin prejuicios.</b><br />
                Cherry es puro amor envuelto en suavidad. Fue rescatada, una historia dura —dos ratas, y un
                destino que cambió justo a tiempo—, y desde entonces no ha conocido más que cariño y calor de
                hogar. Desde que alguien cruza la puerta, ella es la primera en saludar, como si supiera que el
                amor se devuelve con más amor. Le da igual si la aplastan o si ella es la que ocupa toda la cama,
                mientras que haya compañía. Ahora, con cuerpo de peluche y dieta “controlada”, ha aprendido el
                arte de derretirse en el piso para exigir caricias. Cherry no solo es una gata: es un regalo, una
                presencia suave que llena la casa de ternura, mañas y esa vibra dulce de quien sabe que fue
                salvada… y decidió quedarse para amar.
            </>
        ),
    },
    {
        name: "Oni",
        image: "/images/oni.png",
        description: (
            <>
                <b>Oni, una felina madre adoptiva, intensa con su amor.</b><br />
                Oni llegó con una patita quemada, chiquita y frágil, pero con una ternura que desbordaba fuerza.
                Sus humanos no lo dudaron: la abrazaron con todo el amor que tenían, y ella les devolvió el gesto
                convirtiéndose en el corazón suave de la casa. Fue más que una hermana para los otros gatos: fue
                mamá, cuidadora, guía. Los consiente y los regaña. Dormir con ellos no es solo costumbre, es su
                forma de protegerlos, Oni es educada, tranquila y tan graciosa sin proponérselo, uno no puede más
                que sonreír con ella. Cada vez que encuentra una mano, exige caricias. Porque Oni, sin alardes, es
                ejemplo, amor y dulzura hecha gata.
            </>
        ),
    },
];

export default function Carousel() {
    const [current, setCurrent] = useState(0);
    const total = pets.length;

    const prev = () => setCurrent((c) => (c === 0 ? total - 1 : c - 1));
    const next = () => setCurrent((c) => (c === total - 1 ? 0 : c + 1));

    return (
        <>
            <div className={styles.carousel}>
                <button className={styles.carouselBtn} onClick={prev} aria-label="Anterior">
                    &#8592;
                </button>
                <div className={styles.carouselCard} style={{ height: '920px !important', minWidth: '250px !important' }}>
                    <img src={pets[current].image} alt={pets[current].name} width={200} />
                    <h2>
                        <b>{pets[current].name}</b>
                    </h2>
                    <p style={{ textAlign: "justify" }}>{pets[current].description}</p>
                </div>
                <button className={styles.carouselBtn} onClick={next} aria-label="Siguiente">
                    &#8594;
                </button>
            </div>
            <div className={styles.carouselIndicators}>
                {pets.map((_, i) => (
                    <span
                        key={i}
                        className={i === current ? styles.activeDot : styles.dot}
                        onClick={() => setCurrent(i)}
                    ></span>
                ))}
            </div>
        </>
    );
}
 
----- Archivo: Categories.tsx ----- 
// app/landing/components/Categories.tsx
import styles from "../landing.module.css";

const categories = [
    {
        name: "Mascotas",
        image: "/images/pets.png",
        description: "La información médica de tus mascotas en solo lugar.",
    },
    {
        name: "Veterinaria",
        image: "/images/vet.png",
        description: "Lleva el control veterinario de tu mascota sin importar donde sea atendido.",
    },
    {
        name: "Historias clínicas",
        image: "/images/clinic-history.png",
        description: "Organiza tratamientos, vacunas y seguimientos con claridad y accesibilidad sin importar donde te encuentres.",
    },
    {
        name: "Trazabilidad",
        image: "/images/traceability.png",
        description: "Registros inalterables, seguros y siempre disponibles desde cualquier lugar.",
    },
];

export default function Categories() {
    return (
        <section className={styles.category_section} id="category">
            <div className={styles.heading_container}>
                <h2>Categorías</h2>
            </div>
            <div className={styles.category_container}>
                {categories.map((cat) => (
                    <div key={cat.name} className={styles.category_box}>
                        <img src={cat.image} alt={cat.name} width={150} />
                        <h3><b>{cat.name}</b></h3>
                        <p>{cat.description}</p>
                    </div>
                ))}
            </div>
        </section >
    );
}
 
----- Archivo: Experience.tsx ----- 
// app/landing/components/Experience.tsx
import styles from "../landing.module.css";

export default function Experience() {
    return (
        <section className={styles.experience_section}>
            <div className={styles.experience_grid}>
                <div>
                    <img src="/images/computer.svg" alt="Computadora" width={350} />
                </div>
                <div>
                    <h2>¡Sé parte del futuro de la salud animal!</h2>
                    <p>
                        Estamos en fase de desarrollo y queremos que seas de los primeros en probar Lampo.
                    </p>
                    <b>Contáctanos y descubre como puedes hacer parte de nuestro equipo de fundadores, queremos escucharte</b>
                    <div className={styles.experience_btns}>
                        <a href="mailto:a.aulestia@exe.com.co" className={styles.btn3}>Contactar</a>
                    </div>
                </div>
            </div>
        </section>
    );
}
 
----- Archivo: Footer.tsx ----- 
import styles from "../landing.module.css";

export default function Footer() {
    return (
        <footer className={styles.footer_section}>
            <div className="container">
                <p style={{ color: "var(--primary-inverse)" }}>
                    &copy; {new Date().getFullYear()} Todos los derechos reservados Lampo
                </p>
            </div>
        </footer >
    );
}
 
----- Archivo: Hero.tsx ----- 
import Image from "next/image";
import styles from "../landing.module.css";

export default function Hero() {
    return (
        <section className={styles.hero_section} id="home">
            <div className={styles.hero_grid}>
                <div>
                    <h1>
                        <b style={{ color: "var(--primary-inverse)" }}>Lampo</b> es una herramienta que <br />
                        ayudará a TU MASCOTA en sus proceso clínicos y veterinarios
                    </h1>
                    <p>
                        Accede y gestiona la historia clínica de tu mascota desde cualquier lugar, de forma segura y confiable.
                    </p>
                    <div className={styles.hero_btns}>
                        {/* Oculta Probar Gratis como en el HTML */}
                        {/* <a className={styles.btn1} style={{ display: "none" }}>Probar gratis</a> */}
                        <a className={styles.btn2} href="mailto:a.aulestia@exe.com.co">
                            Contactar ahora
                        </a>
                    </div>
                </div>
                <div className={styles.hero_image}>
                    <Image src="/images/petting.svg" alt="Petting" width={400} height={400} />
                </div>
            </div>
        </section>
    );
}
 
----- Archivo: InfoSection.tsx ----- 
// app/landing/components/InfoSection.tsx
import styles from "../landing.module.css";

export default function InfoSection() {
    return (
        <section className={styles.info_section}>
            <div className={styles.info_top}>
                <div className={styles.info_logo}>
                    <img src="/images/logo.png" alt="" width={32} />
                    <span>Lampo</span>
                </div>
                <div className={styles.social_box}>
                    <a href="#"><img src="/images/tiktok.png" alt="TikTok" width={24} /></a>
                    <a href="#"><img src="/images/instagram.png" alt="Instagram" width={24} /></a>
                    <a href="#"><img src="/images/youtube.png" alt="YouTube" width={24} /></a>
                </div>
            </div>
            <div className={styles.info_links}>
                <h5>Enlaces útiles</h5>
                <ul>
                    <li><a href="#about">¿Qué es Lampo?</a></li>
                    <li><a href="#features">Beneficios</a></li>
                    <li><a href="#category">Categorias</a></li>
                    <li><a href="/login">Log In</a></li>
                </ul>
            </div>
            <div className={styles.info_contact}>
                <div>
                    <img src="/images/location.png" alt="" width={24} />
                    <span>Bogotá</span>
                </div>
                <div>
                    <img src="/images/mail.png" alt="" width={24} />
                    <span>a.aulestia@exe.com.co</span>
                </div>
                <div>
                    <img src="/images/call.png" alt="" width={24} />
                    <span>Cel: +57 314 606 1490</span>
                </div>
            </div>
        </section>
    );
}
 
----- Archivo: Navbar.tsx ----- 
// /app/landing/components/Navbar.tsx
import styles from "../landing.module.css";
import Image from "next/image";

export default function Navbar() {
    return (
        <header className={styles.header_section}>
            <nav className={styles.navbar}>
                <div className={styles.brand}>
                    <Image src="/images/logo.png" width={40} height={40} alt="Lampo Logo" />
                    <span>Lampo</span>
                </div>
                <ul className={styles.nav_links}>
                    <li><a href="#about">¿Qué es Lampo?</a></li>
                    <li><a href="#features">Beneficios</a></li>
                    <li><a href="#category">Categorias</a></li>
                    <li><a href="/login">Log In</a></li>
                </ul>
            </nav>
        </header>
    );
}
 
----- Archivo: layout.tsx ----- 
// app/login/layout.tsx
export default function LoginLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/login/page.tsx
"use client";
import React, { FormEvent, useState, useEffect } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import Image from "next/image";

import type { OwnerDataType } from "@/types/index";
import { FaEye, FaEyeSlash } from "react-icons/fa";
import ModalComponent from "@/components/lib/modal";
import { authClient } from "@/lib/auth";
import { useSessionContext } from "@/context/SessionProvider";
import { useTranslation } from "react-i18next";
import dynamic from "next/dynamic";
import { CountryCodeInput } from "@/components/index";
import { Country, City } from 'country-state-city';
import type { ICountry, ICity } from 'country-state-city';
import { v4 as uuidv4 } from 'uuid';

// Importamos el MapPicker de forma dinámica
const MapPicker = dynamic(() => import('@/components/forms/MapPicker'), {
  ssr: false,
  loading: () => <p>Cargando mapa...</p>
});

export default function LoginPage() {

  const BOGOTA_COORDS = { lat: 4.60971, lng: -74.08175 };

  const router = useRouter();
  const { db: session, setSession } = useSessionContext();
  const { t: translate } = useTranslation('errors');

  const t = (error?: string): string => {
    const errorMsg = error ?? "";
    return translate(errorMsg, { defaultValue: translate('default') })
  }

  // Estados comunes
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isRegistering, setIsRegistering] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [infoMessage, setInfoMessage] = useState(""); // Para mensajes como "Revisa tu correo"
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  // Estados adicionales para registro
  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "Bogotá",
    country: "CO",
    email: "", // Se llenará desde el campo de email común
    latitude: BOGOTA_COORDS.lat,
    longitude: BOGOTA_COORDS.lng,
  });

  const [phone, setPhone] = useState<string | undefined>("+57");
  const [countries, setCountries] = useState<ICountry[]>([]);
  const [cities, setCities] = useState<ICity[]>([]);

  // Cargar lista de países al montar
  useEffect(() => {
    setCountries(Country.getAllCountries());
  }, []);

  // Actualizar lista de ciudades cuando cambia el país
  useEffect(() => {
    if (ownerInfo.country) {
      setCities(City.getCitiesOfCountry(ownerInfo.country) || []);
    }
  }, [ownerInfo.country]);

  useEffect(() => {
    if (!ownerInfo.address) return;

    const handler = setTimeout(async () => {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(ownerInfo.address || '')}&format=json&limit=1`);
        const data = await response.json();
        if (data && data.length > 0) {
          const { lat, lon } = data[0];
          setOwnerInfo(prev => ({ ...prev, latitude: parseFloat(lat), longitude: parseFloat(lon) }));
        }
      } catch (e) {
        console.error("Error de geocodificación:", e);
      }
    }, 1000); // Debounce de 1 segundo para no hacer llamadas en cada tecleo

    return () => clearTimeout(handler);
  }, [ownerInfo.address]);

  // Geocodificación Inversa (Coordenadas -> Ciudad/País)
  useEffect(() => {
    if (!ownerInfo.latitude || !ownerInfo.longitude) return;
    const fetchLocationData = async () => {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${ownerInfo.latitude}&lon=${ownerInfo.longitude}&format=json&accept-language=es`);
        const data = await response.json();
        if (data && data.address) {
          const countryCode = data.address.country_code.toUpperCase();
          setOwnerInfo(prev => ({ ...prev, country: countryCode }));

          const cityName = data.address.city || data.address.town || data.address.village;
          if (cityName) {
            setOwnerInfo(prev => ({ ...prev, city: cityName  }));
          }
        }
      } catch (e) {
        console.error("Error de geocodificación inversa:", e);
      }
    };
    fetchLocationData();
  }, [ownerInfo.latitude, ownerInfo.longitude]);

  // Redirigir si ya hay sesión
  useEffect(() => {
    if (session) {
      router.replace("/pages/home"); // O a la página de dashboard
    }
  }, [session, router]);


  const handleAuth = async (e: FormEvent) => {
    e.preventDefault();
    setError("");
    setInfoMessage("");
    setLoading(true);

    try {
      if (isRegistering) {
        // 1) Registro vía authClient
        const { data: signUpData, error: signUpError } = await authClient.signUp(email, password, 'owner');

        if (signUpError || !signUpData?.user) {
          setError(t(signUpError?.message) || "Error al registrar el usuario. Inténtalo de nuevo.");
          setLoading(false);
          return;
        }

        const ownerId = signUpData.user.id;

        // 2) Guardar datos del owner (esto SÍ requiere tu API `api/owners`)
        if (ownerId) {
          // Usar fetch directamente o tu wrapper `postFetch` si aún lo tienes para otras APIs
          const response = await fetch('/api/owners', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              ...ownerInfo,
              owner_id: ownerId,
              phone: phone,
              email
            }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            setError(t(errorData.message) || "Error creando el perfil del dueño.");
            // Considerar un rollback o manejo de error si el perfil no se crea después del auth.
            setLoading(false);
            return;
          }
        }
        if (signUpData.user && !signUpData.user.email_confirmed_at) {
          setShowConfirmModal(true);
        } else if (signUpData.user?.email_confirmed_at) {
          router.push('/pages/owner/register');
        }

      } else {
        // Inicio de sesión
        const { data: signInData, error: signInError } = await authClient.signIn(email, password);

        if (signInError || !signInData?.session) {
          setError(t(signInError?.message) || "Email o contraseña incorrectos.");
          setLoading(false);
          return;
        }
        setSession(signInData.session);

        router.replace('/pages/home');
      }
    } catch (err) {
      console.error("Auth CATCH block error:", err);
      setError("Ocurrió un error inesperado. Por favor, inténtalo de nuevo.");
    }
    setLoading(false);
  };

  const handleResetPassword = async () => {
    setError("");
    setInfoMessage("");
    if (!email) {
      setError("Ingresa tu correo para restablecer la contraseña.");
      return;
    }
    setLoading(true);
    try {
      const { error: resetError } = await authClient.resetPassword(email);
      if (resetError) {
        setError(resetError.message || "Error al enviar el correo de recuperación.");
      } else {
        setInfoMessage("Revisa tu correo para restablecer la contraseña.");
      }
    } catch {
      setError("Ocurrió un error inesperado.");
    }
    setLoading(false);
  };

  const goToVetPage = () => {
    router.replace("/vet-access"); // Usar router.push
  }

  const handleModalContinue = async () => {
    setShowConfirmModal(false);
    setLoading(true);
    const currentSession = await authClient.getSession();
    if (currentSession) {
      router.push("/pages/owner/register");
    } else {
      setInfoMessage("Si ya confirmaste tu correo, intenta iniciar sesión.");
    }
    setLoading(false);
  }

  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal}
        hideClose={true}
      >
        <button
          className="contrast"
          onClick={handleModalContinue}
          style={{ width: "100%", marginTop: "1rem" }}
          aria-busy={loading}
          disabled={loading}
        >
          {loading ? "Verificando..." : "Ya confirmé, continuar"}
        </button>
      </ModalComponent>
    );
  }

  return (
    <main
      style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        minHeight: "100vh",
        background: "var(--primary-ligthgray)",
        padding: "1rem",
      }}
    >
      <article
        style={{
          background: "var(--primary-inverse)",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px var(--primary-lighttransparent)",
          width: "100%",
          maxWidth: "550px",
        }}
      >
        <form onSubmit={handleAuth}> {/* Formulario interno */}
          <div style={{ textAlign: "center", marginBottom: "1.5rem" }}>
            <Image loading={"lazy"} src="/logo.png" alt="Lampo" width="150" height="48" style={{ width: "auto", height: "auto", marginBottom: '10px' }} />
            <h1>{isRegistering ? "Regístrate" : "Inicia sesión"}</h1>
          </div>

          {isRegistering && (
            <>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                {/* Campos de OwnerInfo */}
                <label htmlFor="name">
                  Nombre
                  <input id="name" type="text" autoComplete="given-name" value={ownerInfo.name || ""} onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })} required />
                </label>
                <label htmlFor="lastname">
                  Apellido
                  <input id="lastname" type="text" autoComplete="family-name" value={ownerInfo.last_name || ""} onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })} required />
                </label>
                <label htmlFor="phone">
                  Teléfono
                  <CountryCodeInput value={phone} onChange={setPhone} />
                </label>
                <label htmlFor="country">
                  País
                  <select id="country" value={ownerInfo.country || ''} onChange={e => setOwnerInfo({ ...ownerInfo, country: e.target.value })} required>
                    <option value="" disabled>Selecciona...</option>
                    {countries.map(c => <option key={c.isoCode} value={c.isoCode}>{c.name}</option>)}
                  </select>
                </label>

                {/* Fila 3 */}
                <label htmlFor="city">
                  Ciudad
                  <input list="cities-list" id="city" type="text" value={ownerInfo.city || ""} onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })} required disabled={!ownerInfo.country} />
                  <datalist id="cities-list">
                    {cities.map(c => <option key={uuidv4()} value={c.name} />)}
                  </datalist>
                </label>
                <label htmlFor="address">
                  Dirección
                  <input id="address" type="text" value={ownerInfo.address || ""} onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })} required />
                </label>
              </div>

              {/* Mapa */}
              <div style={{ marginTop: '1rem', marginBottom: '1rem' }}>
                <small>Haz clic en el mapa o arrastra el marcador para ajustar tu ubicación.</small>
                <MapPicker
                  coords={{ lat: ownerInfo.latitude!, lng: ownerInfo.longitude! }}
                  onCoordsChange={({ lat, lng }) => setOwnerInfo(prev => ({ ...prev, latitude: lat, longitude: lng }))}
                />
              </div>
            </>
          )}

          <label htmlFor="email">
            Email
            <input id="email" type="email" autoComplete="email" value={email} onChange={(e) => setEmail(e.target.value)} required />
          </label>

          <label htmlFor="password" style={{ position: 'relative', display: 'block', marginBottom: '1rem' }}>
            Contraseña
            <input
              id="password"
              type={showPassword ? "text" : "password"}
              autoComplete={isRegistering ? 'new-password' : 'current-password'}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              style={{ paddingRight: '3rem' }} // Espacio para el ícono
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
              style={{
                position: 'absolute',
                right: '0.5rem',
                top: 'calc(50% + 8px)',
                transform: 'translateY(-50%)',
                background: 'none',
                border: 'none',
                padding: '0.25rem',
                cursor: 'pointer',
                color: 'var(--primary-darkgray)'
              }}
            >
              {showPassword ? <FaEyeSlash size={20} /> : <FaEye size={20} />}
            </button>
          </label>

          {error && <p role="alert" style={{ color: "var(--pico-form-element-invalid-active-border-color, red)", marginTop: "0.5rem" }}>{error}</p>}
          {infoMessage && <p role="status" style={{ color: "var(--pico-primary)", marginTop: "0.5rem" }}>{infoMessage}</p>}


          <button type="submit" disabled={loading} aria-busy={loading} style={{ width: "100%", marginTop: "1rem" }}>
            {loading ? (isRegistering ? "Registrando..." : "Accediendo...") : (isRegistering ? "Registrarse" : "Entrar")}
          </button>
        </form>

        {!isRegistering && (
          <p style={{ textAlign: "right", marginTop: "0.5rem" }}>
            <button type="button" onClick={handleResetPassword} className="contrast" disabled={loading} style={{ background: "none", border: "none", padding: 0, cursor: "pointer", color: "var(--pico-primary)" }}>
              ¿Olvidaste tu contraseña?
            </button>
          </p>
        )}

        <p style={{ textAlign: "center", padding: 0 }}>
          {isRegistering ? "¿Ya tienes cuenta?" : "¿No tienes cuenta?"}
          <button type="button" onClick={() => { setIsRegistering(!isRegistering); setError(""); setInfoMessage(""); }} disabled={loading} style={{ background: "none", border: "none", color: "var(--pico-primary)", cursor: "pointer", marginLeft: "0.25rem", textDecoration: "underline", padding: 0 }}>
            {isRegistering ? "Inicia sesión" : "Regístrate"}
          </button>
        </p>

        {!isRegistering && (
          <p style={{ textAlign: "center", padding: 0 }}>
            <button type="button" onClick={goToVetPage} disabled={loading} style={{ background: "none", border: "none", color: "var(--pico-primary)", cursor: "pointer", textDecoration: "underline", padding: 0 }}>
              Soy médico veterinario sin registro
            </button>
          </p>
        )}
      </article>
    </main >
  );
} 
----- Archivo: index.ts ----- 
// app/pages/index.tsx
export { default as BasicDataPage } from "./pet/basic-data/page";
export { default as CalendarPage } from "./owner/calendar/page";
export { default as ConditionsPage } from "./pet/conditions/page";
export { default as LabTestsPage } from "./pet/lab-tests/page";
export { default as LoginPage } from "../login/page";
export { default as MedicinesPage } from "./pet/medicines/page";
export { default as SettingsPage } from "./owner/settings/page";
export { default as UpgradePage } from "./owner/upgrade/page";
export { default as VaccinesPage } from "./pet/vaccines/page";
export { default as VetPage } from "./vet/[code]/page";
export { default as OwnerSettings } from "./owner/settings/page"; 
----- Archivo: page.tsx ----- 
// src/app/pages/home/page.tsx
"use client";
import React from "react";
import {
  FaCalendar, FaUser, FaSyringe, FaCut, FaPills, FaCloudSun,
  FaFlask, FaCog, FaPlusCircle, FaPaw,
} from "react-icons/fa";
import {
  FaUserDoctor, FaPencil,
} from "react-icons/fa6";
import { FeatureLink, Loading } from "@/components/index";
import { useRoleContext } from "@/context/RoleProvider";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { usePetProfileProgress } from '@/hooks/usePetProfileProgress'; // IMPORTADO

export default function HomePage() {
  const { isOwner, isVet, isVetWithSession } = useRoleContext();
  const { setShowVetPetCodeModal, setShowAddPetModal, setShowEditPetModal } = useUI();
  const { storedPet } = useStorageContext();
  const { isLoading: isLoadingSession } = useSessionContext();
  const progress = usePetProfileProgress(); // USADO

  if (isLoadingSession) {
    return <Loading />;
  }

  return (
    <main className="container" style={{ maxWidth: 700, margin: "3rem auto" }}>
      <section style={{ textAlign: "center", marginBottom: "2.5rem" }}>
        <h1 style={{ color: 'var(--pico-primary)' }}>Lampo: Gestión clínica de mascotas</h1>
        <p>
          Lampo es la plataforma digital que centraliza el historial médico, agenda y gestión de mascotas, permitiendo a dueños y veterinarios acceder y actualizar información de forma sencilla, segura y colaborativa.
        </p>
      </section>

      <section>
        <h2 style={{ marginBottom: "1.2rem", color: 'var(--pico-primary)' }}>¿Qué puedes hacer en Lampo?</h2>
        <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
          {isOwner &&
            <FeatureLink
              icon={<FaPaw />}
              click={() => setShowAddPetModal(true)}
              href=""
              title="Agregar Mascota"
              desc="Registra una nueva mascota en tu perfil y comienza a gestionar su información clínica desde un solo lugar."
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaPencil />}
              click={storedPet.id ? () => setShowEditPetModal(true) : undefined}
              href=""
              title="Editar Mascota"
              desc="Actualiza la información de tus mascotas de manera fácil y segura."
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaCalendar />}
              href="/pages/owner/calendar"
              title="Calendario"
              desc="Visualiza y gestiona eventos, actividades y recordatorios de salud importantes de tus mascotas."
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaUser />}
              href="/pages/pet/basic-data"
              title="Datos básicos"
              desc="Consulta y edita los datos principales de cada mascota: nombre, raza, edad, propietario y más."
              isComplete={progress.basicData}
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaUserDoctor />}
              href={storedPet.id ? `/pages/pet/consultations/${storedPet.id}` : ''}
              title="Consultas veterinarias"
              desc="Visualiza las visitas médicas, diagnósticos y recomendaciones veterinarias."
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaSyringe />}
              href="/pages/pet/vaccines"
              title="Vacunas"
              desc="Lleva el control de las vacunas aplicadas, pendientes y genera recordatorios personalizados."
              isComplete={progress.vaccines}
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaCut />}
              href="/pages/pet/surgeries"
              title="Cirugías"
              desc="Registra intervenciones quirúrgicas, fechas, veterinario responsable y notas relevantes."
              isComplete={progress.surgeries}
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaPills />}
              href="/pages/pet/medicines"
              title="Medicinas"
              desc="Gestiona tratamientos, dosis, fechas y alertas de administración de medicamentos."
              isComplete={progress.medicines}
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaCloudSun />}
              href="/pages/pet/conditions"
              title="Condiciones especiales"
              desc="Anota alergias, condiciones crónicas u otros factores a tener en cuenta en el cuidado diario."
              isComplete={progress.conditions}
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaFlask />}
              href="/pages/pet/lab-tests"
              title="Exámenes de laboratorio"
              desc="Carga y consulta resultados de exámenes de laboratorio para mantener el historial clínico completo."
              isComplete={progress.labTests}
            />
          }
          {isVet &&
            <FeatureLink
              icon={<FaUserDoctor />}
              click={storedPet.id ? undefined : () => setShowVetPetCodeModal(true)}
              href={storedPet.id ? `/pages/pet/consultations/${storedPet.id}` : ''}
              title="Consultas veterinarias"
              desc="Visualiza y carga documentos de visitas médicas, diagnósticos y recomendaciones de tus pacientes."
            />
          }
          {isOwner &&
            <FeatureLink
              icon={<FaCog />}
              href="/pages/owner/settings"
              title="Configuraciones"
              desc="Personaliza tu perfil, gestiona usuarios y controla la privacidad y notificaciones (solo propietarios)."
            />
          }
          {isVet &&
            <FeatureLink
              icon={<FaPlusCircle />}
              click={storedPet.id ? undefined : () => setShowVetPetCodeModal(true)}
              href={storedPet.id ? `/pages/vet/consultation/${storedPet.id}` : ''}
              title="Agregar Consulta"
              desc="Puedes registrar nuevas consultas médicas para tus pacientes directamente desde aquí."
            />
          }
          {isVetWithSession &&
            <FeatureLink
              icon={<FaCog />}
              href="/pages/vet/settings"
              title="Configuración de Veterinario"
              desc="Actualiza tus datos de perfil profesional que se usan en las historias clínicas."
            />
          }
        </ul>
      </section>

      <section style={{ marginTop: "3rem", textAlign: "center" }}>
        <p>
          <strong style={{ color: 'var(--pico-primary)' }}>¿Listo para comenzar?</strong> Selecciona una sección en el menú o desde aquí para explorar todas las funciones de Lampo.
        </p>
      </section>
    </main>
  );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/calendar/page.tsx (server component)
"use client";
import { Title } from "@/components/index";
import { useRoleContext } from "@/context/RoleProvider";
import React from "react";
import { FaCalendar } from "react-icons/fa";

export default function CalendarPage() {
    const { isVet } = useRoleContext();

    if (isVet) {
        return <div>Página para Veterinarios en desarrollo.</div>
    }
    return (
        <div style={{ width: "100%" }}>
            {<Title icon={<FaCalendar />} title="Próximos eventos programados" />}
            <section style={{ width: "100%", marginBottom: "2rem" }}>
                {/* <input type="date" value="2025-01-01" /> */}
            </section>

            <section>
                <h3>Datos de contacto</h3>
                <div
                    style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fit, minmax(120px, auto))",
                        gap: "0.5rem",
                        alignItems: "center",
                        marginBottom: "1rem",
                        fontSize: "0.8rem"
                    }}
                >
                    <select>
                        <option>Last 12 months</option>
                        <option>Last 6 months</option>
                    </select>
                    <input type="date" defaultValue="2020-08-01" />
                    <span style={{ textAlign: "center" }}>a</span>
                    <input type="date" defaultValue="2020-07-07" />
                    <select>
                        <option>Previous period</option>
                    </select>
                    <select>
                        <option>Monthly</option>
                    </select>
                    <button>Edit charts</button>
                </div>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/owner/register/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { FaCheck } from "react-icons/fa";
import { PlanVersionType, SubscriptionType } from "@/types/index";
import { useRouter } from "next/navigation";
import { useSession } from "@/hooks/useSession";
import { getFetch, postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { Currency } from "@/utils/index";

export default function RegisterPage() {
    useSession();
    const router = useRouter();
    const [plans, setPlans] = useState<PlanVersionType[]>([]);
    const [cycles, setCycles] = useState<Record<string, "monthly" | "annual">>(
        {}
    );
    const [loading, setLoading] = useState<boolean>(false);
    const session = useSessionContext();
    const { setStoredSubscriptionData } = useStorageContext();

    useEffect(() => {
        async function load() {
            try {
                const response = await getFetch("/api/plans/current");
                const json = await response.json();
                if (json.success) {
                    const data = json.plans;
                    setPlans(data);

                    const initialCycles: Record<string, "monthly" | "annual"> = {};
                    data.forEach((p: PlanVersionType) => {
                        initialCycles[p.id.toString()] = "monthly";
                    });
                    setCycles(initialCycles);
                } else {
                    console.error("Error obteniendo planes:", json.message);
                }
            } catch (err) {
                console.error("Error en petición de planes:", err);
            }
        }
        load();
    }, []);

    // Validar sesión
    if (!session?.db?.user?.id) {
        console.error("No hay sesión activa o falta el user.id");
        return null;
    }

    const ownerId = session?.db?.user?.id;

    const handleCycle = (planId: string, cycle: "monthly" | "annual") => {
        setCycles((prev) => ({ ...prev, [planId]: cycle }));
    };

    const handleSelect = async (plan: PlanVersionType) => {
        setLoading(true);
        try {
            const cycle = cycles[plan.id.toString()];
            const priceAtPurchase = cycle === "annual" ? plan.price_year : plan.price_month;
            const discountApplied = cycle === "annual" ? plan.discount_year : plan.discount_month;

            const response = await postFetch("/api/plans/subscriptions", undefined, {
                ownerId,
                planVersionId: plan.id.toString(),
                cycle,
                priceAtPurchase,
                discountApplied
            });
            const json = await response.json();

            if (!response.ok || !json.success) {
                throw new Error(json.message || "Error al crear suscripción");
            }
            setStoredSubscriptionData(json.subscription as SubscriptionType);

            router.replace("/pages/home");
        } catch (e) {
            console.error("Error creando suscripción:", e);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main style={{ padding: "2rem", background: "var(--primary-inverse)" }}>
            <div
                style={{
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(260px, 1fr))",
                    gap: "1.5rem",
                }}
            >
                {plans.map((plan) => {
                    const key = plan.id.toString();
                    const cycle = cycles[key] || "monthly";
                    const isStandard = plan.slug === "standard";
                    const borderColor = "var(--pico-primary)";
                    const darkBg = isStandard;
                    const cardStyle: React.CSSProperties = darkBg
                        ? { background: "var(--primary-darkblue)", color: "var(--primary-inverse)", borderRadius: "8px" }
                        : { border: `2px solid ${borderColor}`, background: "var(--primary-inverse)", borderRadius: "8px" };

                    const discountMonthlyLabel =
                        plan.discount_month > 0 ? `${plan.discount_month}% Descuento` : undefined;
                    const discountYearLabel =
                        plan.discount_year > 0 ? `${plan.discount_year}% Descuento` : undefined;

                    return (
                        <article
                            key={plan.id}
                            style={{ ...cardStyle, padding: "2rem", position: "relative" }}
                        >
                            {plan.slug === "standard" && (
                                <span
                                    style={{
                                        position: "absolute",
                                        top: "1rem",
                                        left: "1rem",
                                        background: borderColor,
                                        color: "var(--primary-inverse)",
                                        fontSize: "0.75rem",
                                        padding: "0.25rem 0.75rem",
                                        borderRadius: "4px",
                                        textTransform: "uppercase",
                                    }}
                                >
                                    Popular
                                </span>
                            )}
                            {(plan.slug === "standard" || plan.slug === "advanced") && (
                                <div
                                    style={{
                                        display: "flex",
                                        border: darkBg ? "none" : `1px solid ${borderColor}`,
                                        borderRadius: "4px",
                                        overflow: "hidden",
                                        marginBottom: "1rem",
                                        background: darkBg ? "var(--primary--graytransparent)" : undefined,
                                    }}
                                >
                                    <button
                                        onClick={() => handleCycle(key, "monthly")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "monthly" ? "var(--primary-inverse)" : "lightgray",
                                            color: "var(--pico-contrast)",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                        }}
                                    >
                                        Mensual
                                        {cycle === "monthly" && discountMonthlyLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "var(--primary-yellow)",
                                                    color: "var(--pico-contrast)",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                    marginBottom: "10px"
                                                }}
                                            >
                                                {discountMonthlyLabel}
                                            </span>
                                        )}
                                    </button>
                                    <button
                                        onClick={() => handleCycle(key, "annual")}
                                        style={{
                                            flex: 1,
                                            padding: "0.5rem",
                                            background: cycle === "annual" ? "var(--primary-inverse)" : "lightgray",
                                            color: "var(--pico-contrast)",
                                            border: "none",
                                            cursor: "pointer",
                                            fontSize: "0.875rem",
                                            position: "relative",
                                        }}
                                    >
                                        Anual
                                        {cycle === "annual" && discountYearLabel && (
                                            <span
                                                style={{
                                                    position: "absolute",
                                                    top: "-0.5rem",
                                                    right: "0.5rem",
                                                    background: "var(--primary-yellow)",
                                                    color: "var(--pico-contrast)",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {discountYearLabel}
                                            </span>
                                        )}
                                    </button>
                                </div>
                            )}

                            <h3 style={{ marginTop: isStandard ? "2rem" : 0, marginBottom: "0.5rem", color: darkBg ? 'lightgray' : 'var(--pico-color)' }}>
                                {plan.title}
                            </h3>
                            <p
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1rem",
                                    opacity: darkBg ? 0.75 : 1,
                                    color: darkBg ? 'lightgray' : 'var(--pico-color)'
                                }}
                            >
                                {plan.description}
                            </p>

                            <div style={{ fontSize: "2rem", fontWeight: 700, marginBottom: "0.25rem", color: darkBg ? 'var(--primary-yellow)' : 'var(--pico-color)' }}>
                                {cycle === "annual"
                                    ? Currency.format(plan.price_year)
                                    : Currency.format(plan.price_month)}
                            </div>
                            <div
                                style={{
                                    fontSize: "0.875rem",
                                    marginBottom: "1.5rem",
                                    opacity: 0.75,
                                }}
                            >
                                {cycle === "annual"
                                    ? "Por usuario, por año"
                                    : "Por usuario, por mes"}
                            </div>

                            <ul style={{ listStyle: "none", padding: 0, marginBottom: "1.5rem" }}>
                                {plan.features.map((feat, idx) => (
                                    <li
                                        key={idx}
                                        style={{ display: "flex", alignItems: "center", marginBottom: "0.5rem" }}
                                    >
                                        <FaCheck
                                            style={{
                                                marginRight: "0.5rem",
                                                color: darkBg ? "var(--primary-yellow)" : borderColor,
                                            }}
                                        />
                                        <span style={{ fontSize: "0.875rem", color: darkBg ? 'lightgray' : 'var(--pico-color)' }}>{feat.text}</span>
                                        {feat.badge && (
                                            <span
                                                style={{
                                                    marginLeft: "0.5rem",
                                                    background: "var(--primary-green)",
                                                    color: "var(--primary-inverse)",
                                                    fontSize: "0.75rem",
                                                    padding: "0.25rem 0.5rem",
                                                    borderRadius: "4px",
                                                }}
                                            >
                                                {feat.badge}
                                            </span>
                                        )}
                                    </li>
                                ))}
                            </ul>

                            <button
                                onClick={() => handleSelect(plan)}
                                className="contrast"
                                style={{
                                    width: "100%",
                                    padding: "0.75rem",
                                    fontWeight: 600,
                                    fontSize: "1rem",
                                    opacity: loading || (plan.slug !== "free" && process.env.DISABLE_ALL_PLANS == 'true') ? 0.6 : 1,
                                    cursor: loading || (plan.slug !== "free" && process.env.DISABLE_ALL_PLANS == 'true') ? "not-allowed" : "pointer",
                                }}
                                disabled={loading || (plan.slug !== "free" && process.env.DISABLE_ALL_PLANS == 'true')}
                            >
                                {plan.slug === "free" ? "Selecciona este plan GRATIS" : "Continuar al pago"}
                            </button>
                        </article>
                    );
                })}
            </div>
        </main>
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/settings/page.tsx

"use client";
import { CountryCodeInput, Loading, Title } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch, putFetch } from "@/app/api";
import type { OwnerDataType, PetType } from "@/types/index";
import React, { FormEvent, useEffect, useRef, useState } from "react";
import { FaCog, FaExclamationTriangle } from "react-icons/fa";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { Empty } from "@/data/index";
import { useRouter } from "next/navigation";
import dynamic from "next/dynamic";
import { Country, City } from 'country-state-city';
import type { ICountry, ICity } from 'country-state-city';
import { v4 as uuidv4 } from 'uuid';
import { parsePhoneNumberFromString } from 'libphonenumber-js';

const MapPicker = dynamic(() => import('@/components/forms/MapPicker'), {
  ssr: false,
  loading: () => <p>Cargando mapa...</p>
});

export default function SettingsPage() {
  const { isMobile } = useDeviceDetect();
  const router = useRouter();
  const session = useSessionContext();
  const storage = useStorageContext();
  const userId = session?.db?.user.id;
  const userEmail = session?.db?.user.email;

  const BOGOTA_COORDS = { lat: 4.60971, lng: -74.08175 };

  const [ownerInfo, setOwnerInfo] = useState<Partial<OwnerDataType>>({
    name: "",
    last_name: "",
    phone: "",
    address: "",
    city: "",
    country: "",
    email: ""
  });
  const [phone, setPhone] = useState<string | undefined>();
  const [countries, setCountries] = useState<ICountry[]>([]);
  const [cities, setCities] = useState<ICity[]>([]);

  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [confirmText, setConfirmText] = useState("");
  // asumo que en tu contexto tienes la mascota seleccionada:
  const pet: PetType | null = storage.storedPet;

  const prevAddressRef = useRef<string | undefined>('');

  const [loadLoading, setLoadLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  useEffect(() => {
    if (!session || !userId) return;

    const fetchData = async () => {
      try {
        if (!storage.storedOwnerData.owner_id) {
          const res = await getFetch(`/api/owners/${encodeURIComponent(userId)}`);
          const json = await res.json();
          if (res.ok) {
            storage.setStoredOwnerData(json);
            setOwnerInfo(json);
            const phoneNumber = parsePhoneNumberFromString(json.phone || '');
            setPhone(phoneNumber ? phoneNumber.formatInternational() : json.phone);
            setPhone(json.phone || undefined);
          } else {
            console.error("Error al obtener owner:", json.error);
            setError("No se pudo cargar la información del dueño.");
            setFormFailed(true);
          }
        }
        else {
          setOwnerInfo(storage.storedOwnerData);
        }
      } catch (err) {
        console.error("Fetch owner error:", err);
        setError("Error de red al cargar datos.");
        setFormFailed(true);
      }
      finally {
        setLoadLoading(false);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [userId, session]);

  // Cargar listas de países y ciudades
  useEffect(() => {
    setCountries(Country.getAllCountries());
  }, []);

  useEffect(() => {
    if (ownerInfo.country) {
      setCities(City.getCitiesOfCountry(ownerInfo.country) || []);
    }
  }, [ownerInfo.country]);

  // Geocodificación (Dirección -> Coordenadas)
  useEffect(() => {
    if (loadLoading || !ownerInfo.address) return;

    if (ownerInfo.address === prevAddressRef.current) {
      return;
    }
    const handler = setTimeout(async () => {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(ownerInfo.address || '')}&format=json&limit=1`);
        const data = await response.json();
        if (data && data.length > 0) {
          const { lat, lon } = data[0];
          setOwnerInfo(prev => ({ ...prev, latitude: parseFloat(lat), longitude: parseFloat(lon) }));
        }
      } catch (e) {
        console.error("Error de geocodificación:", e);
      }
    }, 1000); // Debounce de 1 segundo para no hacer llamadas en cada tecleo

    prevAddressRef.current = ownerInfo.address;
    return () => clearTimeout(handler);
  }, [ownerInfo.address, loadLoading]);

  // Geocodificación Inversa (Coordenadas -> Ciudad/País)
  useEffect(() => {
    if (!ownerInfo.latitude || !ownerInfo.longitude) return;
    const fetchLocationData = async () => {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${ownerInfo.latitude}&lon=${ownerInfo.longitude}&format=json&accept-language=es`);
        const data = await response.json();
        if (data && data.address) {
          const countryCode = data.address.country_code.toUpperCase();
          const cityName = data.address.city || data.address.town || data.address.village;
          setOwnerInfo(prev => ({ ...prev, country: countryCode, city: cityName }));
        }
      } catch (e) {
        console.error("Error de geocodificación inversa:", e);
      }
    };
    const timer = setTimeout(fetchLocationData, 500);
    return () => clearTimeout(timer);
  }, [ownerInfo.latitude, ownerInfo.longitude]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!userId) {
      setError("Usuario no identificado.");
      setFormFailed(true);
      return;
    }

    try {
      if (userEmail) {
        const payload: OwnerDataType = {
          owner_id: userId,
          name: ownerInfo.name || "",
          last_name: ownerInfo.last_name || "",
          phone: phone!,
          address: ownerInfo.address || "",
          latitude: ownerInfo.latitude,
          longitude: ownerInfo.longitude,
          city: ownerInfo.city || "",
          country: ownerInfo.country || "",
          email: userEmail
        };

        const res = await putFetch('/api/owners', undefined, payload);
        const json = await res.json();

        if (res.ok) {
          setError("Datos actualizados correctamente.");
          storage.setStoredOwnerData(payload);
          setFormFailed(false);
        } else {
          console.error("API error:", json.error);
          setError(json.error || "Error al guardar los cambios.");
          setFormFailed(true);
        }
      }
    } catch (err) {
      console.error("Submit error:", err);
      setError("Error de red al guardar cambios.");
      setFormFailed(true);
    }
  };

  const handleDelete = async () => {
    if (!pet) return;
    const res = await fetch(`/api/pets/${encodeURIComponent(pet.id)}`, {
      method: "DELETE",
    });
    if (res.ok) {
      // actualizar lista en el contexto
      storage.setStoredOwnerPets(
        storage.storedOwnerPets.filter((p) => p.id !== pet.id)
      );
      storage.resetPet();
      storage.setStoredPet(Empty.Pet());
      router.replace("/pages/home");
    } else {
      console.error("Error al eliminar mascota");
    }
  };

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      <section style={{ marginBottom: "2rem" }}>
        <Title icon={<FaCog />} title="Configuración del dueño" />
        {loadLoading ? <Loading /> : (
          <form
            onSubmit={handleSubmit}
            style={{ display: "grid", gap: "1rem" }}
          >
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
              <label htmlFor="name">
                Nombre
                <input
                  id="name"
                  type="text"
                  autoComplete="given-name"
                  disabled={loadLoading}
                  value={ownerInfo.name || ""}
                  onChange={e => setOwnerInfo({ ...ownerInfo, name: e.target.value })}
                  required
                />
              </label>

              <label htmlFor="lastname">
                Apellido
                <input
                  id="lastname"
                  type="text"
                  autoComplete="family-name"
                  disabled={loadLoading}
                  value={ownerInfo.last_name || ""}
                  onChange={e => setOwnerInfo({ ...ownerInfo, last_name: e.target.value })}
                  required
                />
              </label>
            </div>

            {/* Fila 2: País y Ciudad */}
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
              <label htmlFor="country">
                País
                <select id="country" value={ownerInfo.country || ''} onChange={e => setOwnerInfo({ ...ownerInfo, city: '', country: e.target.value })} required>
                  <option value="" disabled>Selecciona...</option>
                  {countries.map(c => <option key={c.isoCode} value={c.isoCode}>{c.name}</option>)}
                </select>
              </label>
              <label htmlFor="city">
                Ciudad
                <input list="cities-list" id="city" type="text" value={ownerInfo.city || ""} onChange={e => setOwnerInfo({ ...ownerInfo, city: e.target.value })} required disabled={!ownerInfo.country} />
                <datalist id="cities-list">
                  {cities.map(c => <option key={uuidv4()} value={c.name} />)}
                </datalist>
              </label>
            </div>

            {/* Fila 3: Teléfono y Dirección */}
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
              <label htmlFor="phone">
                Teléfono
                <CountryCodeInput value={phone} onChange={setPhone} />
              </label>
              <label htmlFor="address">
                Dirección
                <input id="address" type="text" value={ownerInfo.address || ""} onChange={e => setOwnerInfo({ ...ownerInfo, address: e.target.value })} required />
              </label>
            </div>

            {/* Fila 4: Mapa */}
            <div>
              <label>Ubicación en el mapa</label>
              <small style={{ display: 'block', marginBottom: '0.5rem' }}>Haz clic o arrastra el marcador para ajustar la ubicación.</small>
              <MapPicker
                coords={{ lat: ownerInfo.latitude || BOGOTA_COORDS.lat, lng: ownerInfo.longitude || BOGOTA_COORDS.lng }}
                onCoordsChange={({ lat, lng }) => setOwnerInfo(prev => ({ ...prev, latitude: lat, longitude: lng }))}
              />
            </div>

            <button type="submit" disabled={loadLoading}>
              Guardar cambios
            </button>

            {error && (
              <p style={{ color: formFailed ? "var(--primary-red)" : "var(--primary-green)" }}>{error}</p>
            )}
          </form>
        )}
      </section>

      {/* ——— Sección Danger Zone para eliminar mascota ——— */}
      {pet && storage.storedPet.id && (
        <section
          style={{
            marginTop: "3rem",
            padding: "1rem",
            border: "1px solid var(--primary-red)",
            borderRadius: "6px",
          }}
        >
          <h3
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              color: "var(--primary-red)",
            }}
          >
            <FaExclamationTriangle /> Zona de peligro
          </h3>
          <p>Eliminar permanentemente la mascota seleccionada.</p>
          <button
            type="button"
            style={{
              backgroundColor: "var(--primary-red)",
              color: "var(--primary-inverse)",
              padding: "0.5rem 1rem",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
            onClick={() => setShowDeleteModal(true)}
          >
            Eliminar mascota
          </button>
        </section>
      )}

      {/* ——— Modal de confirmación ——— */}
      {showDeleteModal && pet && (
        <div
          style={{
            position: "fixed",
            inset: 0,
            backgroundColor: "var(--primary-darkertransparent)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            zIndex: 1000,
          }}
        >
          <div
            style={{
              background: "white",
              padding: "2rem",
              borderRadius: "6px",
              width: "90%",
              maxWidth: "400px",
            }}
          >
            <h2>Confirmar eliminación</h2>
            <p>
              Escribe el nombre de la mascota{" "}
              <strong>{pet.name}</strong> para confirmar:
            </p>
            <input
              type="text"
              placeholder="Nombre de la mascota"
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              style={{
                width: "100%",
                padding: "0.5rem",
                marginTop: "0.5rem",
                marginBottom: "1rem",
                border: "1px solid var(--primary-lightgray)",
                borderRadius: "4px",
              }}
            />
            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}
            >
              <button
                type="button"
                onClick={() => {
                  setShowDeleteModal(false);
                  setConfirmText("");
                }}
              >
                Cancelar
              </button>
              <button
                type="button"
                disabled={confirmText !== pet.name}
                style={{
                  backgroundColor: "var(--primary-red)",
                  color: "var(--primary-inverse)",
                  padding: "0.5rem 1rem",
                  border: "none",
                  borderRadius: "4px",
                  cursor:
                    confirmText === pet.name ? "pointer" : "not-allowed",
                  opacity: confirmText === pet.name ? 1 : 0.6,
                }}
                onClick={handleDelete}
              >
                Eliminar
              </button>
            </div>
          </div>
        </div>
      )}

    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// app/pages/owner/upgrade/page.tsx
"use client";
import React from "react";

export default function UpgradePage() {
    return (
        <div style={{ width: "100%" }}>
            <h2>Mejora tu plan</h2>
            <section style={{ width: "100%", marginBottom: "2rem" }}>
            </section>
        </div>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/basic-data/page.tsx (server component)
"use client";
import React, { useEffect, useState } from "react";
import { FaUser } from "react-icons/fa";
import { format } from "@/utils/dates";
import { BasicField, Loading, Title } from "@/components/index";
import { FieldType } from "@/types/lib";
import { BasicDataType, OwnerDataType } from "@/types/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { Empty } from "@/data/index";
import { Dates } from "@/utils/index";

export default function BasicDataPage() {
  const { isMobile } = useDeviceDetect();
  const storage = useStorageContext();
  const [petData, setPetData] = useState<BasicDataType | null>(null);
  const [ownerData, setOwnerData] = useState<OwnerDataType | null>(null);
  const [basicDataItems, setBasicDataItems] = useState<FieldType[]>([]);
  const [contactItems, setContactItems] = useState<FieldType[]>([]);

  useEffect(() => {
    const petId = storage.storedPet.id;
    if (!petId || storage.storedBasicData.pet_id) {
      setPetData(storage.storedBasicData);
      return;
    }

    const fetchData = async () => {
      try {
        // 1) Datos básicos de la mascota
        const resPet = await getFetch(`/api/pets/basic-data/${storage.storedPet.id}`);
        if (!resPet.ok) throw new Error("Falló fetch basic-data");
        const basicData: BasicDataType = await resPet.json();
        const pet = Empty.BasicData();
        pet.pet_id = 'x';
        if (!basicData) {
          setPetData(pet);
          storage.setStoredBasicData(pet);
        }
        else {
          setPetData(basicData);
          storage.setStoredBasicData(basicData);
        }
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedBasicData]);


  useEffect(() => {
    const ownerId = storage.storedPet.owner_id;
    if (!ownerId || storage.storedOwnerData.owner_id) {
      setOwnerData(storage.storedOwnerData);
      return;
    }
    const fetchData = async () => {
      try {
        const resOwner = await getFetch(`/api/owners/${storage.storedPet.owner_id}`);
        if (!resOwner.ok) throw new Error("Falló fetch owners");
        const owner: OwnerDataType = await resOwner.json();
        storage.setStoredOwnerData(owner);
        setOwnerData(owner);
      } catch (err) {
        console.error("Error cargando datos:", err);
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storage.storedOwnerData]);

  useEffect(() => {
    if (!petData) return;
    setBasicDataItems([
      { label: "Tipo de mascota", show: true, value: petData.pet_type },
      { label: "Edad", show: true, value: Dates.calculateAge(storage.storedPet.birth_date) },
      { label: "Género", show: true, value: petData.gender },
      { label: "Peso", show: true, value: petData.weight },
      { label: "Raza", show: true, value: petData.race },
      { label: "Tipo de pelaje", show: true, value: petData.coat_type },
      { label: "Color", show: true, value: petData.color },
      { label: "Alergias", show: true, value: petData.has_allergies ? 'Si' : 'No' },
      { label: "Condición de peso", show: true, value: petData.weight_condition },
      { label: "Tamaño", show: true, value: petData.size },
      { label: "Vive con otros", show: true, value: petData.lives_with_others ? 'Si' : 'No' },
      { label: "Comida principal", show: true, value: petData.main_food },
      { label: "Última vacuna", show: true, value: petData.has_vaccine ? (`${petData.last_vaccine_name} (${format(petData.last_vaccine_date)})`) : 'No tiene vacunas' },
      { label: "Esterilizado", show: true, value: petData.is_sterilized ? (`Sí (${format(petData.sterilization_date)})`) : 'No' },
      { label: "Antipulgas", show: true, value: petData.has_anti_flea ? (`Sí (${format(petData.anti_flea_date)})`) : 'No' },
      { label: "¿Usa medicina?", show: true, value: petData.uses_medicine ? 'Si' : 'No' },
      { label: "Condición especial", show: true, value: petData.special_condition ? 'Si' : 'No' },
    ]);
  }, [petData, storage.storedPet.birth_date]);


  useEffect(() => {
    if (!ownerData) return;
    setContactItems([
      { label: "Nombre del contacto", show: true, value: ownerData.name },
      { label: "Teléfono", show: ownerData.phone != null, value: ownerData.phone },
      { label: "Dirección", show: ownerData.address != null, value: ownerData.address },
      { label: "Ciudad", show: true, value: ownerData.city },
      { label: "País", show: true, value: ownerData.country },
      { label: "Email", show: true, value: ownerData.email },
    ]);
  }, [ownerData]);

  return (
    <main style={{ padding: isMobile ? "4rem 1rem 2rem" : "2rem", fontSize: "0.9rem", marginTop: isMobile ? "3.5rem" : "0" }}>
      {/* Datos básicos en tres columnas */}
      <section style={{ marginBottom: "2rem" }}>
        {<Title icon={<FaUser />} title="Datos básicos" />}
        {!petData &&
          <Loading />
        }
        {petData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "1rem" }}>
            {basicDataItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
      <section>
        {<Title icon={<FaUser />} title="Datos de contacto" />}
        {!ownerData &&
          <Loading />
        }
        {ownerData &&
          <div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "1rem" }}>
            {contactItems.map((item) =>
              <BasicField key={item.label} item={item} />
            )}
          </div>
        }
      </section>
    </main>
  );
}

 
----- Archivo: page.tsx ----- 
// app/pages/pet/conditions/page.tsx
"use client";
import React from "react";
import { FaCloudSun } from "react-icons/fa";
import { Page } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function ConditionsPage() {
    const storage = useStorageContext();
    return (
        <Page
            parentId={storage.storedPet.id}
            title="Condiciones especiales"
            icon={<FaCloudSun />}
            apiUrl={'/api/pets/list/conditions/'}
            storedList={storage.storedConditionData}
            setStoredList={storage.setStoredConditionData}
            emptyMessage="No hay registro de condiciones especiales."
            mapItemToFields={FieldData.ForConditions}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// src/app/pages/pet/consultations/[petId]/page.tsx
"use client";
import React, { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { PetType, ConsultationType } from '@/types/index';
import { getFetch } from '@/app/api';
import { Loading, DataNotFound, Title } from '@/components/index';
import { ConsultationDetailView } from '@/components/index';
import { FaNotesMedical, FaListAlt, FaArrowLeft } from 'react-icons/fa';
import { useStorageContext } from '@/context/StorageProvider';
import { useSessionContext } from '@/context/SessionProvider'; // Para verificar el veterinario logueado
import { Dates } from '@/utils/index';
import { useRoleContext } from '@/context/RoleProvider';

export default function PetConsultationsPage() {
    const params = useParams();
    const router = useRouter();
    const petId = params.petId as string;

    const { storedPet, setStoredPet } = useStorageContext();
    const { db: session } = useSessionContext(); // Usuario autenticado
    const { isOwner } = useRoleContext();

    const [pet, setPet] = useState<PetType | null>(storedPet.id === petId ? storedPet : null);
    const [consultations, setConsultations] = useState<ConsultationType[]>([]);
    const [selectedConsultation, setSelectedConsultation] = useState<ConsultationType | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (!petId) {
            setError("ID de mascota no proporcionado.");
            setLoading(false);
            return;
        }

        const fetchData = async () => {
            setLoading(true);
            try {
                // Cargar datos de la mascota si no están en el contexto o son diferentes
                if (!pet || pet.id !== petId) {
                    const petResponse = await getFetch(`/api/pets/${petId}`);
                    const petData = await petResponse.json();
                    if (!petResponse.ok || !petData) {
                        throw new Error(petData?.message || 'Mascota no encontrada');
                    }
                    setPet(petData);
                    setStoredPet(petData); // Actualizar contexto
                }

                // Cargar consultas
                const consultsResponse = await getFetch(`/api/consultations?petId=${petId}`);
                const consultsData = await consultsResponse.json();
                if (!consultsResponse.ok || !consultsData.success) {
                    throw new Error(consultsData?.message || 'Error cargando consultas');
                }
                setConsultations(consultsData.consultations || []);
            } catch (err) {
                setError(err instanceof Error ? err.message : "Error desconocido al cargar datos.");
            } finally {
                setLoading(false);
            }
        };
        fetchData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [petId, storedPet, setStoredPet]); // pet no es dependencia para evitar bucle si se actualiza dentro

    const handleSelectConsultation = (consultation: ConsultationType) => {
        setSelectedConsultation(consultation);
    };

    const handleBackToList = () => {
        setSelectedConsultation(null);
    };

    // Función para recargar los datos de la consulta seleccionada (útil después de añadir un archivo)
    const refreshSelectedConsultation = async () => {
        if (!selectedConsultation?.id) return;
        try {
            const response = await getFetch(`/api/consultations/${selectedConsultation.id}`);
            const result = await response.json();
            if (response.ok && result.success) {
                setSelectedConsultation(result.consultation);
                // Actualizar la lista general también
                setConsultations(prev => prev.map(c => c.id === result.consultation.id ? result.consultation : c));
            } else {
                console.error("Error recargando consulta:", result.message);
            }
        } catch (err) {
            console.error("Error recargando consulta:", err);
        }
    };


    if (loading) return <Loading />;
    if (error) return <DataNotFound message={error} />;
    if (!pet) return <DataNotFound message="Mascota no encontrada." />;

    return (
        <main style={{ padding: "2rem" }}>
            <Title
                icon={<FaNotesMedical />}
                title={selectedConsultation
                    ? `Detalle Consulta (${Dates.format(selectedConsultation.consultation_date)}) para ${pet.name}`
                    : `Historial de Consultas para ${pet.name}`}
            />

            {selectedConsultation ? (
                <div>
                    <button onClick={handleBackToList} className="outline secondary" style={{ marginBottom: '1rem' }}>
                        <FaArrowLeft style={{ marginRight: '0.5rem' }} /> Volver al Listado
                    </button>
                    <ConsultationDetailView
                        consultation={selectedConsultation}
                        currentUserId={session?.user?.id || null} // Para lógica de edición/añadir archivos
                        onFileAdded={refreshSelectedConsultation} // Callback para refrescar después de añadir archivo
                    />
                </div>
            ) : (
                <>
                    {consultations.length === 0 ? (
                        <DataNotFound message="No hay consultas registradas para esta mascota." />
                    ) : (
                        <div role="list" style={{ marginTop: '1rem' }}>
                            {consultations.map((consult) => (
                                <article
                                    key={consult.id}
                                    onClick={() => handleSelectConsultation(consult)}
                                    role="listitem"
                                    style={{
                                        marginBottom: '1rem',
                                        cursor: 'pointer',
                                        borderLeft: '5px solid var(--pico-primary)'
                                    }}
                                    className="pico-paper" // Usar alguna clase de Pico para el estilo de "papel"
                                >
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <strong>Motivo: {consult.reason_for_consultation.substring(0, 50)}{consult.reason_for_consultation.length > 50 ? '...' : ''}</strong>
                                        <span>{Dates.format(consult.consultation_date)} {consult.consultation_time}</span>
                                    </div>
                                    <small>HC#: {consult.hc_number || 'N/A'} - Institución: {consult.institution_name || 'N/A'}</small>
                                </article>
                            ))}
                        </div>
                    )}
                    {!isOwner &&
                        <button
                            onClick={() => router.push(`/pages/vet/consultation/${petId}`)}
                            style={{ marginTop: '1.5rem' }}
                        >
                            <FaListAlt style={{ marginRight: '0.5rem' }} /> Agregar Nueva Consulta
                        </button>
                    }
                </>
            )}
        </main>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/lab-tests/page.tsx
"use client";
import React from "react";
import { FaFlask } from "react-icons/fa";
import { Page } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function LabTestsPage() {
    const storage = useStorageContext();
    return (
        <Page
            parentId={storage.storedPet.id}
            title="Exámenes de laboratorio"
            icon={<FaFlask />}
            apiUrl={'/api/pets/list/lab-tests/'}
            storedList={storage.storedLabTestData}
            setStoredList={storage.setStoredLabTestData}
            emptyMessage="No hay registro de resultados de laboratorio."
            mapItemToFields={FieldData.ForLabTests}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaPills } from "react-icons/fa";
import { Page } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function MedicinesPage() {
    const storage = useStorageContext();
    return (
        <Page
            parentId={storage.storedPet.id}
            title="Medicinas"
            icon={<FaPills />}
            apiUrl={'/api/pets/list/medicines/'}
            storedList={storage.storedMedicineData}
            setStoredList={storage.setStoredMedicineData}
            emptyMessage="No hay registro de medicamentos."
            mapItemToFields={FieldData.ForMedicines}
        />
    );
}
 
----- Archivo: page.tsx ----- 
// app/pages/pet/register/page.tsx
export default function PetRegisterPage(){
    return <div></div>
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/surgeries/page.tsx
"use client";
import React from "react";
import { FaCut } from "react-icons/fa";
import { Page } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function SurgeriesPage() {
    const storage = useStorageContext();
    return (
        <Page
            parentId={storage.storedPet.id}
            title="Cirugías"
            icon={<FaCut />}
            apiUrl={'/api/pets/list/surgeries/'}
            storedList={storage.storedSurgeryData}
            setStoredList={storage.setStoredSurgeryData}
            emptyMessage="No hay registro de cirugías."
            mapItemToFields={FieldData.ForSurgeries}
        />
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/pet/vaccines/page.tsx
"use client";
import React from "react";
import { FaSyringe } from "react-icons/fa";
import { Page } from "@/components/index";
import { FieldData } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";

export default function VaccinesPage() {
  const storage = useStorageContext();
  return (
    <Page
      parentId={storage.storedPet.id}
      title="Vacunas"
      icon={<FaSyringe />}
      apiUrl={'/api/pets/list/vaccines/'}
      storedList={storage.storedVaccineData}
      setStoredList={storage.setStoredVaccineData}
      emptyMessage="No hay registro de vacunas."
      mapItemToFields={FieldData.ForVaccines}
    />
  );
}
 
----- Archivo: index.ts ----- 
// src/components/forms/consultation/index.ts
export * from './ConsultationForm';
export * from './FileUploadItem';
// También puedes exportar todas las secciones desde aquí si prefieres
// export * from './sections';  
----- Archivo: ConsultationForm.tsx ----- 
// src/components/forms/consultation/ConsultationForm.tsx
import React, { useState, forwardRef, useImperativeHandle } from 'react';
import type { PetType, CreateConsultationPayload, ConsultationProcedureType, ConsultationMedicationType, BasicDataType, OwnerDataType } from '@/types/index';
// ... (imports de secciones)
import { IdentitySection } from './sections/IdentitySection';
import { OwnerPetSection } from './sections/OwnerPetSection';
import { AnamnesisSection } from './sections/AnamnesisSection';
import { PhysicalExamSection } from './sections/PhysicalExamSection';
import { DiagnosticApproachSection } from './sections/DiagnosticApproachSection';
import { ComplementaryExamsSection } from './sections/ComplementaryExamsSection';
import { DiagnosisPlanSection } from './sections/DiagnosisPlanSection';
import { ProceduresSection } from './sections/ProceduresSection';
import { MedicationsSection } from './sections/MedicationsSection';
import { ObservationsSignatureSection } from './sections/ObservationsSignatureSection';
import { useStorageContext } from '@/context/StorageProvider';

interface ConsultationFormProps {
    pet: PetType;
    owner: OwnerDataType | null;
    basicData: BasicDataType | null;
    onSubmit: (formData: CreateConsultationPayload) => Promise<void>;
    isSubmitting: boolean;
}

// Usamos forwardRef para exponer la función de subida de archivos
export const ConsultationForm = forwardRef(({ pet, owner, basicData, onSubmit, isSubmitting }: ConsultationFormProps, ref) => {
    const { storedVetAccess } = useStorageContext();

    const [formData, setFormData] = useState<Partial<CreateConsultationPayload>>(() => {
        const today = new Date();
        const initialFormData: Partial<CreateConsultationPayload> = {
            consultation_date: today.toISOString().split('T')[0],
            consultation_time: today.toTimeString().split(' ')[0].substring(0, 5),
            procedures: [],
            medications: [],
            institution_name: '',
            hc_number: '',
            reason_for_consultation: '',
            current_diet: '',
            presumptive_diagnosis: '',
            therapeutic_plan: '',
        };
        const allExpectedFields: Array<keyof CreateConsultationPayload> = [
            'institution_name', 'hc_number', 'consultation_date', 'consultation_time',
            'reason_for_consultation', 'current_diet', 'previous_illnesses', 'previous_surgeries',
            'vaccination_history', 'last_deworming_product', 'recent_treatments', 'recent_travels',
            'animal_behavior_owner_description', 'lives_with_other_animals_details', 'sterilized_status',
            'birth_count', 'body_condition_score', 'temperature_celsius', 'heart_rate_bpm',
            'respiratory_rate_rpm', 'capillary_refill_time_sec', 'pulse_description',
            'mucous_membranes_description', 'hydration_percentage_description', 'sense_organs_description',
            'skin_and_coat_description', 'lymph_nodes_description', 'digestive_system_findings',
            'respiratory_system_findings', 'endocrine_system_findings', 'musculoskeletal_system_findings',
            'nervous_system_findings', 'urinary_system_findings', 'reproductive_system_findings',
            'rectal_palpation_findings', 'other_physical_findings', 'problem_list',
            'master_problem_list', 'differential_diagnoses', 'complementary_exams_summary',
            'presumptive_diagnosis', 'definitive_diagnosis', 'therapeutic_plan', 'prognosis',
            'evolution_notes', 'general_observations', 'signature_confirmation'
        ];
        allExpectedFields.forEach(field => {
            if (!(field in initialFormData)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (initialFormData as any)[field] = null;
            }
        });
        return initialFormData;
    });

    const [stagedFiles, setStagedFiles] = useState<File[]>([]);

    useImperativeHandle(ref, () => ({
        async triggerFileUploads(consultationId: string) {
            if (stagedFiles.length === 0) return;

            const uploadPromises = stagedFiles.map(file => {
                const formDataApi = new FormData();
                formDataApi.append('file', file);
                formDataApi.append('petId', pet.id);
                return fetch(`/api/consultations/${consultationId}/files`, {
                    method: 'POST',
                    body: formDataApi,
                });
            });

            const results = await Promise.allSettled(uploadPromises);

            results.forEach((result, index) => {
                if (result.status === 'rejected') {
                    console.error(`Error subiendo archivo ${stagedFiles[index].name}:`, result.reason);
                    // Aquí podrías notificar al usuario sobre los archivos que fallaron
                }
            });
            setStagedFiles([]); // Limpiar archivos en espera
        }
    }));


    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        let processedValue: string | number | boolean | null = value;

        if (type === 'checkbox') {
            processedValue = (e.target as HTMLInputElement).checked;
        } else if (type === 'number') {
            if (value === '') {
                processedValue = null;
            } else {
                const num = parseFloat(value);
                processedValue = isNaN(num) ? null : num;
            }
        }
        setFormData(prev => ({ ...prev, [name]: processedValue }));
    };

    const handleNumericChange = (name: keyof CreateConsultationPayload, value: string) => {
        const numValue = value === '' ? null : parseFloat(value);
        setFormData(prev => ({
            ...prev,
            [name]: numValue === null || isNaN(numValue as number) ? null : numValue,
        }));
    };

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
    const handleBasicDataChange = (field: keyof BasicDataType, value: any) => {
        // Esta función podría usarse si actualizamos `basicData` en tiempo real
        // Por simplicidad, el campo de peso lo manejará el `OwnerPetSection` directamente
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (!formData.reason_for_consultation || !formData.presumptive_diagnosis || !formData.therapeutic_plan) {
            alert("Por favor, complete todos los campos obligatorios: Motivo de Consulta, Diagnóstico Presuntivo y Plan Terapéutico.");
            return;
        }
        onSubmit(formData as CreateConsultationPayload);
    };

    const handleProceduresChange = (updatedProcedures: Array<Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>>) => {
        setFormData(prev => ({ ...prev, procedures: updatedProcedures }));
    };

    const handleMedicationsChange = (updatedMedications: Array<Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>>) => {
        setFormData(prev => ({ ...prev, medications: updatedMedications }));
    };

    const [openSection, setOpenSection] = useState<string | null>('identity');

    const handleToggleSection = (event: React.MouseEvent<HTMLElement>, sectionName: string) => {
        event.preventDefault();
        setOpenSection(prevOpenSection => prevOpenSection === sectionName ? null : sectionName);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 pico-form" style={{ marginTop: '2rem' }}>
            <details open={openSection === 'identity'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'identity')}>1. Identificación</summary>
                {openSection === 'identity' && <IdentitySection vetData={storedVetAccess} formData={formData} handleChange={handleChange} />}
            </details>

            <details open={openSection === 'ownerPet'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'ownerPet')}>2. Datos Propietario y Reseña Mascota</summary>
                {openSection === 'ownerPet' && <OwnerPetSection owner={owner} pet={pet} basicPetData={basicData} onBasicDataChange={handleBasicDataChange} />}
            </details>

            <details open={openSection === 'anamnesis'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'anamnesis')}>3. Anamnesis</summary>
                {openSection === 'anamnesis' && <AnamnesisSection formData={formData} handleChange={handleChange} handleNumericChange={handleNumericChange} basicData={basicData} />}
            </details>

            <details open={openSection === 'physicalExam'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'physicalExam')}>4. Exámenes físicos</summary>
                {openSection === 'physicalExam' && <PhysicalExamSection formData={formData} handleChange={handleChange} handleNumericChange={handleNumericChange} />}
            </details>

            <details open={openSection === 'procedures'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'procedures')}>5. Procedimientos en Consulta</summary>
                {openSection === 'procedures' && <ProceduresSection procedures={formData.procedures || []} onChange={handleProceduresChange} />}
            </details>

            <details open={openSection === 'medications'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'medications')}>6. Medicamentos en Consulta</summary>
                {openSection === 'medications' && <MedicationsSection medications={formData.medications || []} onChange={handleMedicationsChange} />}
            </details>

            <details open={openSection === 'diagnosticApproach'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'diagnosticApproach')}>7. Abordaje Diagnóstico</summary>
                {openSection === 'diagnosticApproach' && <DiagnosticApproachSection formData={formData} handleChange={handleChange} />}
            </details>

            <details open={openSection === 'complementaryExams'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'complementaryExams')}>8. Exámenes Complementarios</summary>
                {openSection === 'complementaryExams' && <ComplementaryExamsSection formData={formData} handleChange={handleChange} setStagedFiles={setStagedFiles} />}
            </details>

            <details open={openSection === 'diagnosisPlan'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'diagnosisPlan')}>9. Diagnóstico y Plan</summary>
                {openSection === 'diagnosisPlan' && <DiagnosisPlanSection formData={formData} handleChange={handleChange} />}
            </details>

            <details open={openSection === 'observations'}>
                <summary role="button" className="secondary outline" onClick={(e) => handleToggleSection(e, 'observations')}>10. Observaciones y Profesional</summary>
                {openSection === 'observations' && <ObservationsSignatureSection formData={formData} handleChange={handleChange} vetData={storedVetAccess} />}
            </details>

            <button type="submit" disabled={isSubmitting} aria-busy={isSubmitting} style={{ marginTop: '1.5rem' }}>
                {isSubmitting ? 'Guardando...' : 'Guardar Consulta'}
            </button>
        </form>
    );
});

ConsultationForm.displayName = "ConsultationForm"; 
----- Archivo: FileUploadItem.tsx ----- 
// src/components/forms/consultation/FileUploadItem.tsx
import React from 'react';
import { ConsultationFileType } from '@/types/index';
import { FaFilePdf, FaFileImage, FaFileAlt, FaTrash } from 'react-icons/fa';

interface FileUploadItemProps {
    file: ConsultationFileType;
    onDelete: (fileId: string) => void;
    // onDownload?: (filePath: string) => void; // Opcional, si manejas la descarga
}

export function FileUploadItem({ file, onDelete /*, onDownload */ }: FileUploadItemProps) {
    const getFileIcon = () => {
        if (file.file_type?.startsWith('image/')) return <FaFileImage className="text-blue-500" />;
        if (file.file_type === 'application/pdf') return <FaFilePdf className="text-red-500" />;
        return <FaFileAlt className="text-gray-500" />;
    };

    // La URL de descarga vendría de una API que genere una URL firmada
    // const handleDownload = () => {
    //     if(onDownload) onDownload(file.file_path);
    // };

    return (
        <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '0.5rem',
            border: '1px solid var(--primary-inverse)',
            borderRadius: '4px',
            marginBottom: '0.5rem',
            fontSize: '0.9rem'
        }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                {getFileIcon()}
                <span>{file.file_name}</span>
                <span style={{ fontSize: '0.75rem', color: 'var(--primary-lightgray)' }}> ({(file.file_size_bytes! / 1024).toFixed(1)} KB)</span>
            </div>
            <div>
                {/* 
                // Botón de descarga (requiere API para URL firmada)
                <button 
                    type="button" 
                    onClick={handleDownload} 
                    className="outline secondary" 
                    aria-label="Descargar archivo"
                    style={{marginRight: '0.5rem', padding: '0.25rem 0.5rem'}}
                >
                    <FaDownload />
                </button> 
                */}
                <button
                    type="button"
                    onClick={() => onDelete(file.id)}
                    className="outline secondary"
                    aria-label="Eliminar archivo"
                    style={{ color: 'var(--pico-color-red-500)', borderColor: 'var(--pico-color-red-500)', padding: '0.25rem 0.5rem' }}
                >
                    <FaTrash />
                </button>
            </div>
        </div>
    );
} 
----- Archivo: index.ts ----- 
// src/components/forms/consultation/sections/index.ts
export * from './IdentitySection';
export * from './OwnerPetSection';
export * from './AnamnesisSection';
export * from './PhysicalExamSection';
export * from './DiagnosticApproachSection';
export * from './ComplementaryExamsSection';
export * from './DiagnosisPlanSection';
export * from './ProceduresSection';
export * from './MedicationsSection';
export * from './ObservationsSignatureSection'; 
----- Archivo: AnamnesisSection.tsx ----- 
// src/components/forms/consultation/sections/AnamnesisSection.tsx
import React from 'react';
import type { CreateConsultationPayload, BasicDataType } from '@/types/index';

interface AnamnesisSectionProps {
    formData: Partial<CreateConsultationPayload>;
    basicData: BasicDataType | null;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    handleNumericChange: (name: keyof CreateConsultationPayload, value: string) => void;
}

export function AnamnesisSection({ formData, basicData, handleChange, handleNumericChange }: AnamnesisSectionProps) {
    const isFemale = basicData?.gender === 'Hembra';

    return (
        <fieldset>
            <legend>4. Anamnesis</legend>
            <label htmlFor="current_diet">Dieta Actual<textarea id="current_diet" name="current_diet" value={formData.current_diet || ''} onChange={handleChange} rows={2} /></label>
            <div className="grid">
                <label htmlFor="previous_illnesses">Enfermedades Previas<textarea id="previous_illnesses" name="previous_illnesses" value={formData.previous_illnesses || ''} onChange={handleChange} rows={2} /></label>
                <label htmlFor="previous_surgeries">Cirugías Previas<textarea id="previous_surgeries" name="previous_surgeries" value={formData.previous_surgeries || ''} onChange={handleChange} rows={2} /></label>
            </div>
            <div className="grid">
                <label htmlFor="vaccination_history">Esquema Vacunal (Resumen)<textarea id="vaccination_history" name="vaccination_history" value={formData.vaccination_history || ''} onChange={handleChange} placeholder="Ej: Completo según edad, última revacunación Diciembre 2023" rows={2} /></label>
                <label htmlFor="last_deworming_product">Última Desparasitación y Producto<input type="text" id="last_deworming_product" name="last_deworming_product" value={formData.last_deworming_product || ''} onChange={handleChange} placeholder="Ej: Drontal Plus, hace 2 meses" /></label>
            </div>
            <label htmlFor="recent_treatments">Tratamientos Recientes<textarea id="recent_treatments" name="recent_treatments" value={formData.recent_treatments || ''} onChange={handleChange} rows={2} /></label>
            <div className="grid">
                <label htmlFor="recent_travels">Viajes Recientes<input type="text" id="recent_travels" name="recent_travels" value={formData.recent_travels || ''} onChange={handleChange} placeholder="Ej: Finca en Clima Cálido hace 1 semana" /></label>
                <label htmlFor="lives_with_other_animals_details">¿Vive con otros animales? ¿Cuáles?<input type="text" id="lives_with_other_animals_details" name="lives_with_other_animals_details" value={formData.lives_with_other_animals_details || ''} onChange={handleChange} placeholder="Ej: Sí, un gato y un perro." /></label>
            </div>
            <div className="grid">
                <label>Esterilizado
                    <select name="sterilized_status" value={formData.sterilized_status || ""} onChange={handleChange}>
                        <option value="" disabled>Seleccionar...</option>
                        <option value="yes">Sí</option>
                        <option value="no">No</option>
                        <option value="unknown">No se sabe</option>
                    </select>
                </label>
                {isFemale && (
                    <label htmlFor="birth_count">N° de Partos
                        <input type="number" id="birth_count" name="birth_count" value={formData.birth_count === undefined || formData.birth_count === null ? '' : formData.birth_count} onChange={(e) => handleNumericChange('birth_count', e.target.value)} min="0" />
                    </label>
                )}
            </div>
            <label htmlFor="animal_behavior_owner_description">Comportamiento del Animal (según propietario)<textarea id="animal_behavior_owner_description" name="animal_behavior_owner_description" value={formData.animal_behavior_owner_description || ''} onChange={handleChange} rows={3} /></label>
            <label htmlFor="reason_for_consultation">Motivo de Consulta (según propietario)<textarea id="reason_for_consultation" name="reason_for_consultation" value={formData.reason_for_consultation || ''} onChange={handleChange} rows={3} required /></label>
        </fieldset>
    );
} 
----- Archivo: ComplementaryExamsSection.tsx ----- 
// src/components/forms/consultation/sections/ComplementaryExamsSection.tsx
import React, { useState, useRef, Dispatch, SetStateAction } from 'react';
import type { CreateConsultationPayload } from '@/types/index';
import { FaPaperclip } from 'react-icons/fa';

interface ComplementaryExamsSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    setStagedFiles: Dispatch<SetStateAction<File[]>>;
}

export function ComplementaryExamsSection({
    formData,
    handleChange,
    setStagedFiles,
}: ComplementaryExamsSectionProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [localFileNames, setLocalFileNames] = useState<string[]>([]);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.files) {
            const newFiles = Array.from(event.target.files);
            setStagedFiles(prev => [...prev, ...newFiles]);
            setLocalFileNames(prev => [...prev, ...newFiles.map(f => f.name)]);
        }
    };

    const triggerFileInput = () => {
        fileInputRef.current?.click();
    };

    return (
        <fieldset>
            <legend>7. Exámenes Complementarios y Resultados</legend>
            <label htmlFor="complementary_exams_summary">
                Resumen de Exámenes Realizados / Hallazgos Principales (texto)
                <textarea
                    id="complementary_exams_summary"
                    name="complementary_exams_summary"
                    value={formData.complementary_exams_summary || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Ej: Hemograma: Leucocitosis leve. Radiografía abdominal: Sin hallazgos significativos."
                />
            </label>

            <div>
                <h6 style={{ marginTop: '1rem' }}>Archivos Adjuntos (se guardarán al finalizar):</h6>
                <input
                    type="file"
                    multiple
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    style={{ display: 'none' }}
                    accept="image/*,application/pdf"
                />
                <button type="button" onClick={triggerFileInput} className="outline">
                    <FaPaperclip style={{ marginRight: '0.5rem' }} /> Seleccionar Archivos
                </button>
                {localFileNames.length > 0 && (
                    <div style={{ marginTop: '1rem', fontSize: '0.9em' }}>
                        <p>Archivos en espera:</p>
                        <ul>
                            {localFileNames.map((name, index) => <li key={index}>{name}</li>)}
                        </ul>
                    </div>
                )}
            </div>
        </fieldset>
    );
} 
----- Archivo: DiagnosisPlanSection.tsx ----- 
// src/components/forms/consultation/sections/DiagnosisPlanSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface DiagnosisPlanSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function DiagnosisPlanSection({ formData, handleChange }: DiagnosisPlanSectionProps) {
    return (
        <fieldset>
            <legend>8. Diagnóstico y Plan</legend>
            <label htmlFor="presumptive_diagnosis">
                Diagnóstico Presuntivo Justificado
                <textarea
                    id="presumptive_diagnosis"
                    name="presumptive_diagnosis"
                    value={formData.presumptive_diagnosis || ''}
                    onChange={handleChange}
                    rows={3}
                    required
                    placeholder="Describa el diagnóstico presuntivo y la justificación basada en los hallazgos."
                />
            </label>
            <label htmlFor="definitive_diagnosis">
                Diagnóstico Definitivo (si se tiene)
                <textarea
                    id="definitive_diagnosis"
                    name="definitive_diagnosis"
                    value={formData.definitive_diagnosis || ''}
                    onChange={handleChange}
                    rows={3}
                />
            </label>
            <label htmlFor="therapeutic_plan">
                Plan Terapéutico
                <textarea
                    id="therapeutic_plan"
                    name="therapeutic_plan"
                    value={formData.therapeutic_plan || ''}
                    onChange={handleChange}
                    rows={4}
                    required
                    placeholder="Detallar el tratamiento, recomendaciones, próxima revisión, etc."
                />
            </label>
            <label htmlFor="prognosis">
                Pronóstico
                <textarea
                    id="prognosis"
                    name="prognosis"
                    value={formData.prognosis || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Ej: Favorable, reservado, grave."
                />
            </label>
            <label htmlFor="evolution_notes">
                Evolución (Notas iniciales si aplica durante la consulta)
                <textarea
                    id="evolution_notes"
                    name="evolution_notes"
                    value={formData.evolution_notes || ''}
                    onChange={handleChange}
                    rows={3}
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: DiagnosticApproachSection.tsx ----- 
// src/components/forms/consultation/sections/DiagnosticApproachSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface DiagnosticApproachSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function DiagnosticApproachSection({ formData, handleChange }: DiagnosticApproachSectionProps) {
    return (
        <fieldset>
            <legend>6. Abordaje Diagnóstico</legend>
            <label htmlFor="problem_list">
                Lista de Problemas
                <textarea
                    id="problem_list"
                    name="problem_list"
                    value={formData.problem_list || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Ej: 1. Vómito agudo, 2. Letargia, 3. Deshidratación leve"
                />
            </label>
            <label htmlFor="master_problem_list">
                Lista Maestra (Problema Principal)
                <textarea
                    id="master_problem_list"
                    name="master_problem_list"
                    value={formData.master_problem_list || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Ej: Síndrome gastrointestinal agudo"
                />
            </label>
            <label htmlFor="differential_diagnoses">
                Diagnósticos Diferenciales
                <textarea
                    id="differential_diagnoses"
                    name="differential_diagnoses"
                    value={formData.differential_diagnoses || ''}
                    onChange={handleChange}
                    rows={4}
                    placeholder="Ej: 1. Gastroenteritis viral, 2. Cuerpo extraño, 3. Indiscreción alimentaria, 4. Pancreatitis"
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: IdentitySection.tsx ----- 
// src/components/forms/consultation/sections/IdentitySection.tsx
import React from 'react';
import type { CreateConsultationPayload, VeterinaryAccessType } from '@/types/index';

interface IdentitySectionProps {
    formData: Partial<CreateConsultationPayload>;
    vetData: VeterinaryAccessType;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
}

export function IdentitySection({ vetData, formData, handleChange }: IdentitySectionProps) {
    return (
        <fieldset>
            <legend>1. Identificación de la Institución e Historia Clínica</legend>
            <div className="grid">
                <label htmlFor="institution_name">
                    Nombre de la Institución
                    <input
                        type="text"
                        id="institution_name"
                        name="institution_name" // Campo nuevo, añadir a CreateConsultationPayload y tabla
                        value={vetData.clinic_name || ''}
                        readOnly disabled
                        onChange={handleChange}
                        placeholder="Ej: Clínica Veterinaria XYZ"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="hc_number">
                    HC # (Número Consecutivo)
                    <input
                        type="text"
                        id="hc_number"
                        name="hc_number" // Campo nuevo
                        value={formData.hc_number || ''}
                        onChange={handleChange}
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="consultation_date">
                    Fecha
                    <input
                        type="date"
                        id="consultation_date"
                        name="consultation_date"
                        value={formData.consultation_date || ''}
                        onChange={handleChange}
                        required
                    />
                </label>
                <label htmlFor="consultation_time">
                    Hora
                    <input
                        type="time"
                        id="consultation_time"
                        name="consultation_time" // Campo nuevo
                        value={formData.consultation_time || ''}
                        onChange={handleChange}
                        required
                    />
                </label>
            </div>
        </fieldset>
    );
} 
----- Archivo: MedicationsSection.tsx ----- 
// src/components/forms/consultation/sections/MedicationsSection.tsx
import React from 'react';
import type { ConsultationMedicationType } from '@/types/index';
import { FaPlus, FaTrash } from 'react-icons/fa';

type MedicationFormItem = Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>;

interface MedicationsSectionProps {
    medications: MedicationFormItem[];
    onChange: (updatedMedications: MedicationFormItem[]) => void;
}

export function MedicationsSection({ medications, onChange }: MedicationsSectionProps) {
    const addMedication = () => {
        onChange([...medications, { medication_name: '', dosage: '', frequency: '', duration_days: null, notes: '' }]);
    };

    const removeMedication = (index: number) => {
        onChange(medications.filter((_, i) => i !== index));
    };

    const handleMedicationChange = (
        index: number,
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        const { name, value } = e.target;
        let processedValue: string | number | null = value;
        if (name === "duration_days") {
            processedValue = value === '' ? null : parseInt(value, 10);
            if (isNaN(processedValue as number)) processedValue = null;
        }

        onChange(
            medications.map((med, i) =>
                i === index ? { ...med, [name]: processedValue } : med
            )
        );
    };

    return (
        <fieldset>
            <legend>Medicamentos Administrados/Prescritos en Consulta</legend>
            {medications.map((med, index) => (
                <div key={index} style={{ border: '1px solid var(--primary-inverse)', padding: '1rem', borderRadius: '4px', marginBottom: '1rem' }}>
                    <div className="grid">
                        <label htmlFor={`medication_name_${index}`}>
                            Nombre del Medicamento
                            <input
                                type="text"
                                id={`medication_name_${index}`}
                                name="medication_name"
                                value={med.medication_name}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                        <label htmlFor={`dosage_${index}`}>
                            Dosis
                            <input
                                type="text"
                                id={`dosage_${index}`}
                                name="dosage"
                                value={med.dosage}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                    </div>
                    <div className="grid">
                        <label htmlFor={`frequency_${index}`}>
                            Frecuencia
                            <input
                                type="text"
                                id={`frequency_${index}`}
                                name="frequency"
                                value={med.frequency}
                                onChange={(e) => handleMedicationChange(index, e)}
                                required
                            />
                        </label>
                        <label htmlFor={`duration_days_${index}`}>
                            Duración (días)
                            <input
                                type="number"
                                id={`duration_days_${index}`}
                                name="duration_days"
                                value={med.duration_days === null || med.duration_days === undefined ? '' : med.duration_days}
                                onChange={(e) => handleMedicationChange(index, e)}
                                min="0"
                            />
                        </label>
                    </div>
                    <label htmlFor={`medication_notes_${index}`}>
                        Notas Adicionales
                        <textarea
                            id={`medication_notes_${index}`}
                            name="notes"
                            value={med.notes || ''}
                            onChange={(e) => handleMedicationChange(index, e)}
                            rows={2}
                        />
                    </label>
                    <button
                        type="button"
                        onClick={() => removeMedication(index)}
                        className="secondary outline"
                        style={{ marginTop: '0.5rem', maxWidth: 'fit-content' }}
                        aria-label="Eliminar medicamento"
                    >
                        <FaTrash />
                    </button>
                </div>
            ))}
            <button type="button" onClick={addMedication} className="outline">
                <FaPlus style={{ marginRight: '0.5rem' }} /> Agregar Medicamento
            </button>
        </fieldset>
    );
} 
----- Archivo: ObservationsSignatureSection.tsx ----- 
// src/components/forms/consultation/sections/ObservationsSignatureSection.tsx
import React from 'react';
import type { CreateConsultationPayload, VeterinaryAccessType } from '@/types/index';

interface ObservationsSignatureSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    vetData: VeterinaryAccessType;
}

export function ObservationsSignatureSection({
    formData,
    handleChange,
    vetData
}: ObservationsSignatureSectionProps) {
    return (
        <fieldset>
            <legend>9. Observaciones y Profesional</legend>
            <label htmlFor="general_observations">
                Observaciones Adicionales / Anexos (descripción)
                <textarea
                    id="general_observations"
                    name="general_observations"
                    value={formData.general_observations || ''}
                    onChange={handleChange}
                    rows={3}
                    placeholder="Consentimientos informados, recomendaciones de egreso, etc."
                />
            </label>

            <div className="grid">
                <label>
                    Nombre MV o MVZ Tratante
                    <input type="text" value={`${vetData?.vet_first_name || ''} ${vetData?.vet_first_last_name || ''}`} readOnly disabled/>
                </label>
                <label>
                    Matrícula Profesional
                    <input type="text" value={vetData.professional_registration} readOnly disabled />
                </label>
            </div>
            <label>
                Firma (Digital o constancia)
                {/* Este campo es complejo de implementar digitalmente sin herramientas específicas.
                    Podría ser un campo de texto donde el vet confirma su responsabilidad. */}
                <input
                    type="text"
                    name="signature_confirmation" // Nuevo campo
                    value={formData.signature_confirmation || ""}
                    onChange={handleChange}
                    placeholder="Confirmo la veracidad de esta consulta bajo mi matrícula profesional."
                    required
                />
            </label>
        </fieldset>
    );
} 
----- Archivo: OwnerPetSection.tsx ----- 
// src/components/forms/consultation/sections/OwnerPetSection.tsx
import React, { useState, useEffect } from 'react';
import type { OwnerDataType, PetType, BasicDataType } from '@/types/index';
import { Dates } from '@/utils/index';

interface OwnerPetSectionProps {
    owner: OwnerDataType | null;
    pet: PetType;
    basicPetData: BasicDataType | null;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    onBasicDataChange: (field: keyof BasicDataType, value: any) => void;
}

export function OwnerPetSection({ owner, pet, basicPetData, onBasicDataChange }: OwnerPetSectionProps) {
    const [currentWeight, setCurrentWeight] = useState('');
    const [weightUnit, setWeightUnit] = useState('Kg');

    useEffect(() => {
        if (basicPetData?.weight) {
            const [value, unit] = basicPetData.weight.split(' ');
            setCurrentWeight(value || '');
            setWeightUnit(unit || 'Kg');
        }
    }, [basicPetData]);

    const handleWeightChange = () => {
        onBasicDataChange('weight', `${currentWeight} ${weightUnit}`);
    };

    return (
        <>
            <fieldset>
                <legend>2. Datos del Propietario</legend>
                <div className="grid">
                    <label>Nombre Propietario<input type="text" value={`${owner?.name || ''} ${owner?.last_name || ''}`} readOnly disabled /></label>
                    <label>Teléfono Celular<input type="text" value={owner?.phone || ''} readOnly disabled /></label>
                </div>
                <label>Correo Electrónico<input type="text" value={owner?.email || ''} readOnly disabled /></label>
            </fieldset>

            <fieldset>
                <legend>3. Reseña de la Mascota</legend>
                <div className="grid">
                    <label>Nombre Paciente<input type="text" value={pet.name} readOnly disabled /></label>
                    <label>Especie<input type="text" value={basicPetData?.pet_type || 'N/A'} readOnly disabled /></label>
                </div>
                <div className="grid">
                    <label>Raza<input type="text" value={basicPetData?.race || 'N/A'} readOnly disabled /></label>
                    <label>Sexo<input type="text" value={basicPetData?.gender || 'N/A'} readOnly disabled /></label>
                </div>
                <div className="grid">
                    <label>Fecha de Nacimiento<input type="date" value={Dates.format(pet.birth_date)} readOnly disabled /></label>
                    <label>
                        Peso Actual
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            <input
                                type="number"
                                value={currentWeight}
                                onChange={(e) => setCurrentWeight(e.target.value)}
                                onBlur={handleWeightChange} // Actualiza al perder el foco
                                placeholder="Ej: 5.5"
                                style={{ flex: 2 }}
                            />
                            <select value={weightUnit} onChange={(e) => setWeightUnit(e.target.value)} onBlur={handleWeightChange} style={{ flex: 1 }}>
                                <option value="Kg">Kg</option>
                                <option value="Lb">Lb</option>
                            </select>
                        </div>
                    </label>
                </div>
                <div className="grid">
                    <label>Color y Tipo de Pelaje<input type="text" value={ basicPetData ? `${basicPetData?.color} ${basicPetData?.coat_type}` : 'N/A'} readOnly disabled /></label>
                    <label>Chip #<input type="text" value={'N/A'} readOnly /></label>
                </div>
            </fieldset>
        </>
    );
} 
----- Archivo: PhysicalExamSection.tsx ----- 
// src/components/forms/consultation/sections/PhysicalExamSection.tsx
import React from 'react';
import type { CreateConsultationPayload } from '@/types/index';

interface PhysicalExamSectionProps {
    formData: Partial<CreateConsultationPayload>;
    handleChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    handleNumericChange: (name: keyof CreateConsultationPayload, value: string) => void;
}

export function PhysicalExamSection({ formData, handleChange, handleNumericChange }: PhysicalExamSectionProps) {
    return (
        <fieldset>
            <legend>5. Examen Físico General</legend>
            
            {/* Sub-sección: Constantes Fisiológicas y Estado General */}
            <div className="grid">
                <label htmlFor="body_condition_score">
                    Condición Corporal (1-5)
                    <input
                        type="number"
                        id="body_condition_score"
                        name="body_condition_score"
                        value={formData.body_condition_score === undefined || formData.body_condition_score === null ? '' : formData.body_condition_score}
                        onChange={(e) => handleNumericChange('body_condition_score', e.target.value)}
                        min="1" max="5" step="0.5"
                        placeholder="Ej: 3"
                    />
                </label>
                <label htmlFor="temperature_celsius">
                    T (°C)
                    <input
                        type="number"
                        id="temperature_celsius"
                        name="temperature_celsius"
                        value={formData.temperature_celsius === undefined || formData.temperature_celsius === null ? '' : formData.temperature_celsius}
                        onChange={(e) => handleNumericChange('temperature_celsius', e.target.value)}
                        step="0.1"
                        placeholder="Ej: 38.5"
                    />
                </label>
            </div>
            <div className="grid">
                 <label htmlFor="heart_rate_bpm">
                    FC (L/min)
                    <input
                        type="number"
                        id="heart_rate_bpm"
                        name="heart_rate_bpm"
                        value={formData.heart_rate_bpm === undefined || formData.heart_rate_bpm === null ? '' : formData.heart_rate_bpm}
                        onChange={(e) => handleNumericChange('heart_rate_bpm', e.target.value)}
                        min="0"
                        placeholder="Ej: 120"
                    />
                </label>
                <label htmlFor="respiratory_rate_rpm">
                    FR (R/min)
                    <input
                        type="number"
                        id="respiratory_rate_rpm"
                        name="respiratory_rate_rpm"
                        value={formData.respiratory_rate_rpm === undefined || formData.respiratory_rate_rpm === null ? '' : formData.respiratory_rate_rpm}
                        onChange={(e) => handleNumericChange('respiratory_rate_rpm', e.target.value)}
                        min="0"
                        placeholder="Ej: 20"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="capillary_refill_time_sec">
                    TRPC (seg) / TLLC (seg)
                    <input
                        type="number"
                        id="capillary_refill_time_sec"
                        name="capillary_refill_time_sec"
                        value={formData.capillary_refill_time_sec === undefined || formData.capillary_refill_time_sec === null ? '' : formData.capillary_refill_time_sec}
                        onChange={(e) => handleNumericChange('capillary_refill_time_sec', e.target.value)}
                        min="0" step="0.1"
                        placeholder="Ej: 1.5"
                    />
                </label>
                <label htmlFor="pulse_description"> {/* Nuevo campo para descripción del pulso */}
                    Pulso (descripción)
                    <input
                        type="text"
                        id="pulse_description"
                        name="pulse_description"
                        value={formData.pulse_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: Fuerte, rítmico"
                    />
                </label>
            </div>
            <div className="grid">
                <label htmlFor="mucous_membranes_description">
                    Mucosas
                    <input
                        type="text"
                        id="mucous_membranes_description"
                        name="mucous_membranes_description"
                        value={formData.mucous_membranes_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: Rosadas, húmedas"
                    />
                </label>
                <label htmlFor="hydration_percentage_description"> {/* Cambiado para ser descripción */}
                    Porcentaje Deshidratación (descripción)
                    <input
                        type="text"
                        id="hydration_percentage_description"
                        name="hydration_percentage_description" // Renombrar en types/schema
                        value={formData.hydration_percentage_description || ''}
                        onChange={handleChange}
                        placeholder="Ej: 5% estimado, leve"
                    />
                </label>
            </div>
             <label htmlFor="sense_organs_description">
                Órganos de los Sentidos (general)
                <textarea
                    id="sense_organs_description"
                    name="sense_organs_description"
                    value={formData.sense_organs_description || ''}
                    onChange={handleChange}
                    rows={2}
                    placeholder="Observaciones generales sobre ojos, oídos, nariz..."
                />
            </label>
            
            {/* Sub-sección: Examen por Sistemas */}
            <h6 style={{ marginTop: '1.5rem', marginBottom: '0.5rem' }}>Examen por Sistemas:</h6>
            <label htmlFor="skin_and_coat_description">
                Piel y Pelaje
                <textarea id="skin_and_coat_description" name="skin_and_coat_description" value={formData.skin_and_coat_description || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="lymph_nodes_description">
                Ganglios Linfáticos
                <textarea id="lymph_nodes_description" name="lymph_nodes_description" value={formData.lymph_nodes_description || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="digestive_system_findings">
                Sistema Digestivo
                <textarea id="digestive_system_findings" name="digestive_system_findings" value={formData.digestive_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="respiratory_system_findings">
                Sistema Respiratorio
                <textarea id="respiratory_system_findings" name="respiratory_system_findings" value={formData.respiratory_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="endocrine_system_findings">
                Sistema Endocrino
                <textarea id="endocrine_system_findings" name="endocrine_system_findings" value={formData.endocrine_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="musculoskeletal_system_findings">
                Sistema Músculo Esquelético
                <textarea id="musculoskeletal_system_findings" name="musculoskeletal_system_findings" value={formData.musculoskeletal_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="nervous_system_findings">
                Sistema Nervioso
                <textarea id="nervous_system_findings" name="nervous_system_findings" value={formData.nervous_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="urinary_system_findings">
                Sistema Urinario
                <textarea id="urinary_system_findings" name="urinary_system_findings" value={formData.urinary_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="reproductive_system_findings">
                Sistema Reproductivo
                <textarea id="reproductive_system_findings" name="reproductive_system_findings" value={formData.reproductive_system_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="rectal_palpation_findings">
                Palpación Rectal (si aplica)
                <textarea id="rectal_palpation_findings" name="rectal_palpation_findings" value={formData.rectal_palpation_findings || ''} onChange={handleChange} rows={2} />
            </label>
            <label htmlFor="other_physical_findings">
                Otros Hallazgos Físicos
                <textarea id="other_physical_findings" name="other_physical_findings" value={formData.other_physical_findings || ''} onChange={handleChange} rows={2} />
            </label>
        </fieldset>
    );
} 
----- Archivo: ProceduresSection.tsx ----- 
// src/components/forms/consultation/sections/ProceduresSection.tsx
import React from 'react';
import type { ConsultationProcedureType } from '@/types/index'; // Usaremos el tipo base
import { FaPlus, FaTrash } from 'react-icons/fa';

// El tipo para el formulario interno, sin los campos generados por BD
type ProcedureFormItem = Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>;

interface ProceduresSectionProps {
    procedures: ProcedureFormItem[];
    onChange: (updatedProcedures: ProcedureFormItem[]) => void;
}

export function ProceduresSection({ procedures, onChange }: ProceduresSectionProps) {
    const addProcedure = () => {
        onChange([...procedures, { procedure_name: '', description: '' }]);
    };

    const removeProcedure = (index: number) => {
        const updated = procedures.filter((_, i) => i !== index);
        onChange(updated);
    };

    const handleProcedureChange = (
        index: number,
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
        const { name, value } = e.target;
        const updated = procedures.map((proc, i) =>
            i === index ? { ...proc, [name]: value } : proc
        );
        onChange(updated);
    };

    return (
        <fieldset>
            <legend>Procedimientos Realizados en Consulta</legend>
            {procedures.map((proc, index) => (
                <div key={index} className="grid" style={{ alignItems: 'flex-end', marginBottom: '1rem', border: '1px solid var(--primary-inverse)', padding: '1rem', borderRadius: '4px' }}>
                    <label htmlFor={`procedure_name_${index}`}>
                        Nombre del Procedimiento
                        <input
                            type="text"
                            id={`procedure_name_${index}`}
                            name="procedure_name"
                            value={proc.procedure_name}
                            onChange={(e) => handleProcedureChange(index, e)}
                            placeholder="Ej: Limpieza de oídos"
                            required
                        />
                    </label>
                    <label htmlFor={`procedure_description_${index}`} className="pico-col-span-2"> {/* Ocupa más espacio si es necesario */}
                        Descripción/Notas
                        <textarea
                            id={`procedure_description_${index}`}
                            name="description"
                            value={proc.description || ''}
                            onChange={(e) => handleProcedureChange(index, e)}
                            rows={2}
                        />
                    </label>
                    <button
                        type="button"
                        onClick={() => removeProcedure(index)}
                        className="secondary outline"
                        style={{ maxWidth: 'fit-content', marginBottom: '0.5rem' }} // PicoCSS a veces necesita ajustes para botones pequeños
                        aria-label="Eliminar procedimiento"
                    >
                        <FaTrash />
                    </button>
                </div>
            ))}
            <button type="button" onClick={addProcedure} className="outline">
                <FaPlus style={{ marginRight: '0.5rem' }} /> Agregar Procedimiento
            </button>
        </fieldset>
    );
} 
----- Archivo: page.tsx ----- 
// src/app/pages/vet/consultation/[petId]/page.tsx
"use client";
import React, { useEffect, useState, useRef } from "react";
import { useRouter, useParams } from "next/navigation";
import { Title, Loading, DataNotFound, AlertModal } from "@/components/index";
import { PetType, CreateConsultationPayload, BasicDataType, VaccineDataType, SurgeryDataType, MedicineDataType, ConditionDataType, OwnerDataType } from "@/types/index";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useVetContext } from "@/context/VetContext";
import { getFetch, postFetch } from "@/app/api";
import { FaClipboardList } from "react-icons/fa";
import ConsultationPetSummary from "@/components/consultations/ConsultationPetSummary";
import { ConsultationForm } from "../ConsultationForm";

type ConsultationSubmitHandle = {
    triggerFileUploads: (consultationId: string) => Promise<void>;
};

export default function ConsultationPage() {
    const router = useRouter();
    const params = useParams();
    const petId = params.petId as string;
    const formRef = useRef<ConsultationSubmitHandle>(null);

    const { db: session } = useSessionContext();
    const { storedPet, storedVetAccess, setStoredPet } = useStorageContext();
    const { vet: veterinarianData } = useVetContext();

    const [pet, setPet] = useState<PetType | null>(storedPet.id === petId ? storedPet : null);
    const [owner, setOwner] = useState<OwnerDataType | null>(null);
    const [basicData, setBasicData] = useState<BasicDataType | null>(null);
    const [vaccines, setVaccines] = useState<VaccineDataType[] | null>(null);
    const [medicines, setMedicines] = useState<MedicineDataType[] | null>(null);
    const [surgeries, setSurgeries] = useState<SurgeryDataType[] | null>(null);
    const [conditions, setConditions] = useState<ConditionDataType[] | null>(null);

    const [loadingPet, setLoadingPet] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [submitting, setSubmitting] = useState<boolean>(false);
    const [showErrorModal, setShowErrorModal] = useState(false);
    const [showSuccessModal, setShowSuccessModal] = useState(false);

    useEffect(() => {
        if (!petId) {
            setError("ID de mascota no encontrado en la ruta.");
            setLoadingPet(false);
            return;
        }

        const fetchAllPetData = async () => {
            try {
                // Fetch principal de la mascota
                if (!pet || pet.id !== petId) {
                    const petResponse = await getFetch(`/api/pets/${petId}`);
                    const petData = await petResponse.json();
                    if (!petResponse.ok) throw new Error(petData.message || "Mascota no encontrada");
                    setPet(petData);
                    setStoredPet(petData);
                }

                // Fetch de todos los datos relacionados para el resumen
                const [basicDataRes, vaccinesRes, medicinesRes, surgeriesRes, conditionsRes, ownerDataRes] = await Promise.all([
                    getFetch(`/api/pets/basic-data/${petId}`),
                    getFetch(`/api/pets/list/vaccines/${petId}`),
                    getFetch(`/api/pets/list/medicines/${petId}`),
                    getFetch(`/api/pets/list/surgeries/${petId}`),
                    getFetch(`/api/pets/list/conditions/${petId}`),
                    getFetch(`/api/owners/by-pet/${petId}`),
                ]);

                setBasicData(await basicDataRes.json());
                setVaccines(await vaccinesRes.json());
                setMedicines(await medicinesRes.json());
                setSurgeries(await surgeriesRes.json());
                setConditions(await conditionsRes.json());
                setOwner(await ownerDataRes.json());


            } catch (err) {
                console.error("Error fetching pet data:", err);
                setError(err instanceof Error ? err.message : "Error cargando datos de la mascota.");
            } finally {
                setLoadingPet(false);
            }
        };

        fetchAllPetData();
    }, [petId, setStoredPet, pet]);

    const handleFormSubmit = async (formData: CreateConsultationPayload) => {
        setSubmitting(true);
        setError(null);

        const payload: CreateConsultationPayload = { ...formData, pet_id: petId };

        if (veterinarianData?.vet_id && session?.user?.user_metadata?.role === 'veterinarian') {
            payload.veterinarian_id = veterinarianData.vet_id;
        } else if (storedVetAccess?.id) {
            payload.veterinary_access_id = storedVetAccess.id;
        } else {
            setError("No se pudo identificar al veterinario responsable. Inicie sesión o use un código de acceso válido.");
            setShowErrorModal(true);
            setSubmitting(false);
            return;
        }

        try {
            const response = await postFetch('/api/consultations', undefined, payload);
            const result = await response.json();

            if (!response.ok || !result.success) {
                throw new Error(result.message || "Error al guardar la consulta.");
            }

            const newConsultationId = result.consultation.id;

            // Si hay archivos, dispare su carga ahora que tenemos el ID
            if (formRef.current?.triggerFileUploads) {
                await formRef.current.triggerFileUploads(newConsultationId);
            }

            setShowSuccessModal(true);

        } catch (err) {
            setError(err instanceof Error ? err.message : "Error desconocido al guardar.");
            setShowErrorModal(true);
        } finally {
            setSubmitting(false);
        }
    };

    const handleSuccessModalClose = () => {
        setShowSuccessModal(false);
        router.push(`/pages/pet/consultations/${petId}`);
    }

    if (loadingPet) return <Loading />;
    if (error && !showErrorModal) return <DataNotFound message={error} />;
    if (!pet) return <DataNotFound message="Mascota no encontrada." />;

    return (
        <main style={{ padding: "2rem" }}>
            <Title icon={<FaClipboardList />} title={`Nueva Consulta para ${pet.name}`} />

            {showErrorModal && (
                <AlertModal title="Error" message={error || "Ocurrió un error inesperado."} type="warning" onClose={() => setShowErrorModal(false)} />
            )}
            {showSuccessModal && (
                <AlertModal title="Éxito" message="La consulta se ha guardado correctamente." type="info" onClose={handleSuccessModalClose} />
            )}

            <ConsultationPetSummary
                basicData={basicData}
                vaccines={vaccines}
                medicines={medicines}
                surgeries={surgeries}
                conditions={conditions}
            />

            <ConsultationForm
                ref={formRef}
                pet={pet}
                owner={owner}
                basicData={basicData}
                onSubmit={handleFormSubmit}
                isSubmitting={submitting}
            />
        </main>
    );
} 
----- Archivo: page.tsx ----- 
// RUTA: src/app/pages/vet/settings/page.tsx
"use client";

import React, { useState, useEffect, FormEvent } from 'react';
import { FaCog, FaSpinner } from 'react-icons/fa';
import { Title, Loading } from '@/components/index';
import { useVetContext } from '@/context/VetContext';
import { VeterinarianType } from '@/types/index';
import { putFetch } from '@/app/api';

export default function VetSettingsPage() {
    const { vet, loading: loadingVet, refresh: refreshVet } = useVetContext();
    const [vetInfo, setVetInfo] = useState<Partial<VeterinarianType>>({});
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [successMessage, setSuccessMessage] = useState<string | null>(null);

    useEffect(() => {
        if (vet) {
            setVetInfo(vet);
        }
    }, [vet]);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target;
        setVetInfo(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e: FormEvent) => {
        e.preventDefault();
        setIsSubmitting(true);
        setError(null);
        setSuccessMessage(null);

        if (!vetInfo.vet_id) {
            setError("No se puede identificar al veterinario.");
            setIsSubmitting(false);
            return;
        }

        try {
            const response = await putFetch(`/api/vet/${vetInfo.vet_id}`, undefined, vetInfo);
            const result = await response.json();

            if (!response.ok || !result.success) {
                throw new Error(result.message || 'Error al actualizar los datos.');
            }

            setSuccessMessage('¡Datos actualizados correctamente!');
            await refreshVet(); // Refrescar el contexto con los nuevos datos

        } catch (err) {
            setError(err instanceof Error ? err.message : 'Ocurrió un error inesperado.');
        } finally {
            setIsSubmitting(false);
        }
    };

    if (loadingVet) {
        return <Loading />;
    }

    if (!vet) {
        return <p>No se pudo cargar la información del veterinario.</p>;
    }

    return (
        <main style={{ padding: '2rem' }}>
            <Title icon={<FaCog />} title="Configuración de Perfil de Veterinario" />
            <p>Aquí puedes actualizar tu información profesional que se mostrará en las historias clínicas.</p>

            <form onSubmit={handleSubmit} style={{ marginTop: '2rem', maxWidth: '700px' }}>
                <fieldset disabled={isSubmitting}>
                    <div className="grid">
                        <label htmlFor="first_name">
                            Nombre
                            <input
                                type="text"
                                id="first_name"
                                name="first_name"
                                value={vetInfo.first_name || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                        <label htmlFor="first_last_name">
                            Primer Apellido
                            <input
                                type="text"
                                id="first_last_name"
                                name="first_last_name"
                                value={vetInfo.first_last_name || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                    </div>

                    <div className="grid">
                        <label htmlFor="second_last_name">
                            Segundo Apellido
                            <input
                                type="text"
                                id="second_last_name"
                                name="second_last_name"
                                value={vetInfo.second_last_name || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                        <label htmlFor="identification">
                            Identificación
                            <input
                                type="text"
                                id="identification"
                                name="identification"
                                value={vetInfo.identification || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                    </div>

                    <label htmlFor="email">
                        Email (no se puede cambiar)
                        <input
                            type="email"
                            id="email"
                            name="email"
                            value={vetInfo.email || ''}
                            readOnly
                            disabled
                        />
                    </label>

                    <div className="grid">
                        <label htmlFor="registration">
                            Matrícula Profesional
                            <input
                                type="text"
                                id="registration"
                                name="registration"
                                value={vetInfo.registration || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                        <label htmlFor="clinic_name">
                            Nombre de la Clínica/Hospital
                            <input
                                type="text"
                                id="clinic_name"
                                name="clinic_name"
                                value={vetInfo.clinic_name || ''}
                                onChange={handleInputChange}
                                required
                            />
                        </label>
                    </div>

                    <label htmlFor="city">
                        Ciudad
                        <input
                            type="text"
                            id="city"
                            name="city"
                            value={vetInfo.city || ''}
                            onChange={handleInputChange}
                            required
                        />
                    </label>

                    {error && <p role="alert" style={{ color: "var(--pico-form-element-invalid-active-border-color, red)" }}>{error}</p>}
                    {successMessage && <p role="status" style={{ color: "var(--pico-color-green-500, green)" }}>{successMessage}</p>}

                    <button type="submit" aria-busy={isSubmitting}>
                        {isSubmitting ? <FaSpinner className="animate-spin" /> : 'Guardar Cambios'}
                    </button>
                </fieldset>
            </form>
        </main>
    );
} 
----- Archivo: page.tsx ----- 
// app/pages/vet/[code]/page.tsx
"use client";
import { useEffect, useState } from "react";
import { useStorageContext } from "@/context/StorageProvider";
import PetEditForm from "./components/forms/PetEditForm";
import { PetType } from "@/types/index";
import { useRouter } from "next/navigation";

interface VetPageProps {
  params: Promise<{ code: string }>;
}

export default function VetPage({ params }: VetPageProps) {
  const [validatedCode, setValidatedCode] = useState("");
  const [pet, setPet] = useState<PetType | null>(null);
  const [isValid, setIsValid] = useState(false);
  const [message, setMessage] = useState("");
  const router = useRouter();

  const storage = useStorageContext();

  useEffect(() => {
    const fetchData = async () => {
      const { code } = await params;
      setValidatedCode(code);

      try {
        const res = await fetch(`/api/vet/validate?code=${code}`);
        const data = await res.json();

        if (!res.ok || !data.success) {
          setMessage(data.message || "Error validando el código.");
          return;
        }

        storage.setStoredPetCode(data.codeRecord);
        storage.setStoredPet(data.pet);
        if (data.vetAccess) {
          storage.setStoredVetAccess(data.vetAccess);
        }

        setPet(data.pet);
        router.replace(`/pages/vet/consultation/${data.pet.id}`);
        setIsValid(true);

      } catch (err) {
        console.error("Error validando código veterinario:", err);
        setMessage("Ocurrió un error al validar el código.");
      }
    };

    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params]);

  return (
    <main className="container" style={{ padding: "2rem" }}>
      <h1>Editar datos de mascota</h1>

      {!isValid && (
        <p style={{ marginBottom: "1rem", color: "var(--primary-red)" }}>
          {message}
        </p>
      )}

      {pet && (
        <PetEditForm code={validatedCode} pet={pet} disabled={!isValid} />
      )}
    </main>
  );
}
 
----- Archivo: PetEditForm.tsx ----- 
// app/pages/vet/[code]/components/forms/PetEditForm.tsx
"use client";
import { putFetch } from "@/app/api";
import { PetType } from "@/types/index";
import React, { useState, FormEvent } from "react";

interface Props {
  code: string;
  pet: PetType;
  disabled?: boolean;
}

export default function PetEditForm({ code, pet, disabled = false }: Props) {
  const [name, setName] = useState(pet.name);
  const [image, setImage] = useState(pet.image || "");
  const [alert, setAlert] = useState<string | null>(null);
  const [formFailed, setFormFailed] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (disabled) return;

    const res = await putFetch(`/api/vet/edit/${pet.id}`, undefined, { code, name, image });

    // ← usar res.ok para determinar éxito
    const success = res.ok;
    setFormFailed(!success);

    if (success) {
      setAlert("Datos actualizados correctamente.");
    } else {
      const json = await res.json();
      setAlert(json.error || "Error al actualizar.");
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: 400, display: "grid", gap: "1rem" }}
    >
      <label>
        Nombre
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          disabled={disabled}
          required
        />
      </label>

      <label>
        Imagen
        <input
          type="text"
          value={image}
          onChange={(e) => setImage(e.target.value)}
          disabled={disabled}
        />
      </label>

      <button type="submit" disabled={disabled}>
        Guardar cambios
      </button>

      {alert && (
        // ← solo basar color en formFailed
        <p style={{ color: formFailed ? "var(--primary-red)" : "var(--primary-green)" }}>{alert}</p>
      )}
    </form>
  );
}
 
----- Archivo: layout.tsx ----- 
// app/vet-access/layout.tsx
export default function VetLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="p-4">
      {children}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/vet-access/page.tsx
"use client";
import React, { useState } from "react";
import Link from "next/link";
import VeterinaryModal from "@/components/modals/VeterinaryModal";

export default function VetAccessPage() {
  const [showVetModal, setShowVetModal] = useState(false);

  return (
    <main className="container" style={{ padding: "2rem", maxWidth: 600 }}>
      <h1>Acceso Veterinario</h1>
      <p>
        Introduce el código de la mascota que te haya facilitado el dueño para
        ver su historial y agregar nuevas entradas.
      </p>

      <div
        className="grid"
        style={{ gridTemplateColumns: "1fr", gap: "1rem", margin: "2rem 0" }}
      >
        {/* Botón para acceder sin registrarse */}
        <button
          className="contrast"
          onClick={() => setShowVetModal(true)}
        >
          Ingresar sin registrarse
        </button>

        {/* Enlace a registro de veterinario (implementa esta ruta si lo deseas) */}
        <Link href="/vet-access/register" className="primary">
          Registrarme como veterinario
        </Link>
      </div>

      {/**  
       * Reutilizamos el componente VeterinaryModal para capturar datos
       * y hacer el POST a VeterinaryAccessRepository.create  
       */}
      {showVetModal && (
        <VeterinaryModal setShowModal={setShowVetModal} />
      )}
    </main>
  );
}
 
----- Archivo: page.tsx ----- 
// components/ValidadorProfesional.js
"use client";
import { ProfessionalData } from '@/types/index';
import { useState } from 'react';

export default function ValidadorProfesional() {
  const [matricula, setMatricula] = useState('');
  const [profesional, setProfesional] = useState<ProfessionalData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const handleValidation = async (e: any) => {
    e.preventDefault();
    if (!matricula) return;

    setIsLoading(true);
    setError(null);
    setProfesional(null);

    try {
      const response = await fetch('/api/vet/validar-matricula', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ matricula }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Error en la validación.');
      }

      setProfesional(data);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div style={{ fontFamily: 'sans-serif', maxWidth: '600px', margin: 'auto', padding: '20px' }}>
      <h2>Validación de Matrícula Profesional COMVEZCOL</h2>
      <form onSubmit={handleValidation}>
        <input
          type="text"
          value={matricula}
          onChange={(e) => setMatricula(e.target.value)}
          placeholder="Ingrese el número de matrícula"
          style={{ padding: '10px', width: '70%', marginRight: '10px' }}
        />
        <button type="submit" disabled={isLoading} style={{ padding: '10px' }}>
          {isLoading ? 'Validando...' : 'Validar'}
        </button>
      </form>

      {error && <p style={{ color: 'red', marginTop: '20px' }}>Error: {error}</p>}

      {profesional && (
        <div style={{ marginTop: '20px', border: '1px solid #ccc', padding: '20px', borderRadius: '8px' }}>
          <h3>Resultados de la Búsqueda</h3>
          <img src={profesional.foto} alt="Foto del profesional" style={{ width: '150px', borderRadius: '50%', float: 'right' }} />
          <p><strong>Nombres:</strong> {profesional.nombres}</p>
          <p><strong>Apellidos:</strong> {profesional.apellidos}</p>
          <p><strong>Matrícula No.:</strong> {profesional.numeroMatricula}</p>
          <p><strong>Título Obtenido:</strong> {profesional.tituloObtenido}</p>
          <p><strong>Universidad:</strong> {profesional.universidad}</p>
          <p><strong>Acta de Grado:</strong> {profesional.actaGrado}</p>
          <p><strong>Estado:</strong> <span style={{ color: 'green', fontWeight: 'bold' }}>{profesional.estado}</span></p>
        </div>
      )}
    </div>
  );
} 
----- Archivo: page.tsx ----- 
// app/vet-access/register/page.tsx
"use client";
import React, { FormEvent, useState } from "react";
import "@picocss/pico";
import { useRouter } from "next/navigation";
import ModalComponent from "@/components/lib/modal";
import { postFetch } from "@/app/api";
import { FaEye, FaEyeSlash } from "react-icons/fa";
import { authClient } from "@/lib/auth";

export default function VetRegisterPage() {
  const router = useRouter();

  // Estados del formulario
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  // Estados UI
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [showConfirmModal, setShowConfirmModal] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError("");

    // Validación básica
    if (![firstName, lastName, registration, clinicName, city, email, password].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }

    setLoading(true);
    try {
      // 1) Crear cuenta en auth
      const { data: { user } } = await authClient.signUp(email, password, 'veterinarian');
      const vetId = user?.id;
      /*
      const signUpRes = await postFetch("/api/auth/sign-up", undefined, { email, password, role: 'veterinarian' });
      const signUpJson = await signUpRes.json();
      if (!signUpRes.ok || !signUpJson.success) {
        setError("Error al registrar la cuenta.");
        return;
      }
      const vetId = signUpJson.user?.id;*/
      if (vetId) {
        // 2) Guardar perfil de veterinario
        const profileRes = await postFetch("/api/vet", undefined, {
          vet_id: vetId,
          first_name: firstName,
          last_name: lastName,
          registration,
          clinic_name: clinicName,
          city,
          email
        });
        if (!profileRes.ok) {
          setError("Error creando perfil de veterinario.");
          return;
        }
      }

      // 3) Mostrar modal de confirmación de correo
      setShowConfirmModal(true);

    } catch {
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  // Modal de “Confirma tu correo”
  if (showConfirmModal) {
    return (
      <ModalComponent
        title="Confirma tu correo"
        description={`Te hemos enviado un correo de verificación a ${email}. Por favor revisa tu bandeja (y carpeta de spam) y haz clic en el enlace.`}
        setShowModal={setShowConfirmModal}
      >
        <button
          className="contrast"
          onClick={() => router.push("/")}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          Ya confirmé, continuar
        </button>
      </ModalComponent>
    );
  }

  // Formulario de registro
  return (
    <main style={{ maxWidth: 600, margin: "2rem auto", padding: '2rem' }}>
      <h1>Registro Veterinario</h1>
      <form onSubmit={handleSubmit}
        style={{
          background: "var(--primary-inverse)",
          padding: "2rem",
          borderRadius: "0.5rem",
          boxShadow: "0 2px 8px var(--primary-lighttransparent)",
          width: "100%",
          maxWidth: "550px",
        }}>
        <div className="grid" style={{ gridTemplateColumns: "1fr 1fr", gap: "1rem" }}>
          <label>
            Nombre
            <input
              type="text"
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              required
            />
          </label>
          <label>
            Apellido
            <input
              type="text"
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              required
            />
          </label>
          <label>
            Registro profesional
            <input
              type="text"
              value={registration}
              onChange={e => setRegistration(e.target.value)}
              required
            />
          </label>
          <label>
            Clínica / Laboratorio
            <input
              type="text"
              value={clinicName}
              onChange={e => setClinicName(e.target.value)}
              required
            />
          </label>
          <label>
            Ciudad
            <input
              type="text"
              value={city}
              onChange={e => setCity(e.target.value)}
              required
            />
          </label>
        </div>

        <label>
          Email
          <input
            type="email"
            value={email}
            onChange={e => setEmail(e.target.value)}
            required
          />
        </label>

        <label style={{ position: 'relative' }}>
          Contraseña
          <input
            type={showPassword ? "text" : "password"}
            value={password}
            onChange={e => setPassword(e.target.value)}
            required
          />
          <button
            type="button"
            onClick={() => setShowPassword(!showPassword)}
            aria-label={showPassword ? "Ocultar contraseña" : "Mostrar contraseña"}
            style={{
              position: 'absolute',
              right: '0.75rem',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'none',
              border: 'none',
              padding: 0,
              cursor: 'pointer',
            }}
          >
            {showPassword ? <FaEyeSlash size={23} color={'var(--pico-contrast)'} style={{ marginTop: '16px' }} /> : <FaEye size={23} color={'var(--pico-contrast)'} style={{ marginTop: '16px' }} />}
          </button>
        </label>

        {error && <p style={{ color: "var(--primary-red)", marginTop: "0.5rem" }}>{error}</p>}

        <button
          type="submit"
          disabled={loading}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          {loading ? "Registrando..." : "Registrarme"}
        </button>
      </form>
    </main>
  );
}
 
----- Archivo: page.tsx ----- 
'use client'
export default function ErrorPage() {
  return <p>Sorry, something went wrong</p>
} 
----- Archivo: index.ts ----- 
// layout
export { default as SideBar } from "./layout/SideBar";
export { default as Bubbles } from "./modals/Bubbles";
export { default as ClientAppProvider } from "../context/ClientAppProvider";

// lib
export { default as AddItem } from "./lib/addItem";
export { default as BasicField } from "./lib/basicField";
export { default as CircularImage } from './lib/circularImage';
export { default as DataNotFound } from "./lib/dataNotFound";
export { default as Display } from "./lib/display";
export { default as Entities } from "./lib/entities";
export { default as Entity } from "./lib/entity";
export { default as EntityFields } from "./lib/entityFields";
export { default as EntityForm } from "./lib/entityForm";
export { default as FeatureLink } from "./lib/featureLink";
export { default as Field } from "./lib/field";
export { default as Form } from "./lib/form";
export { default as Loading } from "./lib/loading";
export { default as Modal } from "./lib/modal";
export { default as Page } from "./lib/page";
export { default as RemoveItem } from "./lib/removeItem";
export { default as Steps } from "./lib/steps";
export { default as Title } from "./lib/title";

// views
export { default as ConsultationDetailView } from './consultations/ConsultationDetailView';
export { default as ConsultationPetSummary } from './consultations/ConsultationPetSummary';

// forms
export { default as CountryCodeInput } from "./forms/CountryCodeInput";
export { default as CountryCitySelector } from "./forms/CountryCitySelector";
export { default as MapPicker } from "./forms/MapPicker";

//modals
export { default as AlertModal } from "./modals/AlertModal";
export { default as ConfirmModal } from "./modals/ConfirmModal"; 
----- Archivo: ConsultationDetailView.tsx ----- 
// src/components/consultations/ConsultationDetailView.tsx
"use client";
import React, { useRef, useState } from 'react';
import { ConsultationType, ConsultationFileType } from '@/types/index';
import { Dates } from '@/utils/index';
import { FaPaperclip, FaTrash, FaDownload, FaSpinner, FaPlusCircle } from 'react-icons/fa';

interface ConsultationDetailViewProps {
    consultation: ConsultationType;
    currentUserId: string | null;
    onFileAdded: () => void;
}

const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; // 5MB
const ALLOWED_FILE_TYPES_ARRAY = ['image/jpeg', 'image/png', 'application/pdf', 'image/webp', 'image/gif'];

// Helper para verificar si un valor se considera "con datos"
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const hasValue = (value: any): boolean => {
    if (value === null || value === undefined) return false;
    if (typeof value === 'string' && value.trim() === '') return false;
    if (typeof value === 'number' && isNaN(value)) return false; // Aunque los nulls numéricos ya se filtran
    return true;
};


export default function ConsultationDetailView({ consultation, currentUserId, onFileAdded }: ConsultationDetailViewProps) {
    const [showAddFile, setShowAddFile] = useState(false);
    const [fileToUpload, setFileToUpload] = useState<File | null>(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);
    // ... (resto del estado y handlers como antes: isUploading, uploadError, fileInputRef, canEditOrAddFiles, handleFileSelect, handleUploadFile, handleDownloadFile, handleDeleteFile)
    const canEditOrAddFiles = consultation.veterinarian_id === currentUserId ||
        (consultation.veterinary_access_id && currentUserId && consultation.veterinarian_id === null);

    const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.files && event.target.files[0]) {
            const file = event.target.files[0];
            if (file.size > MAX_FILE_SIZE_BYTES) {
                setUploadError(`El archivo excede ${MAX_FILE_SIZE_BYTES / (1024 * 1024)}MB.`);
                setFileToUpload(null);
                return;
            }
            if (!ALLOWED_FILE_TYPES_ARRAY.includes(file.type)) {
                setUploadError(`Tipo de archivo no permitido. Permitidos: ${ALLOWED_FILE_TYPES_ARRAY.join(', ')}`);
                setFileToUpload(null);
                return;
            }
            setFileToUpload(file);
            setUploadError(null);
        }
    };

    const handleUploadFile = async () => {
        if (!fileToUpload || !canEditOrAddFiles) return;
        setIsUploading(true);
        setUploadError(null);
        const formData = new FormData();
        formData.append('file', fileToUpload);
        formData.append('petId', consultation.pet_id);
        try {
            const response = await fetch(`/api/consultations/${consultation.id}/files`, {
                method: 'POST',
                body: formData,
            });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.message || 'Error al subir el archivo.');
            }
            alert('Archivo subido exitosamente!');
            setFileToUpload(null);
            setShowAddFile(false);
            if (fileInputRef.current) fileInputRef.current.value = "";
            onFileAdded();
        } catch (err) {
            setUploadError(err instanceof Error ? err.message : 'Error desconocido.');
        } finally {
            setIsUploading(false);
        }
    };

    const handleDownloadFile = async (file: ConsultationFileType) => {
        try {
            const response = await fetch(`/api/consultations/${consultation.id}//files/${file.id}`);
            const result = await response.json();
            if (response.ok && result.success && result.downloadUrl) {
                window.open(result.downloadUrl, '_blank');
            } else {
                throw new Error(result.message || "No se pudo obtener la URL de descarga.");
            }
        } catch (err) {
            alert(err instanceof Error ? err.message : "Error al descargar archivo.");
        }
    };

    const handleDeleteFile = async (fileId: string) => {
        if (!confirm("¿Está seguro de que desea eliminar este archivo? Esta acción no se puede deshacer.")) return;
        try {
            const response = await fetch(`/api/consultations/${consultation.id}//files/${fileId}`, { method: 'DELETE' });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.message || "Error eliminando archivo.");
            }
            alert("Archivo eliminado.");
            onFileAdded();
        } catch (err) {
            alert(err instanceof Error ? err.message : "No se pudo eliminar el archivo.");
        }
    };


    const renderField = (label: string, value: string | number | boolean | null | undefined, isTextArea = false) => {
        if (!hasValue(value)) return null; // Usar el helper hasValue
        const displayValue = typeof value === 'boolean' ? (value ? 'Sí' : 'No') : value;
        return (
            <div style={{ marginBottom: '0.8rem', paddingBottom: '0.5rem', borderBottom: '1px dotted var(--primary-inverse)' }}>
                <strong style={{ display: 'block', color: 'var(--secondary)', fontSize: '0.9em' }}>{label}:</strong>
                {isTextArea ? (
                    <p style={{ whiteSpace: 'pre-wrap', margin: '0.25rem 0 0 0' }}>{displayValue}</p>
                ) : (
                    <span style={{ display: 'block', margin: '0.25rem 0 0 0' }}>{displayValue}</span>
                )}
            </div>
        );
    };

    // --- Funciones para determinar si una sección tiene datos ---
    const anamnesisFields = [
        consultation.current_diet, consultation.previous_illnesses, consultation.previous_surgeries,
        consultation.vaccination_history, consultation.last_deworming_product, consultation.recent_treatments,
        consultation.recent_travels, consultation.animal_behavior_owner_description,
        consultation.lives_with_other_animals_details, consultation.sterilized_status, consultation.birth_count
    ];
    const showAnamnesisSection = hasValue(consultation.reason_for_consultation) || anamnesisFields.some(hasValue);

    const physicalExamGeneralFields = [
        consultation.body_condition_score, consultation.temperature_celsius, consultation.heart_rate_bpm,
        consultation.respiratory_rate_rpm, consultation.capillary_refill_time_sec, consultation.pulse_description,
        consultation.mucous_membranes_description, consultation.hydration_percentage_description,
        consultation.sense_organs_description
    ];
    const physicalExamSystemsFields = [
        consultation.skin_and_coat_description, consultation.lymph_nodes_description,
        consultation.digestive_system_findings, consultation.respiratory_system_findings,
        consultation.endocrine_system_findings, consultation.musculoskeletal_system_findings,
        consultation.nervous_system_findings, consultation.urinary_system_findings,
        consultation.reproductive_system_findings, consultation.rectal_palpation_findings,
        consultation.other_physical_findings
    ];
    const showPhysicalExamSection = physicalExamGeneralFields.some(hasValue) || physicalExamSystemsFields.some(hasValue);

    const diagnosticApproachFields = [
        consultation.problem_list, consultation.master_problem_list, consultation.differential_diagnoses
    ];
    const showDiagnosticApproachSection = diagnosticApproachFields.some(hasValue);

    const diagnosisPlanFields = [
        consultation.definitive_diagnosis, consultation.therapeutic_plan, // Presumptive es obligatorio
        consultation.prognosis, consultation.evolution_notes
    ];
    const showDiagnosisPlanSection = hasValue(consultation.presumptive_diagnosis) || hasValue(consultation.therapeutic_plan) || diagnosisPlanFields.some(hasValue);

    const observationsFields = [
        consultation.general_observations, consultation.signature_confirmation
    ];
    const showObservationsSection = observationsFields.some(hasValue);


    return (
        <article className="pico-paper" style={{ padding: '1.5rem', fontSize: '0.95rem' }}>
            {/* Sección de Identificación (siempre visible o con sus propias comprobaciones) */}
            <div className="grid">
                {renderField("Fecha", Dates.format(consultation.consultation_date))}
                {renderField("Hora", consultation.consultation_time)}
            </div>
            <div className="grid">
                {renderField("HC #", consultation.hc_number)}
                {renderField("Institución", consultation.institution_name)}
            </div>
            {(hasValue(consultation.hc_number) || hasValue(consultation.institution_name) || hasValue(consultation.consultation_time)) && <hr />}


            {showAnamnesisSection && (
                <>
                    <h4>Anamnesis</h4>
                    {renderField("Motivo de Consulta", consultation.reason_for_consultation, true)}
                    {renderField("Dieta Actual", consultation.current_diet, true)}
                    {renderField("Enfermedades Previas", consultation.previous_illnesses, true)}
                    {renderField("Cirugías Previas", consultation.previous_surgeries, true)}
                    {renderField("Esquema Vacunal (Resumen)", consultation.vaccination_history, true)}
                    {renderField("Última Desparasitación y Producto", consultation.last_deworming_product)}
                    {renderField("Tratamientos Recientes", consultation.recent_treatments, true)}
                    {renderField("Viajes Recientes", consultation.recent_travels, true)}
                    {renderField("Comportamiento del Animal (descripción del propietario)", consultation.animal_behavior_owner_description, true)}
                    {renderField("Convive con otros animales (detalles)", consultation.lives_with_other_animals_details)}
                    {renderField("Esterilizado", consultation.sterilized_status)}
                    {renderField("N° de Partos", consultation.birth_count)}
                    <hr />
                </>
            )}

            {showPhysicalExamSection && (
                <>
                    <h4>Examen Físico</h4>
                    {physicalExamGeneralFields.some(hasValue) && <h5>General</h5>}
                    {renderField("Condición Corporal (1-5)", consultation.body_condition_score)}
                    {renderField("Temperatura (°C)", consultation.temperature_celsius)}
                    {renderField("Frecuencia Cardíaca (lpm)", consultation.heart_rate_bpm)}
                    {renderField("Frecuencia Respiratoria (rpm)", consultation.respiratory_rate_rpm)}
                    {renderField("TRPC/TLLC (seg)", consultation.capillary_refill_time_sec)}
                    {renderField("Pulso (descripción)", consultation.pulse_description)}
                    {renderField("Mucosas (descripción)", consultation.mucous_membranes_description)}
                    {renderField("Hidratación (descripción)", consultation.hydration_percentage_description)}
                    {renderField("Órganos de los Sentidos (descripción)", consultation.sense_organs_description, true)}

                    {physicalExamSystemsFields.some(hasValue) && <h5 style={{ marginTop: '1rem' }}>Por Sistemas</h5>}
                    {renderField("Piel y Pelaje", consultation.skin_and_coat_description, true)}
                    {renderField("Ganglios Linfáticos", consultation.lymph_nodes_description, true)}
                    {renderField("Sistema Digestivo", consultation.digestive_system_findings, true)}
                    {renderField("Sistema Respiratorio", consultation.respiratory_system_findings, true)}
                    {renderField("Sistema Endocrino", consultation.endocrine_system_findings, true)}
                    {renderField("Sistema Músculo Esquelético", consultation.musculoskeletal_system_findings, true)}
                    {renderField("Sistema Nervioso", consultation.nervous_system_findings, true)}
                    {renderField("Sistema Urinario", consultation.urinary_system_findings, true)}
                    {renderField("Sistema Reproductivo", consultation.reproductive_system_findings, true)}
                    {renderField("Palpación Rectal", consultation.rectal_palpation_findings, true)}
                    {renderField("Otros Hallazgos Físicos", consultation.other_physical_findings, true)}
                    <hr />
                </>
            )}

            {consultation.procedures && consultation.procedures.length > 0 && (
                <>
                    <h4>Procedimientos Realizados en Consulta</h4>
                    {/* ... (código de lista de procedimientos sin cambios) ... */}
                    <ul style={{ paddingLeft: '1.5rem', listStyleType: 'disc' }}>
                        {consultation.procedures.map(proc => (
                            <li key={proc.id} style={{ marginBottom: '0.5rem' }}>
                                <strong>{proc.procedure_name}</strong>
                                {proc.description && <p style={{ fontSize: '0.9em', margin: '0.2em 0 0.5em 1em', color: 'var(--muted-color)' }}>{proc.description}</p>}
                            </li>
                        ))}
                    </ul>
                    <hr />
                </>
            )}

            {consultation.medications && consultation.medications.length > 0 && (
                <>
                    <h4>Medicamentos Administrados/Prescritos en Consulta</h4>
                    {/* ... (código de lista de medicamentos sin cambios) ... */}
                    <ul style={{ paddingLeft: '1.5rem', listStyleType: 'disc' }}>
                        {consultation.medications.map(med => (
                            <li key={med.id} style={{ marginBottom: '0.5rem' }}>
                                <strong>{med.medication_name}</strong>: {med.dosage} / {med.frequency}
                                {med.duration_days && <span> por {med.duration_days} día(s)</span>}
                                {med.notes && <p style={{ fontSize: '0.9em', margin: '0.2em 0 0.5em 1em', color: 'var(--muted-color)' }}>{med.notes}</p>}
                            </li>
                        ))}
                    </ul>
                    <hr />
                </>
            )}

            {showDiagnosticApproachSection && (
                <>
                    <h4>Abordaje Diagnóstico</h4>
                    {renderField("Lista de Problemas", consultation.problem_list, true)}
                    {renderField("Lista Maestra (Problema Principal)", consultation.master_problem_list, true)}
                    {renderField("Diagnósticos Diferenciales", consultation.differential_diagnoses, true)}
                    <hr />
                </>
            )}

            {/* Sección de Exámenes Complementarios y Archivos */}
            {(hasValue(consultation.complementary_exams_summary) || (consultation.files && consultation.files.length > 0) || canEditOrAddFiles) && (
                <>
                    <h4>Exámenes Complementarios</h4>
                    {renderField("Resumen de Exámenes / Hallazgos Principales", consultation.complementary_exams_summary, true)}

                    {consultation.files && consultation.files.length > 0 && (
                        // ... (código de lista de archivos sin cambios) ...
                        <div style={{ marginTop: '1rem', marginBottom: '1rem' }}>
                            <h5>Archivos Adjuntos:</h5>
                            {consultation.files.map(file => (
                                <div key={file.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.5rem 0.2rem', borderBottom: '1px solid var(--primary-inverse)' }}>
                                    <span style={{ display: 'flex', alignItems: 'center' }}><FaPaperclip style={{ marginRight: '0.5rem', color: 'var(--muted-color)' }} /> {file.file_name} <small style={{ marginLeft: '0.5rem', color: 'var(--muted-font-color)' }}>({(file.file_size_bytes || 0 / 1024).toFixed(1)}KB)</small></span>
                                    <div>
                                        <button onClick={() => handleDownloadFile(file)} className="outline secondary pico-button-small" aria-label="Descargar" title="Descargar" style={{ marginRight: '0.5rem', padding: '0.3rem 0.6rem' }}>
                                            <FaDownload />
                                        </button>
                                        {canEditOrAddFiles && (
                                            <button onClick={() => handleDeleteFile(file.id)} className="outline contrast pico-button-small" aria-label="Eliminar" title="Eliminar" style={{ padding: '0.3rem 0.6rem' }}>
                                                <FaTrash />
                                            </button>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {canEditOrAddFiles && (
                        // ... (código para añadir archivo sin cambios) ...
                        <div style={{ marginTop: '1.5rem', marginBottom: '1rem' }}>
                            <button type="button" onClick={() => setShowAddFile(prev => !prev)} className="outline pico-button-small">
                                {showAddFile ? 'Cancelar subida' : <><FaPlusCircle style={{ marginRight: '0.5rem' }} /> Adjuntar Nuevo Archivo</>}
                            </button>
                            {showAddFile && (
                                <div style={{ marginTop: '1rem', border: '1px dashed var(--primary)', padding: '1rem', borderRadius: 'var(--pico-border-radius)' }}>
                                    <label htmlFor="file-upload-detail">Seleccionar archivo:</label>
                                    <input id="file-upload-detail" type="file" ref={fileInputRef} onChange={handleFileSelect} accept={ALLOWED_FILE_TYPES_ARRAY.join(',')} />
                                    {fileToUpload && <p style={{ marginTop: '0.5rem', fontSize: '0.85em' }}>Seleccionado: {fileToUpload.name}</p>}
                                    {uploadError && <p className="text-error" style={{ marginTop: '0.5rem' }}>{uploadError}</p>}
                                    <button
                                        onClick={handleUploadFile}
                                        disabled={!fileToUpload || isUploading}
                                        aria-busy={isUploading}
                                        style={{ marginTop: '1rem' }}
                                    >
                                        {isUploading ? <><FaSpinner className="animate-spin" /> Subiendo...</> : "Confirmar y Subir Archivo"}
                                    </button>
                                </div>
                            )}
                        </div>
                    )}
                    <hr />
                </>
            )}


            {showDiagnosisPlanSection && (
                <>
                    <h4>Diagnóstico y Plan</h4>
                    {renderField("Diagnóstico Presuntivo Justificado", consultation.presumptive_diagnosis, true)}
                    {renderField("Diagnóstico Definitivo", consultation.definitive_diagnosis, true)}
                    {renderField("Plan Terapéutico", consultation.therapeutic_plan, true)}
                    {renderField("Pronóstico", consultation.prognosis, true)}
                    {renderField("Evolución", consultation.evolution_notes, true)}
                    <hr />
                </>
            )}

            {showObservationsSection && (
                <>
                    <h4>Observaciones Finales y Profesional</h4>
                    {renderField("Observaciones Generales / Anexos (descripción)", consultation.general_observations, true)}
                    {renderField("Confirmación/Firma Profesional", consultation.signature_confirmation)}
                    {/* {renderField("Veterinario Tratante ID", consultation.veterinarian_id || consultation.veterinary_access_id)} */}
                </>
            )}
        </article>
    );
} 
----- Archivo: ConsultationPetSummary.tsx ----- 
// src/components/consultations/ConsultationPetSummary.tsx
import React from 'react';
import { BasicDataType, VaccineDataType, MedicineDataType, SurgeryDataType, ConditionDataType } from '@/types/index';
import { Dates } from '@/utils/index';
import { FaExclamationTriangle, FaStethoscope, FaSyringe, FaPills, FaCut, FaHeartbeat } from 'react-icons/fa';

interface SummaryProps {
    basicData: BasicDataType | null;
    vaccines: VaccineDataType[] | null;
    medicines: MedicineDataType[] | null;
    surgeries: SurgeryDataType[] | null;
    conditions: ConditionDataType[] | null;
}

const SummaryItem: React.FC<{ icon: React.ReactNode; label: string; value: React.ReactNode; show?: boolean }> = ({ icon, label, value, show = true }) => {
    if (!show || !value) return null;
    return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
            <span style={{ color: 'var(--pico-primary)' }}>{icon}</span>
            <strong>{label}:</strong>
            <span>{value}</span>
        </div>
    );
};

export default function ConsultationPetSummary({ basicData, vaccines, medicines, surgeries, conditions }: SummaryProps) {
    if (!basicData) return null;

    return (
        <details style={{ marginBottom: '2rem' }}>
            <summary role="button" className="outline">Resumen de la Mascota</summary>
            <div style={{ padding: '1rem', border: '1px solid var(--pico-secondary)', borderRadius: '4px', marginTop: '0.5rem' }}>
                <SummaryItem icon={<FaExclamationTriangle />} label="Alergias" value={basicData.has_allergies ? 'Sí' : 'No'} />
                <SummaryItem icon={<FaStethoscope />} label="Condiciones Especiales" value={basicData.special_condition ? 'Sí' : 'No'} />
                {conditions && conditions.length > 0 && (
                    <SummaryItem
                        icon={<FaHeartbeat />}
                        label="Condiciones Listadas"
                        value={conditions.map(c => `${c.condition} (${c.severity})`).join(', ')}
                    />
                )}
                <SummaryItem
                    icon={<FaSyringe />}
                    label="Última Vacuna"
                    value={basicData.has_vaccine ? `${basicData.last_vaccine_name} el ${Dates.format(basicData.last_vaccine_date)}` : 'Ninguna registrada'}
                />
                {vaccines && vaccines.length > 1 && (
                    <SummaryItem
                        icon={<FaSyringe />}
                        label="Vacunas Anteriores"
                        show={vaccines.length > 1}
                        value={`${vaccines.length - 1} más registradas`}
                    />
                )}
                <SummaryItem
                    icon={<FaPills />}
                    label="Usa Medicamentos"
                    value={basicData.uses_medicine ? 'Sí' : 'No'}
                />
                {medicines && medicines.length > 0 && (
                    <SummaryItem
                        icon={<FaPills />}
                        label="Medicamentos Listados"
                        value={medicines.map(m => m.name).join(', ')}
                    />
                )}
                {surgeries && surgeries.length > 0 && (
                    <SummaryItem
                        icon={<FaCut />}
                        label="Cirugías Previas"
                        value={surgeries.map(s => `${s.name} el ${Dates.format(s.date)}`).join('; ')}
                    />
                )}
            </div>
        </details>
    );
} 
----- Archivo: index.ts ----- 
export { default as BasicDataForm } from './BasicDataForm';
export { default as PetNameForm } from './PetNameForm'; 
----- Archivo: BasicDataForm.tsx ----- 
// src/components/forms/BasicDataForm.tsx
import React, { useState, useEffect, Dispatch } from 'react';
import { InitialBasicDataType, PetStep as PetStep, PetType, type BasicDataType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import { Dates, Steps } from '@/utils/index';
import { petTypes, genders, weightUnits, breedOptions, foodOptions, weightConditionOptions, sizeOptions, coatTypes, colorOptions } from '@/data/petdata';
import { Empty } from '@/data/index';
import { useDeviceDetect } from '@/hooks/useDeviceDetect';
import { postFetch } from '@/app/api';
import StepsComponent from '../lib/steps';
import { useStorageContext } from '@/context/StorageProvider';

interface BasicDataFormProps {
  pet: PetType;
  basicData: BasicDataType;
  setBasicData: (basicData: BasicDataType) => void;
  onBack: () => void;
  onNext: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
  setShowModal: Dispatch<React.SetStateAction<boolean>>;
}

export default function BasicDataForm({ pet, basicData, setBasicData, onNext, onBack, stepStates, setStepStates, setShowModal }: BasicDataFormProps) {
  const step = PetStep.BasicData;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  }
  const stateEq = (stepState: StepStateEnum) => {
    return stepStates.find(x => x.step == step)?.state == stepState;
  }
  const initials = (basicData: BasicDataType, fetch: boolean = false): InitialBasicDataType => {
    const initialPetType = petTypes.filter(t => t == basicData.pet_type).length > 0 || (basicData.pet_type == '' && !fetch) ? basicData.pet_type : 'Otro';
    const initialFood = foodOptions.find(t => t == basicData.main_food) != null || (basicData.main_food == '' && !fetch) ? basicData.main_food : 'Otro';
    const initialRace = (breedOptions[initialPetType] ?? []).filter(t => t == basicData.race).length > 0 || (basicData.race == '' && !fetch) ? basicData.race : 'Otro';
    const initialOtherPetType = initialPetType != 'Otro' && basicData.pet_type == 'Otro' ? '' : basicData.pet_type;
    const initialOtherFood = initialFood != 'Otro' && basicData.main_food == 'Otro' ? '' : basicData.main_food;
    const initialOtherRace = initialRace != 'Otro' && basicData.race == 'Otro' ? '' : basicData.race;
    return {
      petType: initialPetType,
      food: initialFood,
      race: initialRace,
      otherPetType: initialOtherPetType,
      otherFood: initialOtherFood,
      otherRace: initialOtherRace
    };
  };

  const initial = initials(basicData);
  const [formData, setFormData] = useState<Partial<BasicDataType>>({ ...basicData, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [weight, setWeight] = useState<number>(parseFloat(basicData.weight.split(' ')[0]) ?? 0);
  const [weightUnit, setWeightUnit] = useState<string>(basicData.weight.split(' ')[1]);
  const [otherPetType, setOtherPetType] = useState<string>(initial.otherPetType);
  const [otherFood, setOtherFood] = useState<string>(initial.otherFood);
  const [otherRace, setOtherRace] = useState<string>(initial.otherRace);
  const [loadedWithPreviusData, setLoadedWithPreviusData] = useState<boolean>(false);
  const [savedData, setSavedData] = useState<BasicDataType>(Empty.BasicData());
  const { isMobile, isDesktop, isTablet } = useDeviceDetect();
  const storage = useStorageContext();

  const sectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: isMobile
      ? "repeat(2, 1fr)"
      : "repeat(4, 1fr)"
  };
  const tabletSectionGridStyle: React.CSSProperties = {
    display: "grid",
    gap: "1rem",
    gridTemplateColumns: "repeat(2, 1fr)"
  };

  useEffect(() => {
    if (JSON.stringify(savedData) != JSON.stringify(formData) && !stateEq(StepStateEnum.NotInitialize) && loadLoading == false) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData, otherPetType, otherFood, otherRace, weight, weightUnit]);

  useEffect(() => {
    const fetchData = async () => {
      setLoadLoading(true);
      if (stateEq(StepStateEnum.NotInitialize) && !basicData.pet_id)
        if (stateEq(StepStateEnum.NotInitialize)) {
          setState(StepStateEnum.Initialize);
          let basicDataSaved: BasicDataType = Empty.BasicData();
          if (!storage.storedBasicData.pet_id) {
            const petResponse = await fetch(`/api/pets/basic-data/${pet.id}`);
            if (!petResponse.ok) throw new Error("Falló fetch basic-data");
            const data = await petResponse.json() as BasicDataType;
            if (data) {
              basicDataSaved = data;
            }

          }
          else if (storage.storedBasicData.pet_id == pet.id) {
            basicDataSaved = storage.storedBasicData;
          }
          if (basicDataSaved.pet_id) {
            setSavedData(basicDataSaved);
            setBasicData(basicDataSaved);
            const initial = initials(basicDataSaved, loadedWithPreviusData);
            setLoadedWithPreviusData(true);
            setFormData({ ...basicDataSaved, pet_id: pet.id, pet_type: initial.petType, main_food: initial.food, race: initial.race });
            setWeight(parseFloat(basicDataSaved.weight.split(' ')[0]));
            setWeightUnit(basicDataSaved.weight.split(' ')[1]);
            setOtherPetType(initial.otherPetType);
            setOtherRace(initial.otherRace);
            setOtherFood(initial.otherFood);
          }
        }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet.id, formData]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(false);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        const finalFood = formData.main_food === 'Otro' ? otherFood.trim() : formData.main_food;
        const finalPetType = formData.pet_type === 'Otro' ? otherPetType.trim() : formData.pet_type;
        const finalRace = formData.race === 'Otro' ? otherRace.trim() : formData.race;
        const finalWeight = `${weight ?? 0} ${weightUnit}`;
        const dataToSave: BasicDataType = {
          ...(formData as BasicDataType),
          main_food: finalFood || '',
          weight: finalWeight || '0 Kg',
          pet_type: finalPetType || '',
          race: finalRace || '',
        };
        const basicDataResponse = await postFetch(`/api/pets/basic-data/${formData.pet_id}`, undefined, dataToSave);
        if (!basicDataResponse.ok) throw new ApiError("Error actualizado datos básicos de la mascota");
        setSavedData(dataToSave);
        setBasicData(dataToSave);
        if (dataToSave.pet_id == storage.storedBasicData.pet_id) {
          storage.setStoredBasicData(dataToSave);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
      setSubmitLoading(true);
    } finally {
      setSubmitLoading(true);
    }
  };

  return (
    <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={stepStates.length} error={error} setShowModal={setShowModal}>
      <fieldset>
        <legend><b>Información básica</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="pet_type">Tipo de mascota</label>
            <select
              id="pet_type"
              className="w-full"
              value={formData.pet_type}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: 'Otro', race: '' });
                } else {
                  setOtherPetType(initial.petType);
                  setFormData({ ...formData, pet_type: val, race: '' });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona tipo</option>
              {petTypes.map(type => <option key={type} value={type}>{type}</option>)}
            </select>
            {formData.pet_type === 'Otro' && (
              <input
                value={otherPetType}
                type="text"
                placeholder="Especifica el tipo"
                className="w-full mt-2"
                disabled={loadLoading}
                onChange={e => setOtherPetType(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="gender">Género</label>
            <select
              id="gender"
              className="w-full"
              value={formData.gender}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, gender: e.target.value })}
              required
            >
              <option value="" disabled>Selecciona género</option>
              {genders.map(g => <option key={g} value={g}>{g}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="weight">Peso</label>
            <div className="flex gap-2">
              <input
                id="weight"
                type="number"
                pattern="^\d+(?:\.\d{1,2})?$"
                min="0"
                className="w-2/3"
                disabled={loadLoading}
                value={weight ?? 0}
                onChange={e => setWeight(parseFloat(e.target.value) ?? 0)}
                required
              />
              <select
                id="weight_unit"
                className="w-1/3"
                value={weightUnit}
                disabled={loadLoading}
                onChange={e => setWeightUnit(e.target.value)}
              >
                {weightUnits.map(u => <option key={u} value={u}>{u}</option>)}
              </select>
            </div>
          </div>
          <div>
            <label htmlFor="race">Raza</label>
            <select
              id="race"
              className="w-full"
              disabled={loadLoading || !formData.pet_type}
              value={formData.race}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: 'Otro' });
                } else {
                  setOtherRace(initial.otherRace);
                  setFormData({ ...formData, race: val });
                }
              }}
              required
            >
              <option value="" disabled>{formData.pet_type ? 'Selecciona raza' : 'Selecciona primero tipo'}</option>
              {formData.pet_type && breedOptions[formData.pet_type].map(r => <option key={r} value={r}>{r}</option>)}
            </select>
            {formData.race === 'Otro' && (
              <input
                value={otherRace}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la raza"
                className="w-full mt-2"
                onChange={e => setOtherRace(e.target.value)}
              />
            )}
          </div>
          {/* ... (Tipo de mascota, Género, Peso, Raza sin cambios) ... */}
          <div>
            <label htmlFor="coat_type">Tipo de pelaje</label>
            <select
              id="coat_type"
              className="w-full"
              value={formData.coat_type}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, coat_type: e.target.value })}
            >
              <option value="" disabled>Selecciona tipo de pelaje</option>
              {coatTypes.map(type => <option key={type} value={type}>{type}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="color">Color principal</label>
            <select
              id="color"
              className="w-full"
              value={formData.color}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, color: e.target.value })}
            >
              <option value="" disabled>Selecciona un color</option>
              {colorOptions.map(c => <option key={c} value={c}>{c}</option>)}
            </select>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend><b>Alimentación y entorno</b></legend>
        <div style={sectionGridStyle}>
          <div>
            <label htmlFor="main_food">Comida principal</label>
            <select
              id="main_food"
              className="w-full"
              value={formData.main_food}
              disabled={loadLoading}
              onChange={e => {
                const val = e.target.value;
                if (val === 'Otro') {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: 'Otro' });
                } else {
                  setOtherFood(initial.otherFood);
                  setFormData({ ...formData, main_food: val });
                }
              }}
              required
            >
              <option value="" disabled>Selecciona comida</option>
              {foodOptions.map(food => <option key={food} value={food}>{food}</option>)}
            </select>
            {formData.main_food === 'Otro' && (
              <input
                value={otherFood}
                disabled={loadLoading}
                type="text"
                placeholder="Especifica la comida"
                className="w-full mt-2"
                onChange={e => setOtherFood(e.target.value)}
              />
            )}
          </div>
          <div>
            <label htmlFor="weight_condition">Condición de peso</label>
            <select
              id="weight_condition"
              className="w-full"
              value={formData.weight_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, weight_condition: e.target.value })}
            >
              <option value="" disabled>Selecciona condición</option>
              {weightConditionOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
          <div>
            <label htmlFor="size">Tamaño</label>
            <select
              id="size"
              className="w-full"
              value={formData.size}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, size: e.target.value })}
            >
              <option value="" disabled>Selecciona tamaño</option>
              {sizeOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
        </div>
        <div style={sectionGridStyle}>
          <div>
            <label className="flex items-center gap-2" htmlFor="lives_with_others">
              <input
                id="lives_with_others"
                type="checkbox"
                checked={formData.lives_with_others}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, lives_with_others: e.target.checked })}
              />
              Vive con otros
            </label>
          </div>
          <div>
            <label className="flex items-center gap-2" htmlFor="has_allergies">
              <input
                id="has_allergies"
                type="checkbox"
                checked={formData.has_allergies}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_allergies: e.target.checked })}
              />
              Alergias
            </label>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend><b>Vacunación y procedimientos</b></legend>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          <div style={{ gridColumn: 'span 2' }}>
            <label className="flex items-center gap-2" htmlFor="has_vaccine">
              <input
                id="has_vaccine"
                type="checkbox"
                checked={formData.has_vaccine}
                disabled={loadLoading}
                onChange={e => setFormData({ ...formData, has_vaccine: e.target.checked })}
              />
              Tiene vacunas
            </label>
          </div>
          {isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_sterilized">
                  <input
                    id="is_sterilized"
                    type="checkbox"
                    checked={formData.is_sterilized}
                    onChange={e => setFormData({ ...formData, is_sterilized: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Esterilizado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
        </div>
        <div style={isTablet ? tabletSectionGridStyle : sectionGridStyle}>
          {formData.has_vaccine && (
            <>
              <div>
                <label htmlFor="last_vaccine_name">Nombre última vacuna</label>
                <input
                  id="last_vaccine_name"
                  type="text"
                  className="w-full"
                  value={formData.last_vaccine_name}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_name: e.target.value })}
                />
              </div>
              <div>
                <label htmlFor="last_vaccine_date">Fecha última vacuna</label>
                <input
                  id="last_vaccine_date"
                  type="date"
                  className="w-full"
                  value={formData.last_vaccine_date ? Dates.format(formData.last_vaccine_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, last_vaccine_date: e.target.valueAsDate || undefined })}
                />
              </div>
            </>
          )}
          {!formData.has_vaccine &&
            <>
              <div style={{ gridColumn: 'span 2' }}></div>
            </>}
          {!isDesktop &&
            <>
              <div>
                <label className="flex items-center gap-2" htmlFor="is_sterilized">
                  <input
                    id="is_sterilized"
                    type="checkbox"
                    checked={formData.is_sterilized}
                    onChange={e => setFormData({ ...formData, is_sterilized: e.target.checked })}
                    disabled={loadLoading}
                  />
                  Esterilizado
                </label>
              </div>
              <div>
                <label className="flex items-center gap-2" htmlFor="has_anti_flea">
                  <input
                    id="has_anti_flea"
                    type="checkbox"
                    checked={formData.has_anti_flea}
                    disabled={loadLoading}
                    onChange={e => setFormData({ ...formData, has_anti_flea: e.target.checked })}
                  />
                  Antipulgas
                </label>
              </div>
            </>
          }
          <div>
            {formData.is_sterilized && (
              <div>
                <label htmlFor="sterilization_date">Fecha de esterilización</label>
                <input
                  id="sterilization_date"
                  type="date"
                  className="w-full"
                  value={formData.sterilization_date ? Dates.format(formData.sterilization_date) : ''}
                  onChange={e => setFormData({ ...formData, sterilization_date: e.target.valueAsDate || undefined })}
                  disabled={loadLoading}
                />
              </div>
            )}
          </div>
          <div>
            {formData.has_anti_flea && (
              <div>
                <label htmlFor="anti_flea_date">Fecha antipulgas</label>
                <input
                  id="anti_flea_date"
                  type="date"
                  className="w-full"
                  value={formData.anti_flea_date ? Dates.format(formData.anti_flea_date) : ''}
                  disabled={loadLoading}
                  onChange={e => setFormData({ ...formData, anti_flea_date: e.target.valueAsDate || undefined })}
                />
              </div>
            )}
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend><b>Otros datos</b></legend>
        <div style={sectionGridStyle}>
          <label className="flex items-center gap-2" htmlFor="uses_medicine">
            <input
              id="uses_medicine"
              type="checkbox"
              checked={formData.uses_medicine}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, uses_medicine: e.target.checked })}
            />
            Usa medicina
          </label>
          <label className="flex items-center gap-2" htmlFor="special_condition">
            <input
              id="special_condition"
              type="checkbox"
              checked={formData.special_condition}
              disabled={loadLoading}
              onChange={e => setFormData({ ...formData, special_condition: e.target.checked })}
            />
            Condición especial
          </label>
        </div>
      </fieldset>
    </StepsComponent>
  );
} 
----- Archivo: CountryCitySelector.tsx ----- 
// src/components/forms/CountryCitySelector.tsx
"use client";

import React, { useState, useEffect } from 'react';
import { Country, City } from 'country-state-city';
import type { ICountry, ICity } from 'country-state-city';

interface CountryCitySelectorProps {
    onCountryChange: (country: ICountry | undefined) => void;
    onCityChange: (city: ICity | undefined) => void;
    initialCountryCode?: string;
    initialCityName?: string;
}

export default function CountryCitySelector({
    onCountryChange,
    onCityChange,
    initialCountryCode = 'CO', // Default a Colombia
    initialCityName = ''
}: CountryCitySelectorProps) {

    const [countries, setCountries] = useState<ICountry[]>([]);
    const [selectedCountry, setSelectedCountry] = useState<ICountry | undefined>();
    const [cityInput, setCityInput] = useState(initialCityName);
    const [citySuggestions, setCitySuggestions] = useState<ICity[]>([]);

    useEffect(() => {
        setCountries(Country.getAllCountries());
    }, []);

    useEffect(() => {
        const country = Country.getCountryByCode(initialCountryCode);
        setSelectedCountry(country);
        onCountryChange(country);
        setCityInput(initialCityName);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [initialCountryCode, initialCityName]);


    const handleCountryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const countryCode = e.target.value;
        const country = Country.getCountryByCode(countryCode);
        setSelectedCountry(country);
        onCountryChange(country);
        setCityInput(''); // Resetear ciudad al cambiar de país
        onCityChange(undefined);
        setCitySuggestions([]);
    };

    const handleCityInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const input = e.target.value;
        setCityInput(input);
        if (input.length > 1 && selectedCountry) {
            const suggestions = City.getCitiesOfCountry(selectedCountry.isoCode)?.filter(c =>
                c.name.toLowerCase().startsWith(input.toLowerCase())
            );
            setCitySuggestions(suggestions || []);
        } else {
            setCitySuggestions([]);
        }
    };

    const handleCitySuggestionClick = (city: ICity) => {
        setCityInput(city.name);
        onCityChange(city);
        setCitySuggestions([]);
    };

    return (
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
            <div>
                <label htmlFor="country">País</label>
                <select id="country" value={selectedCountry?.isoCode || ''} onChange={handleCountryChange}>
                    <option value="" disabled>Selecciona un país</option>
                    {countries.map(country => (
                        <option key={country.isoCode} value={country.isoCode}>
                            {country.name}
                        </option>
                    ))}
                </select>
            </div>

            <div style={{ position: 'relative' }}>
                <label htmlFor="city">Ciudad</label>
                <input
                    id="city"
                    type="text"
                    value={cityInput}
                    onChange={handleCityInputChange}
                    placeholder={selectedCountry ? "Escribe para buscar..." : "Selecciona un país primero"}
                    disabled={!selectedCountry}
                    autoComplete="off"
                />
                {citySuggestions.length > 0 && (
                    <ul style={{
                        position: 'absolute',
                        top: '100%',
                        left: 0,
                        right: 0,
                        background: 'var(--primary-inverse)',
                        border: '1px solid var(--primary-lightgray)',
                        borderRadius: '0.5rem',
                        maxHeight: '150px',
                        overflowY: 'auto',
                        zIndex: 100,
                        padding: 0,
                        listStyle: 'none'
                    }}>
                        {citySuggestions.slice(0, 10).map(city => (
                            <li
                                key={city.name}
                                onClick={() => handleCitySuggestionClick(city)}
                                className="city-suggestion-item"
                                style={{ padding: '0.5rem', cursor: 'pointer' }}
                            >
                                {city.name}
                            </li>
                        ))}
                    </ul>
                )}
            </div>
        </div>
    );
} 
----- Archivo: CountryCodeInput.tsx ----- 
// src/components/forms/CountryCodeInput.tsx
"use client";
import 'react-phone-number-input/style.css';
import PhoneInput, { isPossiblePhoneNumber } from 'react-phone-number-input';
import { useState } from 'react';

interface CountryCodeInputProps {
    value: string | undefined;
    onChange: (value: string | undefined) => void;
    defaultCountry?: "CO"; // Usamos CO como default
}

export default function CountryCodeInput({ value, onChange, defaultCountry = "CO" }: CountryCodeInputProps) {
    const [error, setError] = useState('');

    const handleChange = (newValue: string | undefined) => {
        if (newValue && !isPossiblePhoneNumber(newValue)) {
            setError('Número de teléfono no válido.');
        } else {
            setError('');
        }
        onChange(newValue);
    }

    return (
        <div>
            <PhoneInput
                international
                defaultCountry={defaultCountry}
                value={value}
                onChange={handleChange}
                style={{
                    '--PhoneInput-color': 'var(--pico-form-element-color)',
                    '--PhoneInput-backgroundColor': 'var(--pico-form-element-background-color)',
                    '--PhoneInput-borderColor': 'var(--pico-form-element-border-color)',
                    '--PhoneInput-borderWidth': '1px',
                    '--PhoneInput-borderRadius': 'var(--pico-border-radius)',
                    '--PhoneInputCountrySelect-borderColor': 'var(--pico-form-element-border-color)',
                }}
                className="pico-input" // Usa una clase que no exista para que no herede estilos conflictivos
            />
            {error && <small style={{ color: 'var(--pico-form-element-invalid-active-border-color)' }}>{error}</small>}
        </div>
    );
} 
----- Archivo: MapPicker.tsx ----- 
// src/components/forms/MapPicker.tsx
"use client";
import { MapContainer, TileLayer, Marker, useMap, useMapEvents } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import "leaflet/dist/images/marker-shadow.png";
import "leaflet/dist/images/marker-icon.png";
import { useEffect, useMemo, useRef } from 'react';

// Arreglo para el ícono por defecto de Leaflet que se rompe con Webpack
const DefaultIcon = L.icon({
    iconUrl: '/images/marker-icon.png',
    iconRetinaUrl: '/images/marker-icon-2x.png',
    shadowUrl: '/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});

interface MapPickerProps {
    coords: { lat: number; lng: number };
    onCoordsChange: (coords: { lat: number; lng: number }) => void;
}

// Componente interno para actualizar la vista del mapa cuando las coordenadas cambian
function ChangeView({ center }: { center: [number, number] }) {
    const map = useMap();
    map.setView(center, map.getZoom());
    return null;
}

// Componente interno para manejar los eventos del mapa
function MapEvents({ onCoordsChange }: { onCoordsChange: (coords: { lat: number, lng: number }) => void }) {
    useMapEvents({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        click(e: any) {
            onCoordsChange(e.latlng);
        },
    });
    return null;
}

export default function MapPicker({ coords, onCoordsChange }: MapPickerProps) {
    const markerRef = useRef<L.Marker>(null);

    const eventHandlers = useMemo(() => ({
        dragend() {
            const marker = markerRef.current;
            if (marker != null) {
                onCoordsChange(marker.getLatLng());
            }
        },
    }), [onCoordsChange]);

    // Asegúrate de que las imágenes de los marcadores estén en la carpeta /public/images/
    useEffect(() => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete (L.Icon.Default.prototype as any)._getIconUrl;
        L.Icon.Default.mergeOptions({
            iconRetinaUrl: '/images/marker-icon-2x.png',
            iconUrl: '/images/marker-icon.png',
            shadowUrl: '/images/marker-shadow.png',
        });
    }, []);


    return (
        <MapContainer center={[coords.lat, coords.lng]} zoom={15} style={{ height: '300px', width: '100%', borderRadius: '8px' }}>
            <TileLayer
                attribution='© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />
            <Marker
                position={[coords.lat, coords.lng]}
                draggable={true}
                eventHandlers={eventHandlers}
                ref={markerRef}
                icon={DefaultIcon}
            />
            <ChangeView center={[coords.lat, coords.lng]} />
            <MapEvents onCoordsChange={onCoordsChange} />
        </MapContainer>
    );
} 
----- Archivo: PetNameForm.tsx ----- 
// src/components/forms/PetNameForm.tsx
import React, { Dispatch, useEffect, useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { FaCloudUploadAlt } from 'react-icons/fa';
import { generateUniquePetId } from '@/utils/random';
import { PetStep, PetType } from '@/types/index';
import { ApiError, StepsStateType, StepStateEnum } from '@/types/lib';
import StepsComponent from '../lib/steps';
import { Dates, Steps } from '@/utils/index';
import { Empty } from '@/data/index';
import { CircularImage } from "@/components/index";
import { getFetch, postFetch } from '@/app/api';
import { useStorageContext } from '@/context/StorageProvider';

interface PetFormProps {
  ownerId: string;
  pet: PetType;
  setPet: (pet: PetType) => void;
  onNext: () => void;
  onBack: () => void;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>;
  setShowModal: Dispatch<React.SetStateAction<boolean>>;
}

export default function PetNameForm({
  ownerId,
  pet,
  setPet,
  onNext,
  onBack,
  stepStates,
  setStepStates,
  setShowModal
}: PetFormProps) {
  const step = PetStep.Name;
  const setState = (stepState: StepStateEnum, stepError: string | null = null) => {
    Steps.ChangeState(stepStates, setStepStates, step, stepState, stepError);
  };
  const stateEq = (stepState: StepStateEnum) =>
    stepStates.find((x) => x.step === step)?.state === stepState;

  const [error, setError] = useState<string | null>(null);
  const [loadLoading, setLoadLoading] = useState(true);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [savedData, setSavedData] = useState<PetType>(Empty.Pet());
  const [preview, setPreview] = useState<string>(pet.image || '/pets/pet.jpg');
  const storage = useStorageContext();

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result as string;
      setPet({ ...pet, image: base64 });
      setPreview(base64);
    };
    reader.readAsDataURL(file);
  }, [pet, setPet]);

  const { getRootProps, getInputProps, isDragActive, open } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    multiple: false,
    noClick: true,
    noKeyboard: true,
  });

  useEffect(() => {
    const fetchData = async () => {
      if (stateEq(StepStateEnum.NotInitialize) && !pet.id) {
        setState(StepStateEnum.Initialize);
      } else if (stateEq(StepStateEnum.NotInitialize)) {
        setState(StepStateEnum.Initialize);
        let petSaved: PetType = Empty.Pet();
        if (!storage.storedPet.id) {
          const response = await getFetch(`/api/pets/${pet.id}`);
          if (!response.ok) {
            throw new ApiError('Error al obtener la mascota');
          }
          petSaved = (await response.json())[0] as PetType;
        }
        else if (storage.storedPet.id == pet.id) {
          petSaved = storage.storedPet;
        }
        if (petSaved) {
          setPet(petSaved);
          setSavedData(petSaved);
          setPreview(petSaved.image || preview);
        }
      }
      setLoadLoading(false);
    };
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  useEffect(() => {
    if (
      JSON.stringify(savedData) !== JSON.stringify(pet) &&
      !stateEq(StepStateEnum.NotInitialize)
    ) {
      setState(StepStateEnum.Modified);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pet]);

  const handleSubmit = async () => {
    setError(null);
    setSubmitLoading(true);
    try {
      if (!stateEq(StepStateEnum.Saved) || stateEq(StepStateEnum.Modified)) {
        if (!pet.id && storage.storedOwnerPets.filter(p => p.name == pet.name).length > 0) {
          throw new ApiError('Ya tienes una mascota registrada con ese mismo nombre.');
        }
        const newId = pet.id || (await generateUniquePetId());
        const newPet: PetType = { id: newId, name: pet.name, image: pet.image, birth_date: pet.birth_date, owner_id: ownerId };
        if (JSON.stringify(newPet) != JSON.stringify(pet)) {
          const response = await postFetch('/api/pets', undefined, newPet);
          const result = await response.json();
          if (!response.ok) {
            throw new ApiError('Error al guardar mascota');
          }
          const savedPet: PetType = result[0] as PetType;
          setSavedData(savedPet);
          if (newPet.id)
            storage.setStoredPet(savedPet);
          const pets = storage.storedOwnerPets.filter((p: PetType) => p.id != savedPet.id);
          storage.setStoredOwnerPets([...pets, savedPet]);
          setPet(savedPet);
        }
        setState(StepStateEnum.Saved);
      }
      onNext();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
      setState(StepStateEnum.Error, err.message);
      setError(err.message);
    } finally {
      setSubmitLoading(false);
    }
  };

  return (
    <StepsComponent
      onBack={onBack}
      onNext={handleSubmit}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      step={step}
      totalSteps={stepStates.length}
      error={error}
      setShowModal={setShowModal}
    >
      <div style={{ display: 'grid', gap: '1rem', marginBottom: '30px' }}>
        <div style={{display: 'flex', gap: '1rem' }}>
          <label>
            Nombre
            <input
              type="text"
              value={pet.name}
              disabled={loadLoading}
              onChange={(e) => setPet({ ...pet, name: e.target.value })}
              required
            />
          </label>

          <label>
            Fecha de Nacimiento
            <input
              type="date"
              value={Dates.format(pet.birth_date)}
              disabled={loadLoading}
              onChange={(e) => setPet({ ...pet, birth_date: e.target.valueAsDate })}
              required
            />
          </label>
        </div>
        {pet.image ? (
          <CircularImage
            src={preview}
            width={200}
            getRootProps={getRootProps}
            getInputProps={getInputProps}
            onClick={open}
            overlayText="Cambiar foto"
            hoverEnabled={true}
          />
        ) : (
          <div
            {...getRootProps()}
            style={{
              border: `2px dashed ${isDragActive ? 'var(--pico-primary)' : 'var(--primary-lightgray)'}`,
              borderRadius: '4px',
              padding: '1.5rem',
              backgroundColor: isDragActive ? 'var(--primary-skin)' : 'var(--primary-darkerskin)',
              textAlign: 'center',
              cursor: 'pointer'
            }}
            onClick={open}
          >
            <input {...getInputProps()} />
            <FaCloudUploadAlt
              style={{ fontSize: '2rem', color: isDragActive ? 'var(--pico-primary)' : 'var(--primary-darkgray)' }}
            />
            <p style={{ marginTop: '0.5rem', fontWeight: 'bold' }}>
              <b>Selecciona o</b> arrastra y suelta la foto aquí
            </p>
          </div>
        )}
      </div>
    </StepsComponent>
  );
}
 
----- Archivo: SideBar.tsx ----- 
// app/components/layout/SideBar.tsx
"use client";
import React, { useEffect, useState } from "react";
import {
    FaBars,
    FaCalendar,
    FaStethoscope,
    FaCog,
    FaCut,
    FaFlask,
    FaHome,
    FaPills,
    FaPowerOff,
    //TODO: actualizar para menu de actualizar plan
    //FaRocket,
    FaSyringe,
    FaUser
} from "react-icons/fa";
import Link from 'next/link';
import Image from 'next/image';
import { MenuType } from "@/types/lib";
import { v4 } from 'uuid';
import { useRouter } from "next/navigation";
import { FaPencil, FaUserDoctor } from "react-icons/fa6";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { handleLogout } from "@/services/authService";
import { useSessionContext } from "@/context/SessionProvider";
import { useRoleContext } from "@/context/RoleProvider";
import { FaPlusCircle } from 'react-icons/fa';

export default function SideBar() {
    const { isMobile, isTablet, isDesktop } = useDeviceDetect();
    const { db: session, isLoading: isLoadingSession } = useSessionContext();
    const storage = useStorageContext();
    const [menuItems, setMenuItems] = useState<MenuType[]>([]);
    const router = useRouter();
    const { setShowEditPetModal } = useUI();
    const { isOwner, isVet, isVetWithSession } = useRoleContext();

    const menuData = (show: boolean): MenuType[] => [
        { label: "Inicio", icon: <FaHome />, url: "/pages/home", show: isOwner || isVetWithSession },
        { label: "Calendario", icon: <FaCalendar />, url: "/pages/owner/calendar", show: isOwner },
        { label: "Datos básicos", icon: <FaUser />, url: "/pages/pet/basic-data", show },
        { label: "Consultas veterinarias", icon: <FaUserDoctor />, url: `/pages/pet/consultations/${storage.storedPet.id}`, show },
        { label: "Vacunas", icon: <FaSyringe />, url: "/pages/pet/vaccines", show },
        { label: "Cirugías", icon: <FaCut />, url: "/pages/pet/surgeries", show },
        { label: "Medicinas", icon: <FaPills />, url: "/pages/pet/medicines", show },
        { label: "Condiciones especiales", icon: <FaStethoscope  />, url: "/pages/pet/conditions", show },
        { label: "Exámenes laboratorio", icon: <FaFlask />, url: "/pages/pet/lab-tests", show },
        //TODO: modal para actualizar el plan
        //{ label: "Mejora tu plan", icon: <FaRocket />, url: "/pages/owner/upgrade", show: isOwner },
        { label: "Configuración", icon: <FaCog />, url: "/pages/owner/settings", show: isOwner },
        { label: "Configuración", icon: <FaCog />, url: "/pages/vet/settings", show: isVetWithSession },
        { label: 'Editar Mascota', icon: <FaPencil />, url: "", showModal: setShowEditPetModal, show: isOwner && show },
        { label: "Agregar Consulta", icon: <FaPlusCircle />, url: `/pages/vet/consultation/${storage.storedPet.id}`, show: isVet && show },
    ];
    useEffect(() => {
        const menu = menuData(storage.storedPet.id != "");
        setMenuItems(menu);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedPet, storage.storedOwnerPets, session, storage.storedVetAccess, setShowEditPetModal, isVetWithSession]);

    const goToLogin = () => {
        storage.setStoredVetAccess(Empty.VetAccess());
        router.push("/login");
    }

    if (menuItems.filter(m => m.show).length == 0 || isLoadingSession) {
        return <></>;
    }

    function item({ label, icon, url, show, showModal }: MenuType) {
        if (!show) {
            return <div key={v4()}></div>;
        }
        else if (showModal) {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <a onClick={() => showModal(true)} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </a>
                </li>
            );
        }
        else {
            return (
                <li key={label} style={{ marginBottom: "0.5rem" }}>
                    <Link href={url} style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                        {icon} {label}
                    </Link>
                </li>
            );
        }
    }

    return (
        <>
            {/* Desktop Sidebar */}
            {isDesktop && (
                <aside
                    style={{
                        width: "300px",
                        display: "flex",
                        flexDirection: "column",
                        paddingTop: "1rem",
                        backgroundColor: "var(--primary-inverse)",
                        boxShadow: "0 4px 12px var(--primary-lighttransparent)",
                    }}
                >
                    <div style={{ padding: "0 1rem 1rem", display: 'flex', alignItems: 'center' }}>
                        <CircularImage
                            src={storage.storedPet.image || "/pets/pet.jpg"}
                            width={80}
                        />
                        <p style={{ marginLeft: '20px' }}>
                            <b>{storage.storedPet.name ?? 'Nombre de tu mascota'}</b>
                        </p>
                    </div>
                    <nav style={{ padding: "0 1rem" }}>
                        <ul>
                            {menuItems.map(item)}
                            {session && <li><a style={{ background: "none", border: "none", color: 'var(--primary-red)' }} onClick={() => handleLogout(storage, router)}> <FaPowerOff style={{ marginRight: '1rem' }} />Cerrar sesión</a></li>}
                            {!session && <li><button onClick={goToLogin}>Iniciar sesión</button></li>}
                        </ul>
                    </nav>
                    <div style={{ display: "flow", justifyContent: "space-around", marginTop: "1rem" }}>
                        <Image src="/others/play-store.png" alt="Google Play" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                        <br /><br />
                        <Image src="/others/app-store.png" alt="App Store" width="120" height="100" style={{ width: "220px", height: "auto" }} />
                    </div>
                </aside>
            )}

            {/* Mobile Sidebar */}
            {(isMobile || isTablet) && (
                <aside
                    style={{
                        position: "fixed",
                        top: 0,
                        bottom: 0,
                        left: 0,
                        width: "64px",
                        backgroundColor: "var(--primary-inverse)",
                        boxShadow: "2px 0 8px var(--primary-lighttransparent)",
                        zIndex: 1000,
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        paddingTop: "1rem",
                        gap: "1rem"
                    }}
                >
                    {/* Foto y nombre */}
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>
                        <CircularImage src={storage.storedPet.image || "/pets/pet.jpg"} width={50} borderSize="2px" />
                        <span style={{ fontSize: "1rem", textAlign: "center", padding: "0 4px" }}><b>{storage.storedPet.name}</b></span>
                    </div>

                    {/* Íconos con tooltip */}
                    {menuItems.filter(m => m.show).map(({ label, icon, url, showModal }) => {
                        const content = (
                            <div className="tooltip-container" style={{ fontSize: "1.75rem", cursor: "pointer" }}>
                                {icon}
                                <span className="tooltip-text tooltip-right">{label}</span>
                            </div>
                        );

                        if (showModal) {
                            return (
                                <button
                                    key={label}
                                    onClick={() => showModal(true)}
                                    style={{ background: "none", border: "none", color: 'var(--pico-primary)', padding: '0' }}
                                >
                                    {content}
                                </button>
                            );
                        } else {
                            return (
                                <Link
                                    key={label}
                                    href={url}
                                    style={{ display: "flex", justifyContent: "center", alignItems: "center", color: 'var(--pico-primary)' }}
                                >
                                    {content}
                                </Link>
                            );
                        }
                    })}

                    {/* Logout/Login */}
                    <div style={{ position: 'fixed', bottom: "0", marginBottom: "1rem" }}>
                        <div className="tooltip-container" style={{ cursor: "pointer" }}>
                            <button
                                onClick={session ? () => handleLogout(storage, router) : goToLogin}
                                style={{ background: "none", border: "none", fontSize: "1.75rem", color: 'var(--primary-red)' }}
                            >
                                {session ? <FaPowerOff /> : <FaBars />}
                            </button>
                            <span className="tooltip-text tooltip-right">{session ? "Cerrar sesión" : "Iniciar sesión"}</span>
                        </div>
                    </div>
                </aside>
            )}
        </>
    );
}
 
----- Archivo: addItem.tsx ----- 
// src/components/lib/addItem.tsx
"use client"
import { tooltipStyles } from "@/styles/tooltip";
import { FaInfoCircle } from "react-icons/fa";
interface AddItemProps {
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
    count: number;
}

export default function AddItemComponent({ entityName, loadLoading, handleAdd, count }: AddItemProps) {
    return (
        <>
            <style jsx global>{`
        ${tooltipStyles}

        /* Override específico para tooltip de advertencia */
        .tooltip-container.tooltip-warning .tooltip-text {
          background-color: var(--primary-lightyellow) !important;  /* amarillo pálido */
          color: var(--primary-yellow) !important;            /* texto oscuro */
          border-color: var(--primary-yellow) !important;      /* borde amarillo */

          /* Posicionar a la derecha del icono */
          top: 50%;
          left: 120%;
          right: auto;
          bottom: auto;
          transform: translateY(-50%);   
          
        }
        .tooltip-container>svg {    
            font-size: 33px;
            color: var(--primary-yellow);
            margin-left: 10px;
        }
      `}</style>
            <div className="flex items-center flex-wrap gap-2">
                <button
                    type="button"
                    onClick={handleAdd}
                    className="contrast"
                    disabled={loadLoading}
                >
                    Agregar {count == 0 ? '' : 'otra '} {entityName}
                </button>

                {count === 0 && (
                    <span className="tooltip-container tooltip-warning">
                        <FaInfoCircle className="ml-1 text-yellow-600" />
                        <span className="tooltip-text">
                            Puedes añadir estos datos más tarde
                        </span>
                    </span>
                )}
            </div>
        </>
    );
} 
----- Archivo: basicField.tsx ----- 
// src/components/lib/basicField.tsx
import { FieldType } from "@/types/lib";

interface BasicFieldProps {
    item: FieldType
}

export default function BasicFieldComponent(props: BasicFieldProps) {
    if (!props.item.show) {
        return <div></div>;
    }
    return (
        <div key={props.item.label} style={{ backgroundColor: "var(--primary-inverse)", padding: "1rem", borderRadius: "0.5rem", boxShadow: "0 2px 8px var(--primary-lighttransparent)" }}>
            <p style={{ fontSize: "0.75rem", color: "var(--primary-darkgray)", margin: 0 }}>{props.item.label}</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}>{props.item.value}</p>
        </div>
    );
}
 
----- Archivo: circularImage.tsx ----- 
// src/components/lib/circularImage.tsx
"use client"
import React, { useState } from 'react';
import Image from 'next/image';

// Componente reutilizable para avatar circular
interface CircularImageProps {
    src: string;
    width: number;
    borderSize?: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getRootProps?: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInputProps?: any;
    onClick?: () => void;
    overlayText?: string;
    hoverEnabled?: boolean;
}

export default function CircularImageComponent({ src, width, borderSize = '5px', getRootProps, getInputProps, onClick, overlayText, hoverEnabled = false }: CircularImageProps) {
    const [hover, setHover] = useState(false);
    if (!hoverEnabled) {
        return (
            <div style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: `${borderSize} solid var(--pico-primary)`,
                cursor: 'pointer'
            }}
            >
                <Image
                    loading={"lazy"}
                    src={src}
                    alt="Foto de la mascota" fill
                    style={{ objectFit: 'cover' }} />
            </div>
        );
    }
    return (
        <div
            {...getRootProps()}
            onClick={onClick}
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
            style={{
                position: 'relative',
                width: width,
                height: width,
                borderRadius: '50%',
                overflow: 'hidden',
                border: '5px solid var(--pico-primary)',
                cursor: 'pointer'
            }}
        >
            <input {...getInputProps()} />
            <Image
                loading={"lazy"}
                src={src}
                alt="Foto de la mascota" fill
                style={{ objectFit: 'cover' }} />
            {hover && overlayText && (
                <div
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'var(--primary--graytransparent)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        borderRadius: '50%'
                    }}
                >
                    <span style={{ fontWeight: 'bold', color: 'var(--primary-darkgray)', textAlign: 'center' }}>
                        {overlayText}
                    </span>
                </div>
            )}
        </div>
    );
} 
----- Archivo: dataNotFound.tsx ----- 
// src/components/DataNotFound.tsx
import React from "react";
import { FaInbox } from "react-icons/fa";

interface DataNotFoundProps {
  message: string;
}

export default function DataNotFoundComponent({ message }: DataNotFoundProps) {
  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: "2rem",
        backgroundColor: "var(--pico--primary)",
        borderRadius: "0.5rem",
        color: "var(--primary-lightgray)",
        textAlign: "center",
        maxWidth: "400px",
        margin: "2rem auto",
        boxShadow: "0 2px 8px var(--primary-lighttransparent)",
      }}
    >
      <FaInbox
        size={48}
        style={{ marginBottom: "1rem", color: "var(--primary-skin)" }}
      />
      <p style={{ fontSize: "1.25rem", lineHeight: "1.5" }}>
        {message}
      </p>
    </div>
  );
}
 
----- Archivo: display.tsx ----- 
// src/components/lib/display.tsx
import { FieldType, FormType as DisplayType } from "@/types/lib";
import { Field } from "@/components/index";
import { v4 } from "uuid";

interface DisplayProps {
    formItems: DisplayType[];
    isMobile: boolean;
}

export default function DisplayComponent(props: DisplayProps) {
    return (
        <div style={{ display: "grid", gridTemplateColumns: props.isMobile ? "1fr" : "repeat(2, 1fr)", gap: "1rem" }}>
            {props.formItems.map((item) => (
                <div key={item.id} style={{ backgroundColor: "transparent", padding: "0.1rem", borderRadius: "0.5rem", borderColor: 'var(--pico-contrast)', borderWidth: '1px', border: 'groove', boxShadow: "0 2px 8px var(--primary-lighttransparent)" }}>
                    {item.fields.map((field: FieldType) =>
                        <Field key={v4()} field={field} />
                    )}
                </div>
            ))}
        </div>
    );
} 
----- Archivo: entities.tsx ----- 
// src/components/entities.tsx
"use client";

import React from "react";
import { AddItem, Entity } from "@/components/index";

interface EntitiesProps {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    form: (item: any, id: number) => React.JSX.Element;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    entityList: any[];
    entityName: string;
    loadLoading: boolean;
    handleAdd: () => void;
}
export default function EntitiesComponent({ form, entityList, entityName, loadLoading, handleAdd }: EntitiesProps) {

    return (
        <div className="grid grid-cols-1 gap-6" style={{ display: 'flow' }}>
            {entityList.map((item, i: number) => (
                <Entity key={i.toString()} index={i} entityName={entityName} >
                    {form(item, i)}
                </Entity>
            ))}

            <AddItem entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} count={entityList.length} />
        </div>
    );
}
 
----- Archivo: entity.tsx ----- 
// src/components/lib/entity.tsx
"use client";

import { Strings } from "@/utils/index";
import React from "react";

interface EntityProps {
    key: string;
    children: React.ReactNode;
    entityName: string;
    index: number;
}

export default function EntityComponent({ children, index, entityName }: EntityProps) {
    

    return (
        <fieldset
            key={index}
            className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 border rounded"
            style={{ display: 'flex', border: '1px solid var(--pico-primary)', borderRadius: '10px', padding: '1rem' }} >
            <legend className="text-lg font-semibold" >
                <b style={{paddingLeft: '1rem', paddingRight: '1rem'}}>{Strings.titleCase(entityName)} #{index + 1}</b>
            </legend>
            {children}
        </fieldset>
    );
}
 
----- Archivo: entityFields.tsx ----- 
// src/components/lib/entityFields.tsx
"use client";

import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { FieldConfig } from "@/types/lib";
import { Dates } from "@/utils/index";
import React from "react";
import RemoveItemComponent from "./removeItem";


interface EntityFieldsProps<T extends { id: string | undefined }> {
    fieldsConfig: FieldConfig<T>[];
    item: T;
    index: number;
    loadLoading: boolean;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateItem: (index: number, field: keyof T, value: any) => void;
    handleRemove: (id: string | undefined) => void;
}

export default function EntityFieldsComponent<T extends { id: string | undefined }>({
    fieldsConfig,
    item,
    index,
    loadLoading,
    updateItem,
    handleRemove
}: EntityFieldsProps<T>) {

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const setValue = (type: 'text' | 'date', item: any, name: string | number | symbol): string | number | readonly string[] | undefined => {
        if (type == 'date') {
            return item[name] ? Dates.format(item[name]) : ''
        }
        return item[name] ?? "";
    }

    const { isMobile } = useDeviceDetect();

    const gridTemplateColumnsCalculateDesktopOrTablet = (count: number) => {
        switch (count) {
            case 5: return "repeat(3, 1fr)";
            case 4: return "repeat(3, 1fr)";
            case 3: return "repeat(4, 1fr)";
            case 2:
            default: return "repeat(3, 1fr)";
        }
    }

    // Estilo común de grid: en móvil siempre 2 columnas, en desktop auto-ajusta
    const sectionGridStyle: React.CSSProperties = {
        display: "grid",
        gap: "1rem",
        gridTemplateColumns: isMobile
            ? "repeat(2, 1fr)"
            : gridTemplateColumnsCalculateDesktopOrTablet(fieldsConfig.length)
    };

    return (
        <div style={sectionGridStyle}>
            {fieldsConfig.map(({ label, name, type, mandatory, className }) => (
                <label key={`${String(name)}-${index}`} className={className}>
                    {label}
                    <input
                        type={type}
                        value={setValue(type, item, name)}
                        disabled={loadLoading}
                        onChange={(e) =>
                            updateItem(
                                index,
                                name,
                                type === "date"
                                    ? (e.target as HTMLInputElement).valueAsDate
                                    : (e.target as HTMLInputElement).value
                            )
                        }
                        required={mandatory}
                        className="w-full"
                    />
                </label>
            ))}
            <RemoveItemComponent id={item.id} loadLoading={loadLoading} handleRemove={handleRemove} />
        </div>
    );
}
 
----- Archivo: entityForm.tsx ----- 
// src/components/entityForm.tsx
"use client";

import React from "react";
import type { Dispatch, SetStateAction } from "react";
import { EntityFields, Form } from "@/components/index";
import { useLoadEntities } from "@/hooks/useLoadEntities";
import { useEntityList } from "@/hooks/useEntityList";
import { useEntitySubmit } from "@/hooks/useEntitySubmit";
import type { FieldConfig, StepsStateType } from "@/types/lib";

export interface EntityFormProps<T extends { id?: string }> {
  id: string;
  storedList: T[];
  setStoredList: (list: T[] | null) => void;
  data: T[];
  setData: Dispatch<SetStateAction<T[]>>;
  step: number;
  stepStates: StepsStateType[];
  setStepStates: Dispatch<SetStateAction<StepsStateType[]>>;
  entityName: string;
  emptyFactory: (id: string) => Partial<T>;
  fieldsConfig: FieldConfig<T>[];
  onNext: () => void;
  onBack: () => void;
  setShowModal: Dispatch<React.SetStateAction<boolean>>;
}

export default function EntityFormComponent<T extends { id: string | undefined }>({
  id,
  storedList,
  setStoredList,
  data,
  setData,
  step,
  stepStates,
  setStepStates,
  entityName,
  emptyFactory,
  fieldsConfig,
  onNext,
  onBack,
  setShowModal
}: EntityFormProps<T>) {
  // 1) Carga los datos guardados
  const {
    list,
    setList,
    error: loadError,
    setError: setLoadError,
    loading: loadLoading,
  } = useLoadEntities<T>(
    id,
    entityName,
    storedList,
    setStoredList,
    data,
    setData,
    step,
    stepStates,
    setStepStates
  );

  // 2) Gestión de la lista en memoria (añadir, eliminar, editar)
  const { addItem, removeItem, updateItem } = useEntityList<T>(
    emptyFactory,
    id,
    setList,
    setLoadError,
    step,
    stepStates
  );

  // 3) Envío y validación
  const {
    submit,
    loading: submitLoading,
    error: submitError,
  } = useEntitySubmit<T>(
    id,
    list,
    entityName,
    setStoredList,
    setData,
    fieldsConfig,
    step,
    stepStates,
    setStepStates,
    loadError,
    setLoadError
  );

  // 4) Renderizado de campos dinámicos
  const renderFields = (item: T, index: number) => (
    <EntityFields<T>
      fieldsConfig={fieldsConfig}
      item={item}
      index={index}
      loadLoading={loadLoading}
      updateItem={updateItem}
      handleRemove={removeItem}
    />
  );

  return (
    <Form<T>
      entityList={list}
      step={step}
      totalSteps={stepStates.length}
      entityName={entityName}
      submitLoading={submitLoading}
      loadLoading={loadLoading}
      error={loadError || submitError}
      form={renderFields}
      onBack={onBack}
      handleAdd={addItem}
      handleSubmit={() => submit(onNext)}
      setShowModal={setShowModal}
    />
  );
}
 
----- Archivo: featureLink.tsx ----- 
// src/components/lib/featureLink.tsx
import Link from "next/link";
import React from "react";
import { FaCheckCircle } from "react-icons/fa";

interface FeatureLinkProps {
  icon: React.ReactNode;
  href: string;
  title: string;
  desc: string;
  click?: () => void;
  isComplete?: boolean;
}

export default function FeatureLink({ icon, href, title, desc, click, isComplete = false }: FeatureLinkProps) {
  return (
    <li style={{ marginBottom: "1.2rem", position: 'relative' }}>
      <Link
        href={click ? '' : href}
        className="contrast"
        onClick={click}
        style={{
          display: "flex",
          alignItems: "center",
          gap: "1rem",
          textDecoration: "none",
          padding: "1rem",
          borderRadius: "0.75rem",
          background: "var(--primary-inverse)",
          boxShadow: "0 1px 6px var(--primary-lighttransparent)",
          transition: "background 0.2s",
          borderLeft: isComplete ? '5px solid var(--primary-green)' : '5px solid transparent'
        }}
      >
        {isComplete && (
          <FaCheckCircle style={{ color: 'var(--primary-green)', position: 'absolute', top: '0.5rem', right: '0.5rem' }} />
        )}
        <span style={{ fontSize: 28, minWidth: 40 }}>{icon}</span>
        <span>
          <strong>{title}</strong>
          <br />
          <span style={{ fontSize: "0.98rem", color: "var(--primary-darkgray)" }}>{desc}</span>
        </span>
      </Link>
    </li>
  );
} 
----- Archivo: field.tsx ----- 
// src/components/lib/field.tsx
import { FieldType } from "@/types/lib";
import React from "react";

interface FieldsProps {
    field: FieldType;
} 

export default function FieldComponent(props: FieldsProps) {
    if (!props.field.show) {
        return <div></div>;
    }
    return (
        <div key={props.field.label} style={{ backgroundColor: "var(--primary-inverse)", padding: "1rem", margin: '0.5rem', borderRadius: "0.5rem", boxShadow: "0 2px 8px var(--primary-lighttransparent)" }}>
            <p style={{ fontSize: "0.75rem", color: "var(--primary-lightgray)", margin: 0 }}>{props.field.label}:</p>
            <p style={{ fontSize: "1rem", margin: "0.25rem 0 0 0" }}> {props.field.value}</p>
        </div>
    );
} 
----- Archivo: form.tsx ----- 
// src/components/form.tsx
"use client";
import React from "react";
import StepsComponent from "./steps";
import EntitiesComponent from "@/components/lib/entities";

interface FormProps<T extends { id: string | undefined }> {
    entityList: Partial<T>[];
    step: number;
    totalSteps: number;
    entityName: string;
    submitLoading: boolean;
    loadLoading: boolean;
    error: string | null;
    form: (entity: T, i: number) => React.JSX.Element
    onBack: () => void;
    handleAdd: () => void;
    handleSubmit: () => Promise<void>;
    setShowModal: React.Dispatch<React.SetStateAction<boolean>>;
}

export default function FormComponent<T extends { id: string | undefined }>({ entityList, step, totalSteps, entityName, submitLoading, loadLoading, error, form, onBack, handleAdd, handleSubmit, setShowModal }: FormProps<T>) {
    return (
        <StepsComponent onBack={onBack} onNext={handleSubmit} submitLoading={submitLoading} loadLoading={loadLoading} step={step} totalSteps={totalSteps} error={error} setShowModal={setShowModal}>
            <EntitiesComponent form={form} entityList={entityList} entityName={entityName} loadLoading={loadLoading} handleAdd={handleAdd} />
        </StepsComponent >
    );
}
 
----- Archivo: loading.tsx ----- 
// src/components/lib/loading.tsx
"use client";
import React from "react";
import { FaSpinner } from "react-icons/fa";

export default function LoadingComponent() {
  return (
    <div className="loading-container">
      <FaSpinner
        size={48}
        style={{
          color: "var(--pico-primary)",
          marginBottom: "1rem",
          animation: "spin 1s linear infinite"
        }}
      />
      <p>Cargando...</p>
      <style jsx>{`
        .loading-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          padding: 2rem;
          color: var(--primary-lightgray);
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to   { transform: rotate(360deg); }
        }
        p {
          font-size: 1rem;
        }
      `}</style>
    </div>
  );
}
 
----- Archivo: modal.tsx ----- 
// app/components/lib/modal.tsx
"use client";
import React, { Dispatch, SetStateAction } from "react";
import { FaTimes } from "react-icons/fa";

interface ModalProps {
    children: React.ReactNode;
    title: string;
    description?: string;
    setShowModal: Dispatch<SetStateAction<boolean>>;
    maxWidth?: string;
    dropdownRef?: React.RefObject<HTMLDivElement | null>;
    hideClose?: boolean;
}

export default function ModalComponent({ children, title, description, setShowModal, maxWidth = "450px", dropdownRef, hideClose = false }: ModalProps) {
    return (
        <div
            style={{
                position: "fixed",
                inset: 0,
                backgroundColor: "var(--primary-darkertransparent)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 2000,
            }}
        >

            <div
                ref={dropdownRef}
                style={{
                    backgroundColor: "var(--primary-inverse)",
                    borderRadius: "1rem",
                    padding: "2rem",
                    width: "90%",
                    maxWidth: maxWidth,
                    position: "relative",
                }}
            >

                {/* Close button */}
                {!hideClose &&
                    <button
                        onClick={() => setShowModal(false)}
                        style={{
                            position: "absolute",
                            top: "0.5rem",
                            right: "0.5rem",
                            background: "none",
                            border: "none",
                            fontSize: "1rem",
                            cursor: "pointer",
                            color: 'var(--pico-contrast)'
                        }}
                        aria-label="Cerrar modal"
                    >
                        <FaTimes />
                    </button>
                }
                <h2 className="modal-title">{title}</h2>
                <p className="description">{description}</p>
                {children}
            </div>
        </div >
    );
}
 
----- Archivo: page.tsx ----- 
// src/components/page.tsx
"use client";
import React, { useEffect, useState } from "react";
import { v4 } from "uuid";
import { Loading, DataNotFound, Display, Title } from "@/components/index";
import { ApiError, FormType } from "@/types/lib";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { useSession } from "@/hooks/useSession";
import { getFetch } from "@/app/api";

export interface PageProps<T> {
    parentId: string,
    title: string;
    icon: React.JSX.Element;
    apiUrl: string;
    storedList: T[];
    setStoredList: (value: T[]) => void;
    /** Mapea cada ítem a un array de campos para Display */
    mapItemToFields: (item: T) => { label: string; show: boolean; value: string }[];
    emptyMessage: string;
}

const PageComponent = <T,>({
    parentId,
    title,
    icon,
    apiUrl,
    storedList,
    setStoredList,
    mapItemToFields,
    emptyMessage,
}: PageProps<T>) => {
    useSession();
    const { isMobile } = useDeviceDetect();
    const [items, setItems] = useState<T[] | null>(null);

    useEffect(() => {
        if (!parentId) return;
        const fetchData = async () => {
            try {
                let data: T[] = [];
                if (storedList == null) {
                    const response = await getFetch(`${apiUrl}${parentId}`);
                    if (!response.ok) throw new ApiError(`Error llamando al api: ${apiUrl}${parentId}`);
                    const data = await response.json();
                    setItems(data);
                    setStoredList(data);
                }
                else {
                    data = storedList;
                    setItems(data);
                }
            } catch (err) {
                console.error(`Error cargando ${title.toLowerCase()}:`, err);
            }
        };
        fetchData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storedList]);

    const formItems: FormType[] = (items || []).map((item) => ({
        id: v4(),
        fields: mapItemToFields(item),
    }));

    return (
        <main style={{ padding: isMobile ? "2rem 1rem" : "2rem" }}>
            <Title icon={icon} title={title} />
            {items === null ? (
                <Loading />
            ) : items.length === 0 ? (
                <DataNotFound message={emptyMessage} />
            ) : (
                <Display formItems={formItems} isMobile={isMobile} />
            )}
        </main>
    );
};

export default PageComponent;
 
----- Archivo: removeItem.tsx ----- 
// app/components/lib/removeItem.tsx
import { FaTrash } from "react-icons/fa";

interface RemoveItemProps {
    id: string | undefined;
    loadLoading: boolean;
    handleRemove: (id: string | undefined) => void;
}

export default function RemoveItemComponent({ id, loadLoading, handleRemove }: RemoveItemProps) {
    return (
        <div className="flex flex-wrap gap-2" style={{ marginTop: '26px', alignContent: 'center' }}>
            <button
                type="button"
                onClick={() => handleRemove(id)}
                className="contrast"
                disabled={loadLoading}
            >
                <FaTrash />
            </button>
        </div>
    );
} 
----- Archivo: steps.tsx ----- 
// src/components/lib/steps.tsx
import React from 'react';

interface StepsProps {
  children: React.ReactNode;
  step: number;
  totalSteps: number;
  submitLoading: boolean;
  loadLoading: boolean;
  error: string | null;
  onNext: () => void;
  onBack: () => void;
  setShowModal: React.Dispatch<React.SetStateAction<boolean>>;
}

export default function StepsComponent({ children, submitLoading, loadLoading, step, totalSteps, error, onNext, onBack/*, setShowModal*/ }: StepsProps) {

  return (
    <>
      <div className="space-y-4">
        <div style={{ maxHeight: '500px', overflowY: 'auto', padding: '1rem', marginBottom: '1rem' }}>
          {children}
        </div>
        {error && (
          <p style={{ color: "var(--primary-red)" }}>
            {error}
          </p>
        )}
        <div className="mt-4 flex justify-between">
          {step > 0 && (
            <button
              type="button"
              onClick={onBack}
              className="btn-secondary ml-auto"
              style={{ float: 'left' }}
            >
              Atrás
            </button>
          )}
          <button
            type="button"
            onClick={onNext}
            disabled={submitLoading || loadLoading}
            className="btn-primary"
            style={{ float: 'right' }}
          >
            {submitLoading ? "Guardando…" : (totalSteps - 1 == step ? "Finalizar" : "Siguiente")}
          </button>
        </div>
      </div>
    </>
  );
}
 
----- Archivo: title.tsx ----- 
// src/components/lib/title.tsx
interface TitleProps {
    icon: React.JSX.Element;
    title: string;
}

export default function TitleComponent(props: TitleProps) {
    return (
        <h3 style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            {props.icon} {props.title}
        </h3>
    );
} 
----- Archivo: AddPetModal.tsx ----- 
// src/components/modals/AddPetModal.tsx
"use client";

import React, { useState, Dispatch, SetStateAction, useEffect } from "react";
import ModalComponent from "../lib/modal";
import { EntityForm } from "@/components/index";

import { PetNameForm, BasicDataForm } from "@/components/forms";

import {
    emptyVaccine,
    emptyMedicine,
    emptyLabTest,
    emptyCondition,
    emptySurgery,
} from "@/utils/factories";

import {
    PetStep,
    PetType,
    BasicDataType,
    VaccineDataType,
    MedicineDataType,
    LabTestDataType,
    ConditionDataType,
    SurgeryDataType
} from "@/types/index";

import type { StepsStateType, StepConfig } from "@/types/lib";
import { Empty } from "@/data/index";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";

interface AddPetModalProps {
    editPet?: PetType
}

export default function AddPetModal({ editPet }: AddPetModalProps) {
    const session = useSessionContext();
    const storage = useStorageContext();
    const [step, setStep] = useState<PetStep>(PetStep.Name);
    const { showAddPetModal, setShowAddPetModal, setShowEditPetModal } = useUI();

    // Estados por entidad
    const [pet, setPet] = useState<PetType>(editPet == undefined ? Empty.Pet() : editPet);
    const [basicData, setBasicData] = useState<BasicDataType>(Empty.BasicData());
    const [vaccinesData, setVaccinesData] = useState<VaccineDataType[]>([]);
    const [medicinesData, setMedicinesData] = useState<MedicineDataType[]>([]);
    const [labTestsData, setLabTestsData] = useState<LabTestDataType[]>([]);
    const [conditionsData, setConditionsData] = useState<ConditionDataType[]>([]);
    const [surgeriesData, setSurgeriesData] = useState<SurgeryDataType[]>([]);
    const [stepStates, setStepStates] = useState<StepsStateType[]>(Empty.Steps());


    useEffect(() => {
        setStepStates(Empty.Steps());
    }, [showAddPetModal])

    // Validar sesión
    if (!session?.db?.user?.id) return null;
    const ownerId = session.db.user.id;

    const totalSteps = 7;
    const next = () => setStep(s => Math.min(s + 1, totalSteps - 1));
    const back = () => setStep(s => Math.max(s - 1, 0));
    const finalize = () => {
        if (!pet.id) return;
        pet.owner_id = ownerId;
        storage.setStoredOwnerPets([...(storage.storedOwnerPets ?? []), pet]);
        setShowAddPetModal(false);
        setShowEditPetModal(false);
        setStepStates(Empty.Steps());
    };

    // Configuración dinámica para los pasos que usan EntityForm
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const stepConfigs: Partial<Record<PetStep, StepConfig<any>>> = {
        [PetStep.Vaccines]: {
            entityName: "vacuna",
            storedList: storage.storedVaccineData,
            setStoredList: storage.setStoredVaccineData,
            emptyFactory: emptyVaccine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Lote *", name: "batch", type: "text", mandatory: true, className: "w-full" },
                { label: "Marca *", name: "brand", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Medicines]: {
            entityName: "medicina",
            storedList: storage.storedMedicineData,
            setStoredList: storage.setStoredMedicineData,
            emptyFactory: emptyMedicine,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Dosis *", name: "dosage", type: "text", mandatory: true, className: "w-full" },
                { label: "Frecuencia *", name: "frequency", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.LabTests]: {
            entityName: "prueba",
            storedList: storage.storedLabTestData,
            setStoredList: storage.setStoredLabTestData,
            emptyFactory: emptyLabTest,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Tipo *", name: "type", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Resultado", name: "result", type: "text", className: "w-full" },
            ],
        },
        [PetStep.Conditions]: {
            entityName: "condición",
            storedList: storage.storedConditionData,
            setStoredList: storage.setStoredConditionData,
            emptyFactory: emptyCondition,
            fieldsConfig: [
                { label: "Condición *", name: "condition", type: "text", mandatory: true, className: "w-full" },
                { label: "Severidad *", name: "severity", type: "text", mandatory: true, className: "w-full" },
            ],
        },
        [PetStep.Surgeries]: {
            entityName: "cirugía",
            storedList: storage.storedSurgeryData,
            setStoredList: storage.setStoredSurgeryData,
            emptyFactory: emptySurgery,
            fieldsConfig: [
                { label: "Nombre *", name: "name", type: "text", mandatory: true, className: "w-full" },
                { label: "Fecha", name: "date", type: "date", className: "w-full" },
                { label: "Descripción", name: "description", type: "text", className: "w-full" },
            ],
        },
    };

    // Mapeo de datos y setters por paso
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dataMap: Partial<Record<PetStep, [any[], Dispatch<SetStateAction<any[]>>]>> = {
        [PetStep.Vaccines]: [vaccinesData, setVaccinesData],
        [PetStep.Medicines]: [medicinesData, setMedicinesData],
        [PetStep.LabTests]: [labTestsData, setLabTestsData],
        [PetStep.Conditions]: [conditionsData, setConditionsData],
        [PetStep.Surgeries]: [surgeriesData, setSurgeriesData],
    };

    const renderStep = () => {
        switch (step) {
            case PetStep.Name:
                return (
                    <PetNameForm
                        ownerId={ownerId}
                        pet={pet}
                        setPet={setPet}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                        setShowModal={editPet == undefined ? setShowAddPetModal : setShowEditPetModal}
                    />
                );

            case PetStep.BasicData:
                return (
                    <BasicDataForm
                        pet={pet}
                        basicData={basicData}
                        setBasicData={setBasicData}
                        onNext={next}
                        onBack={back}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                        setShowModal={editPet == undefined ? setShowAddPetModal : setShowEditPetModal}
                    />
                );

            default: {
                // TS: usamos Partial y ! para asegurar que cfg y data existen
                const cfg = stepConfigs[step]!;
                const [items, setItems] = dataMap[step]!;

                return (
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    <EntityForm<any>
                        key={step}
                        id={pet.id!}
                        storedList={cfg.storedList}
                        setStoredList={cfg.setStoredList}
                        data={items}
                        setData={setItems}
                        step={step}
                        stepStates={stepStates}
                        setStepStates={setStepStates}
                        entityName={cfg.entityName}
                        emptyFactory={cfg.emptyFactory}
                        fieldsConfig={cfg.fieldsConfig}
                        onNext={step === PetStep.Surgeries ? finalize : next}
                        onBack={back}
                        setShowModal={editPet == undefined ? setShowAddPetModal : setShowEditPetModal}
                    />
                );
            }
        }
    };

    const stepTitle = () => {
        const titles: Record<PetStep, string> = {
            [PetStep.Name]: "Agrega tu mascota",
            [PetStep.BasicData]: `Datos básicos de ${pet.name}`,
            [PetStep.Vaccines]: `Información de vacunas de ${pet.name}`,
            [PetStep.Medicines]: `Información de medicamentos de ${pet.name}`,
            [PetStep.LabTests]: `Información de exámenes de ${pet.name}`,
            [PetStep.Conditions]: `Información de condiciones especiales de ${pet.name}`,
            [PetStep.Surgeries]: `Información de cirugías de ${pet.name}`,
        };
        return titles[step] || "";
    };

    return (
        <ModalComponent title={stepTitle()} setShowModal={editPet == undefined ? setShowAddPetModal : setShowEditPetModal} maxWidth="1000px">
            {renderStep()}
        </ModalComponent>
    );
}
 
----- Archivo: AlertModal.tsx ----- 
// src/components/modals/AlertModal.tsx
import React from "react";
import ModalComponent from "../lib/modal";
import { FaExclamationTriangle, FaInfoCircle } from "react-icons/fa";

interface AlertModalProps {
    title: string;
    message: string;
    type: 'warning' | 'info';
    onClose: () => void;
}

export default function AlertModal({ title, message, type, onClose }: AlertModalProps) {
    const icon = type === 'warning'
        ? <FaExclamationTriangle size={32} style={{ color: 'var(--primary-yellow)', flexShrink: 0 }} />
        : <FaInfoCircle size={32} style={{ color: 'var(--pico-primary)', flexShrink: 0 }} />;

    return (
        <ModalComponent setShowModal={() => onClose()} title="">
            <div style={{ display: 'flex', gap: '1rem', alignItems: 'flex-start' }}>
                {icon}
                <div>
                    <h2 className="modal-title" style={{ marginTop: 0 }}>{title}</h2>
                    <p className="modal-description">{message}</p>
                </div>
            </div>
            <button onClick={onClose} style={{ width: '100%', marginTop: '1rem' }}>
                Entendido
            </button>
        </ModalComponent>
    );
} 
----- Archivo: Bubbles.tsx ----- 
// app/components/modals/Bubbles.tsx
"use client"
import React, { useEffect, useState } from "react";
import { FaShareAlt, FaCommentDots, FaUserMd, FaExchangeAlt, FaUserPlus } from "react-icons/fa";
import FeedbackModal from "./FeedbackModal";
import PetCodeModal from "./PetCodeModal";
import VeterinaryModal from "./VeterinaryModal";
import ChangePetModal from "./ChangePetModal";
import AddPetModal from "./AddPetModal";
import { useUI } from "@/context/UIProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useRoleContext } from "@/context/RoleProvider";
import VeterinarianPetCodeModal from "./VeterinarianPetCodeModal";
import PlanSelectModal from "./PlanSelectModal";
import InviteUserModal from "./InviteUserModal";
import MissingPetModal from "./MissingPet";

const bubbleStyleBase: React.CSSProperties = {
  backgroundColor: "var(--primary-inverse)",
  border: "1px solid var(--pico-primary)",
  borderRadius: "50%",
  width: "3rem",
  height: "3rem",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  color: "var(--pico-primary)",
  fontSize: "1.25rem",
  cursor: "pointer",
};

export default function Bubbles() {

  const [showChangePetBubble, setShowChangePetBubble] = useState(false);
  const { isOwner, isVet } = useRoleContext();


  const storage = useStorageContext();

  const { setShowFeedbackModal,
    showFeedbackModal,
    setShowVetModal,
    showVetModal,
    setShowCodeModal,
    showCodeModal,
    setShowChangePetModal,
    showChangePetModal,
    showAddPetModal,
    showEditPetModal,
    setShowVetPetCodeModal,
    showVetPetCodeModal,
    showPlanModal,
    showInviteUserModal,
    setShowInviteUserModal,
    showMissingPetModal
  } = useUI();

  useEffect(() => {
    const show = (storage.storedOwnerPets.length ?? 0) > 0;
    setShowChangePetBubble(show);
  }, [storage.storedOwnerPets]);

  return (
    <div
      style={{
        position: "fixed",
        right: "1rem",
        bottom: "1rem",
        display: "flex",
        flexDirection: "column",
        gap: "1rem",
        zIndex: 1500,
      }}
    >
      {/* Feedback Bubble */}
      <div className="tooltip-container" draggable>
        <button
          onClick={() => setShowFeedbackModal(true)}
          style={bubbleStyleBase}
          aria-label="Feedback"
        >
          <FaCommentDots />
        </button>
        <span className="tooltip-text tooltip-left">Enviar feedback</span>
      </div>

      {/* //TODO: create admin user, and enable other users to invite another users.*/ }
      {showInviteUserModal &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowInviteUserModal(true)}
            style={bubbleStyleBase}
            aria-label="Invita a un amigo"
          >
            <FaUserPlus />
          </button>
          <span className="tooltip-text tooltip-left">Invita a un amigo</span>
        </div>
      }

      {/* Vet Bubble */}
      {isOwner && !isVet && storage.storedPet.id &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Soy médico veterinario</span>
        </div>
      }

      {/* Vet Bubble */}
      {isVet &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowVetPetCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Veterinario"
          >
            <FaUserMd />
          </button>
          <span className="tooltip-text tooltip-left">Ingresar código de una mascota</span>
        </div>
      }

      {/* Code Bubble */}
      {isOwner && !isVet && storage.storedPet.id &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowCodeModal(true)}
            style={bubbleStyleBase}
            aria-label="Código único"
          >
            <FaShareAlt />
          </button>
          <span className="tooltip-text tooltip-left">Genera un código único para tu veterinario</span>
        </div>
      }

      {/* Change Pet Bubble */}
      {showChangePetBubble &&
        <div className="tooltip-container" draggable>
          <button
            onClick={() => setShowChangePetModal(true)}
            style={bubbleStyleBase}
            aria-label="Cambia de mascota"
          >
            <FaExchangeAlt />
          </button>
          <span className="tooltip-text tooltip-left">Cambia de mascota</span>
        </div>
      }

      {/* Modals */}
      {showChangePetModal && <ChangePetModal />}
      {showVetModal && <VeterinaryModal setShowModal={setShowVetModal}/>}
      {showCodeModal && <PetCodeModal />}
      {showFeedbackModal && <FeedbackModal />}
      {showAddPetModal && <AddPetModal />}
      {showEditPetModal && <AddPetModal editPet={storage.storedPet} />}
      {showVetPetCodeModal && <VeterinarianPetCodeModal />}
      {showPlanModal && <PlanSelectModal />}
      {showInviteUserModal && <InviteUserModal />}
      {showMissingPetModal && <MissingPetModal />}
    </div>
  );
}
 
----- Archivo: ChangePetModal.tsx ----- 
// app/components/modals/ChangePetModal.tsx
"use client";
import React, {
  useState,
  useRef,
  useEffect,
} from "react";
import { FaChevronDown, FaChevronUp, FaPlus } from "react-icons/fa";
import { PetType } from "@/types/index";
import ModalComponent from "../lib/modal";
import { Empty } from "@/data/index";
import { CircularImage } from "@/components/index"
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";

export default function ChangePetModal() {
  const storage = useStorageContext();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { setShowChangePetModal, setShowAddPetModal } = useUI();

  // close dropdown if you click outside
  useEffect(() => {
    const handleClickOutside = (ev: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(ev.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () =>
      document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleSelect = (pet: PetType) => {
    storage.resetPet();
    storage.setStoredPet(pet);
    setIsOpen(false);
    setShowChangePetModal(false);
    storage.setStoredVetAccess(Empty.VetAccess());
  };

  const addPet = () => {
    setShowChangePetModal(false);
    setShowAddPetModal(true);
  };

  return (
    <ModalComponent title="Selecciona la mascota" description="Visualiza la información de la mascota seleccionada" setShowModal={setShowChangePetModal} dropdownRef={dropdownRef}>
      {/* Custom dropdown */}
      <div style={{ position: "relative", marginTop: "1rem" }}>
        <button
          type="button"
          onClick={() => setIsOpen((o) => !o)}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "0.5rem 1rem",
            borderRadius: "0.5rem",
            border: "1px solid var(--primary-lightgray)",
            background: "var(--primary-inverse)",
          }}
        >
          <div style={{ display: "flex", alignItems: "center" }}>
            <CircularImage
              src={storage.storedPet.image || "/pets/pet.jpg"}
              width={60}
              borderSize="3px" />
            <span style={{ color: 'var(--pico-contrast)', marginLeft: '10px' }}>
              {storage.storedPet.name ?? "Selecciona una mascota"}
            </span>
          </div>
          {isOpen ? <FaChevronUp /> : <FaChevronDown />}
        </button>

        {isOpen && (
          <ul
            style={{
              position: "absolute",
              top: "100%",
              left: 0,
              right: 0,
              background: "var(--primary-inverse)",
              border: "1px solid var(--primary-lightgray)",
              borderRadius: "0.5rem",
              maxHeight: 200,
              overflowY: "auto",
              marginTop: "0.25rem",
              zIndex: 2010,
              padding: 0,
              listStyle: "none",
            }}
          >
            {storage.storedOwnerPets.map((pet: PetType) => (
              <li
                className="pet-selection"
                key={pet.id}
                onClick={() => handleSelect(pet)}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "0.5rem 1rem",
                  cursor: "pointer",
                }}
              >
                <CircularImage
                  src={pet.image || "/pets/pet.jpg"}
                  width={50}
                  borderSize="3px" />
                <span style={{ color: 'var(--pico-contrast)', marginLeft: '8px' }}>{pet.name}</span>
              </li>
            ))}
            <li
              className="pet-selection"
              onClick={addPet}
              style={{
                display: "flex",
                alignItems: "center",
                padding: "0.5rem 1rem",
                cursor: "pointer",
              }}>
              <FaPlus />
              <span style={{ color: 'var(--pico-contrast)', marginLeft: '20px' }}>Agregar mascota</span>
            </li>
          </ul>
        )}

      </div>
    </ModalComponent>
  );
}
 
----- Archivo: ConfirmModal.tsx ----- 
// src/components/modals/ConfirmModal.tsx
import React from "react";
import ModalComponent from "../lib/modal";
import { FaQuestionCircle } from "react-icons/fa";

interface ConfirmModalProps {
    title: string;
    message: string;
    onConfirm: () => void;
    onCancel: () => void;
    confirmText?: string;
    cancelText?: string;
}

export default function ConfirmModal({ title, message, onConfirm, onCancel, confirmText = "Confirmar", cancelText = "Cancelar" }: ConfirmModalProps) {
    return (
        <ModalComponent setShowModal={() => onCancel()} title="">
            <div style={{ display: 'flex', gap: '1rem', alignItems: 'flex-start' }}>
                <FaQuestionCircle size={32} style={{ color: 'var(--pico-primary)', flexShrink: 0 }} />
                <div>
                    <h2 className="modal-title" style={{ marginTop: 0 }}>{title}</h2>
                    <p className="modal-description">{message}</p>
                </div>
            </div>
            <div style={{ display: 'flex', gap: '1rem', marginTop: '1rem' }}>
                <button onClick={onCancel} className="secondary" style={{ flex: 1 }}>
                    {cancelText}
                </button>
                <button onClick={onConfirm} style={{ flex: 1 }}>
                    {confirmText}
                </button>
            </div>
        </ModalComponent>
    );
} 
----- Archivo: FeedbackModal.tsx ----- 
// app/components/modals/FeedbackModal.tsx
"use client";
import React, { useState } from "react";
import ModalComponent from "../lib/modal";
import { postFetch } from "@/app/api";
import { useSessionContext } from "@/context/SessionProvider";
import { useUI } from "@/context/UIProvider";


export default function FeedbackModal() {
  const [feedback, setFeedback] = useState("");
  const [sending, setSending] = useState(false);
  const [isAnonymous, setIsAnonymous] = useState(false);
  const session = useSessionContext();
  const { setShowFeedbackModal } = useUI();

  const sendFeedback = async (anonymous: boolean) => {
    if (!feedback.trim()) return;
    setSending(true);

    try {
      const res = await postFetch(`/api/feedback`, undefined, { feedback, anonymous, userEmail: session?.db?.user.email });
      if (!res.ok) throw new Error("Error en el servidor");
      alert("¡Gracias por tu opinión!");
      setShowFeedbackModal(false);
    } catch (err) {
      console.error(err);
      alert("Ocurrió un error al enviar tu mensaje.");
      setSending(false);
    }
  };

  return (
    <ModalComponent title="Queremos leerte" description="Cuéntanos tu experiencia con Lampo o sobre tu mascota" setShowModal={setShowFeedbackModal}>
      <textarea
        value={feedback}
        onChange={(e) => setFeedback(e.target.value)}
        style={{
          width: "100%",
          minHeight: "4rem",
          padding: "0.5rem",
          borderRadius: "0.5rem",
          border: "1px solid var(--primary-lightgray)",
          marginTop: "0.75rem",
        }}
        disabled={sending}
      />

      {/* Checkbox para envío anónimo */}
      <label style={{ display: "flex", alignItems: "center", marginTop: "0.75rem" }}>
        <input
          type="checkbox"
          checked={isAnonymous}
          onChange={(e) => setIsAnonymous(e.target.checked)}
          disabled={sending}
          style={{ marginRight: "0.5rem" }}
        />
        Enviar de forma anónima
      </label>

      <div style={{ display: "flex", gap: "0.5rem", marginTop: "1rem" }}>
        <button
          onClick={() => sendFeedback(isAnonymous)}
          style={{ flex: 1 }}
          disabled={sending || !feedback.trim()}
        >
          {sending ? "Enviando..." : "Enviar"}
        </button>
      </div>
    </ModalComponent>
  );
}
 
----- Archivo: InviteUserModal.tsx ----- 
import React, { useState } from "react";
import ModalComponent from "@/components/lib/modal";
import { useUI } from "@/context/UIProvider";
import { authClient } from "@/lib/auth";

export default function InviteUserModal() {
    const { setShowInviteUserModal } = useUI();
    const [email, setEmail] = useState("");
    const [error, setError] = useState<string | null>(null);
    const [success, setSuccess] = useState(false);
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);

        if (!email || !/\S+@\S+\.\S+/.test(email)) {
            setError("Por favor ingresa un correo válido.");
            return;
        }

        setLoading(true);

        try {
            await authClient.inviteUser(email);
            setSuccess(true);
            setEmail("");
        } catch {
            setError("Hubo un error al enviar la invitación. Intenta de nuevo.");
        } finally {
            setLoading(false);
        }
    };

    return (
        <ModalComponent
            title="Invita a un amigo"
            description="Ingresa el correo de la persona que quieres invitar a Lampo."
            setShowModal={setShowInviteUserModal}
            hideClose={false}
        >
            {success ? (
                <div style={{ textAlign: "center", color: "var(--primary-green)", margin: "1rem 0" }}>
                    ¡Invitación enviada exitosamente!
                </div>
            ) : (
                <form onSubmit={handleSubmit} style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
                    <input
                        type="email"
                        placeholder="Correo electrónico"
                        value={email}
                        onChange={e => setEmail(e.target.value)}
                        required
                        style={{
                            padding: "0.75rem",
                            borderRadius: "4px",
                            border: "1px solid var(--primary-lightgray)",
                            fontSize: "1rem"
                        }}
                        autoFocus
                    />
                    {error && <span style={{ color: "var(--pico-primary)", fontSize: "0.95rem" }}>{error}</span>}
                    <button
                        type="submit"
                        className="contrast"
                        style={{ width: "100%", marginTop: "0.5rem" }}
                        aria-busy={loading}
                        disabled={loading}
                    >
                        {loading ? "Enviando..." : "Enviar invitación"}
                    </button>
                </form>
            )}
        </ModalComponent>
    );
} 
----- Archivo: MissingPet.tsx ----- 
import React from "react";
import ModalComponent from "@/components/lib/modal";
import { useUI } from "@/context/UIProvider";

export default function MissingPetModal() {
    const { setShowMissingPetModal, setShowAddPetModal } = useUI();

    function handleGoToAddPet() {
        setShowAddPetModal(true);
        setShowMissingPetModal(false);
    }

    return (
        <ModalComponent
            title="Registra tu primera mascota"
            description="Para comenzar a aprovechar Lampo, registra la información de tu primera mascota."
            setShowModal={setShowMissingPetModal}
            hideClose={true}
        >
            <button
                className="contrast"
                onClick={handleGoToAddPet}
                style={{ width: "100%", marginTop: "1rem" }}
            >
                Registrar mascota
            </button>
        </ModalComponent>
    );
}
 
----- Archivo: PetCodeModal.tsx ----- 
// app/components/modals/PetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { FaShareAlt, FaCopy } from "react-icons/fa";
import ModalComponent from "../lib/modal";
import { useStorageContext } from "@/context/StorageProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { postFetch } from "@/app/api";
import { useUI } from "@/context/UIProvider";

export default function PetCodeModal() {
  const [code, setCode] = useState("");
  const [show, setShow] = useState(false);
  const [error, setError] = useState("");
  const [copied, setCopied] = useState(false);
  const session = useSessionContext();
  const storage = useStorageContext();
  const { setShowCodeModal } = useUI();

  async function generar() {
    setError("");
    try {
      const res = await postFetch('/api/pets/me/code', undefined, { owner_id: session?.db?.user.id, pet_id: storage.storedPet.id });

      if (res.status === 404) {
        setError("No se encontró la mascota.");
        return;
      }
      if (!res.ok) {
        setError("Error al generar el código.");
        return;
      }

      const json = await res.json();
      if (json.code) {
        setCode(json.code);
        setShow(true);
        setCopied(false);
      } else {
        setError("Respuesta inválida del servidor.");
      }
    } catch (e) {
      console.error(e);
      setError("Ocurrió un error al generar el código.");
    }
  }

  const handleCopy = () => {
    navigator.clipboard.writeText(code).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
  };

  return (
    <ModalComponent title="Generar código" setShowModal={setShowCodeModal}>

      {!show &&
        <p style={{ fontSize: "0.8rem" }}>
          Este es un código dinámico de acesso para que tu veterinario pueda editar la información clínica de tu mascota.
        </p>
      }

      {error && (
        <p style={{ color: "var(--primary-red)", marginBottom: "0.5rem", fontSize: "0.9rem" }}>
          {error}
        </p>
      )}

      {show && (
        <>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              marginBottom: "0.5rem",
            }}
          >
            {code.split("").map((char, idx) => (
              <span
                key={idx}
                style={{
                  display: "inline-block",
                  width: "2rem",
                  padding: "0.5rem 0",
                  border: "1px solid var(--primary-lightgray)",
                  borderRadius: "0.25rem",
                  color: "var(--pico-primary)",
                  fontWeight: "bold",
                  textAlign: "center",
                  fontFamily: "monospace",
                }}
              >
                {char}
              </span>
            ))}

            <button
              onClick={handleCopy}
              style={{
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: "0.5rem",
              }}
              title="Copiar código"
            >
              <FaCopy size={20} color={copied ? "green" : "var(--pico-primary)"} />
            </button>
          </div>

          {copied && (
            <p style={{ color: "var(--primary-green)", marginBottom: "0.5rem", fontSize: "0.8rem" }}>
              ¡Código copiado!
            </p>
          )}

          <p style={{ fontSize: "0.8rem" }}>
            Este código es único para cada mascota. Compártelo con tu médico veterinario para brindarle acceso al historial.
          </p>

        </>
      )}

      {!show &&
        <button
          onClick={generar}
          style={{
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "0.5rem",
            marginTop: "1rem",
          }}
        >
          <FaShareAlt size={20} /> Generar
        </button>
      }
    </ModalComponent>
  );
}
 
----- Archivo: PlanSelectModal.tsx ----- 
import React from "react";
import { useRouter } from "next/navigation";
import ModalComponent from "@/components/lib/modal";
import { useUI } from "@/context/UIProvider";

export default function PlanSelectModal() {
    const router = useRouter();
    const {setShowPlanModal} = useUI();

    function handleGoToRegister() {
        setShowPlanModal(false); // Opcional: cierra el modal antes de redirigir
        router.push("/pages/owner/register");
    }

    return (
        <ModalComponent
            title="Selecciona tu plan"
            description="Selecciona tu plan antes de continuar."
            setShowModal={setShowPlanModal}
            hideClose={true}
        >
            <button
                className="contrast"
                onClick={handleGoToRegister}
                style={{ width: "100%", marginTop: "1rem" }}
            >
                Elegir plan
            </button>
        </ModalComponent>
    );
} 
----- Archivo: VeterinarianPetCodeModal.tsx ----- 
// src/components/modals/VeterinarianPetCodeModal.tsx
"use client";
import React, { useState } from "react";
import { useRouter } from "next/navigation";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";
import { useVetContext } from "@/context/VetContext";
import { useUI } from "@/context/UIProvider";

export default function VeterinarianPetCodeModal() {
    const router = useRouter();
    const { vet } = useVetContext();
    const { setShowVetPetCodeModal } = useUI();

    const storage = useStorageContext();

    const [code, setCode] = useState("");
    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    if (!vet) {
        return;
    }

    const handleSubmit = async () => {
        setError("");
        const sanitizedCode = code.trim().toUpperCase();
        if (!sanitizedCode) {
            setError("Por favor ingresa el código de la mascota.");
            return;
        }
        setLoading(true);

        try {
            // Envío de código junto con datos ocultos del veterinario
            const vetPayload = {
                code: sanitizedCode,
                firstName: vet.first_name,
                firstLastName: vet.first_last_name,
                secondLastName: vet.second_last_name,
                identification: vet.identification,
                registration: vet.registration,
                clinicName: vet.clinic_name,
                city: vet.city
            };
            const res = await postFetch("/api/vet/use-code", undefined, vetPayload);
            const data = await res.json();

            if (!res.ok || data.error) {
                setError(data.error || "Código inválido o expirado.");
            } else {
                // Obtener datos de la mascota y almacenar
                const petRes = await getFetch(`/api/pets/${data.pet_id}`);
                if (!petRes.ok) {
                    setError("No se encontró la mascota.");
                } else {
                    const petData = await petRes.json();
                    storage.setStoredPet(petData);
                    storage.setStoredOwnerPets([]);
                    storage.setStoredVetAccess({
                        id: data.vet_access,
                        pet_id: petData.id,
                        pet_code_id: data.pet_code,
                        vet_first_name: vet.first_name,
                        vet_first_last_name: vet.first_last_name,
                        vet_second_last_name: vet.second_last_name,
                        identification: vet.identification,
                        professional_registration: vet.registration,
                        clinic_name: vet.clinic_name,
                        city: vet.city
                    });
                    setShowVetPetCodeModal(false);
                    router.push(`/pages/vet/consultation/${petData.id}`);
                }
            }
        } catch {
            setError("Ocurrió un error inesperado.");
        } finally {
            setLoading(false);
        }
    };

    return (
        <ModalComponent
            title="Acceder a historial"
            description="Solo ingresa el código de la mascota para acceder a su historial"
            setShowModal={setShowVetPetCodeModal}
        >
            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    handleSubmit();
                }}
            >
                {/* Inputs ocultos con datos del veterinario */}
                <input type="hidden" name="firstName" value={vet.first_name} />
                <input type="hidden" name="firstLastName" value={vet.first_last_name} />
                <input type="hidden" name="secondLastName" value={vet.second_last_name} />
                <input type="hidden" name="identification" value={vet.identification} />
                <input type="hidden" name="registration" value={vet.registration} />
                <input type="hidden" name="clinicName" value={vet.clinic_name} />
                <input type="hidden" name="city" value={vet.city} />

                {/* Input visible para el código */}
                <label className="label">
                    Código de la mascota
                    <input
                        type="text"
                        className="input"
                        value={code}
                        onChange={(e) => setCode(e.target.value)}
                        placeholder="e.g. U8Y499"
                        required
                    />
                </label>

                {error && <p className="error">{error}</p>}

                <button
                    type="submit"
                    className="submit-btn"
                    disabled={loading}
                >
                    {loading ? "Validando..." : "Acceder"}
                </button>
            </form>
        </ModalComponent>
    );
}
 
----- Archivo: VeterinaryModal.tsx ----- 
// app/components/modals/VeterinaryModal.tsx
"use client";
import React, { Dispatch, SetStateAction, useState } from "react";
import { useRouter } from "next/navigation";
import { veterinaryStyles } from "../../styles/veterinary";
import ModalComponent from "../lib/modal";
import { postFetch, getFetch } from "@/app/api";
import { useStorageContext } from "@/context/StorageProvider";

interface VeterinaryModalProps {
  setShowModal: Dispatch<SetStateAction<boolean>>;
}

export default function VeterinaryModal({ setShowModal }: VeterinaryModalProps) {
  const [code, setCode] = useState("");
  const [firstName, setFirstName] = useState("");
  const [firstLastName, setFirstLastName] = useState("");
  const [secondLastName, setSecondLastName] = useState("");
  const [identification, setIdentification] = useState("");
  const [registration, setRegistration] = useState("");
  const [clinicName, setClinicName] = useState("");
  const [city, setCity] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const storage = useStorageContext();
  const handleSubmit = async () => {
    setError("");
    const sanitizedCode = code.replaceAll(" ", "").toUpperCase();
    if (![sanitizedCode, firstName, firstLastName, secondLastName, identification, registration, clinicName, city].every(Boolean)) {
      setError("Por favor completa todos los campos.");
      return;
    }
    setLoading(true);

    try {
      const codeResponse = await postFetch(
        '/api/vet/use-code',
        undefined,
        {
          code: sanitizedCode,
          firstName,
          firstLastName,
          secondLastName,
          identification,
          registration,
          clinicName,
          city
        }
      );
      const codeData = await codeResponse.json();

      if (!codeResponse.ok || codeData.error) {
        setError(codeData.error || "Código inválido o expirado.");
      } else {
        const petResponse = await getFetch(`/api/pets/${codeData.pet_id}`);

        if (!petResponse.ok) {
          setError("No se encontró la mascota.");
        }
        const petData = await petResponse.json();

        storage.setStoredPet(petData);
        storage.setStoredOwnerPets([]);

        storage.setStoredVetAccess({
          id: codeData.vet_access,
          pet_id: petData.id,
          pet_code_id: codeData.pet_code,
          vet_first_name: codeData.firstName,
          vet_first_last_name: codeData.firstLastName,
          vet_second_last_name: codeData.secondLastName,
          identification: codeData.identification,
          professional_registration: codeData.registration,
          clinic_name: codeData.clinicName,
          city: codeData.city
        });
        setShowModal(false);
        router.push(`/pages/vet/consultation/${petData.id}`);
      }
    } catch (error) {
      console.log(error);
      setError("Ocurrió un error inesperado.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <ModalComponent title="Soy médico veterinario" description="Aquí puedes revisar el historial completo, modificarlo y agregar entradas
        a la historia de la mascota" setShowModal={setShowModal} maxWidth="1000px">

      <div className="form-grid" style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
        <div>
          <h4 className="label">Nombre</h4>
          <input
            className="input"
            type="text"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Nombre"
          />
        </div>

        <div>
          <h4 className="label">Primer Apellido</h4>
          <input
            className="input"
            type="text"
            value={firstLastName}
            onChange={(e) => setFirstLastName(e.target.value)}
            placeholder="Primer Apellido"
          />
        </div>

        <div>
          <h4 className="label">Segundo Apellido</h4>
          <input
            className="input"
            type="text"
            value={secondLastName}
            onChange={(e) => setSecondLastName(e.target.value)}
            placeholder="Segundo Apellido"
          />
        </div>

        <div>
          <h4 className="label">Identificación</h4>
          <input
            className="input"
            type="text"
            value={identification}
            onChange={(e) => setIdentification(e.target.value)}
            placeholder="Identificación"
          />
        </div>

        <div>
          <h4 className="label">Registro profesional</h4>
          <input
            className="input"
            type="text"
            value={registration}
            onChange={(e) => setRegistration(e.target.value)}
            placeholder="Número de registro"
          />
        </div>

        <div>
          <h4 className="label">Clínica / Laboratorio</h4>
          <input
            className="input"
            type="text"
            value={clinicName}
            onChange={(e) => setClinicName(e.target.value)}
            placeholder="Nombre de la clínica"
          />
        </div>

        <div>
          <h4 className="label">Ciudad</h4>
          <input
            className="input"
            type="text"
            value={city}
            onChange={(e) => setCity(e.target.value)}
            placeholder="Ciudad"
          />
        </div>

        <div>
          <h4 className="label">Código de la mascota</h4>
          <input
            className="input-code"
            type="text"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            placeholder="e.g. U8Y499"
          />
        </div>
      </div>

      {error && <p className="error">{error}</p>}

      <button
        className="submit-btn"
        onClick={handleSubmit}
        disabled={loading}
      >
        {loading ? "Guardando..." : "Acceder"}
      </button>

      <style jsx>{veterinaryStyles}</style>
    </ModalComponent>
  );
}
 
----- Archivo: StorageContextType.ts ----- 
// src/context/storageType.ts
 
----- Archivo: AppContextProvider.tsx ----- 
// src/context/AppContext.tsx

import { UIProvider } from "./UIProvider";
import { OwnerSessionProvider } from "./OwnerSessionProvider";
import { PlanProvider } from "./PlanProvider";

export function AppContextProvider({ children }: { children: React.ReactNode }) {
  return (
    <UIProvider>
      <PlanProvider>
        <OwnerSessionProvider>
            {children}
        </OwnerSessionProvider>
      </PlanProvider>
    </UIProvider>
  );
}
 
----- Archivo: ClientAppProvider.tsx ----- 
// components/layout/ClientAppProvider.tsx
"use client";
import React from "react";
import { AppContextProvider } from "@/context/AppContextProvider";
import { Bubbles, Loading, SideBar } from "@/components/index";
import { useDeviceDetect } from "@/hooks/useDeviceDetect";
import { usePathname } from "next/navigation";
import useAuthRedirect from "@/hooks/useAuthRedirect";
import { useSessionContext } from "./SessionProvider";

interface Props {
    children: React.ReactNode;
}

export default function ClientAppProvider({ children }: Props) {
    useAuthRedirect();

    const { isMobile, isDesktop } = useDeviceDetect(); 
    const { isLoading: isSessionLoading } = useSessionContext();
    const pathname = usePathname();

    // 2. Determinar si la ruta actual es una ruta pública/especial que no usa el layout principal.
    const isAuthRoute = pathname === "/login" ||
        pathname.startsWith("/auth/callback") ||
        pathname.startsWith("/landing") ||
        pathname.startsWith("/pages/auth/verify");

    if (isSessionLoading) {
        return <Loading />; // Loader fullscreen o centrado
    }

    if (isAuthRoute) {
        return (
            <AppContextProvider>
                {children}
            </AppContextProvider>
        );
    }

    const gridCols = isMobile ? "1fr" : "300px 1fr";


    return (
        <AppContextProvider>
            <div
                className="container grid"
                style={{
                    gridTemplateColumns: gridCols,
                    minHeight: "100vh",
                    transition: "grid-template-columns 0.3s ease",
                    backgroundColor: "var(--primary-inverse)",
                    fontFamily: "'Inter', sans-serif",
                    marginLeft: '2%',
                }}
            >
                <SideBar />
                <Bubbles />
                <main
                    style={{
                        padding: "3rem",
                        marginLeft: isMobile ? "1rem" : isDesktop ? "5rem" : "2rem",
                        width: isMobile ? "100%" : isDesktop ? "107%" : "247%",
                    }}
                >
                    {children}
                </main>
            </div>
        </AppContextProvider>
    );
}
 
----- Archivo: OwnerSessionProvider.tsx ----- 
// src/context/OwnerSessionProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useOwnerSession } from "@/hooks/useOwnerSession";

interface OwnerSessionContextType { isLoading: boolean }

const OwnerSessionContext = createContext<OwnerSessionContextType>({
    isLoading: true
});

export const useOwnerSessionContext = () => useContext(OwnerSessionContext);

export function OwnerSessionProvider({ children }: { children: React.ReactNode }) {
    const { isLoading } = useOwnerSession();
    return (
        <OwnerSessionContext.Provider value={{  isLoading }}>
            {children}
        </OwnerSessionContext.Provider>
    );
} 
----- Archivo: PlanProvider.tsx ----- 
// src/context/PlanProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useSelectedPlan } from "@/hooks/useSelectedPlan";

interface PlanContextType {
    isLoading: boolean;
    hasSelectedPlan: boolean;
    hasFreePlan: boolean;
    hasStandardPlan: boolean;
    hasAdvancedPlan: boolean;
    hasLifetimePlan: boolean;
    requiresPlan: boolean;
}

const PlanContext = createContext<PlanContextType>({
    isLoading: true,
    hasSelectedPlan: true,
    hasFreePlan: true,
    hasStandardPlan: false,
    hasAdvancedPlan: false,
    hasLifetimePlan: false,
    requiresPlan: false,
});

export const usePlanContext = () => useContext(PlanContext);

export function PlanProvider({ children }: { children: React.ReactNode }) {
    const {
        isLoading,
        hasSelectedPlan,
        hasFreePlan,
        hasStandardPlan,
        hasAdvancedPlan,
        hasLifetimePlan,
        requiresPlan } = useSelectedPlan();
    return (
        <PlanContext.Provider value={{
            isLoading,
            hasSelectedPlan,
            hasFreePlan,
            hasStandardPlan,
            hasAdvancedPlan,
            hasLifetimePlan,
            requiresPlan
        }}>
            {children}
        </PlanContext.Provider>
    );
} 
----- Archivo: RoleProvider.tsx ----- 
// src/context/RoleProvider.tsx
"use client";
import { useRole } from "@/hooks/useRole";
import { createContext, useContext } from "react";

export const Role = createContext({} as ReturnType<typeof useRole>);
export const useRoleContext = () => useContext(Role);

export function RoleProvider({ children }: { children: React.ReactNode }) {
    const storage = useRole();
    return <Role.Provider value={storage}>{children}</Role.Provider>;
} 
----- Archivo: SessionProvider.tsx ----- 
// src/context/SessionProvider.tsx
"use client";
import React, { createContext, useContext } from "react";
import { useSession as useAppSessionHook } from "@/hooks/useSession";
import { AuthSession } from "@/lib/auth";

interface AppSessionContextType {
    db: AuthSession | null;
    isLoading: boolean;
    setSession: (session: AuthSession) => Promise<void>;
}

const SessionContext = createContext<AppSessionContextType>({
    db: null,
    isLoading: true,
    setSession: async () => {}
});

export const useSessionContext = () => useContext(SessionContext);

export function SessionProvider({ children }: { children: React.ReactNode }) {
    const { session, isLoading, setSession } = useAppSessionHook();
    return (
        <SessionContext.Provider value={{ db: session, isLoading: isLoading, setSession }}>
            {children}
        </SessionContext.Provider>
    );
} 
----- Archivo: StorageProvider.tsx ----- 
// src/context/StorageProvider.tsx
"use client";
import { useAppStorage } from "@/hooks/useAppStorage";
import { createContext, useContext } from "react";

export const Storage = createContext({} as ReturnType<typeof useAppStorage>);
export const useStorageContext = () => useContext(Storage);

export function StorageProvider({ children }: { children: React.ReactNode }) {
    const storage = useAppStorage();
    return <Storage.Provider value={storage}>{children}</Storage.Provider>;
} 
----- Archivo: UIProvider.tsx ----- 
// src/context/UIProvider.tsx
"use client";
import { useState, createContext, useContext, SetStateAction } from "react";
import { useStorageContext } from "./StorageProvider";

export interface UIState {
    showVetModal: boolean;
    setShowVetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showCodeModal: boolean;
    setShowCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
    showFeedbackModal: boolean;
    setShowFeedbackModal: React.Dispatch<React.SetStateAction<boolean>>;
    showChangePetModal: boolean;
    setShowChangePetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showAddPetModal: boolean;
    setShowAddPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showEditPetModal: boolean;
    setShowEditPetModal: React.Dispatch<React.SetStateAction<boolean>>;
    showVetPetCodeModal: boolean;
    setShowVetPetCodeModal: React.Dispatch<React.SetStateAction<boolean>>;
    showPlanModal: boolean;
    setShowPlanModal: React.Dispatch<React.SetStateAction<boolean>>;
    showInviteUserModal: boolean;
    setShowInviteUserModal: React.Dispatch<React.SetStateAction<boolean>>;
    showMissingPetModal: boolean;
    setShowMissingPetModal: React.Dispatch<React.SetStateAction<boolean>>;
}

const UIContext = createContext({} as UIState);
export const useUI = () => useContext(UIContext);

export function UIProvider({ children }: { children: React.ReactNode }) {
    const [showVetModal, setShowVetModal] = useState(false);
    const [showCodeModal, setShowCodeModal] = useState(false);
    const [showFeedbackModal, setShowFeedbackModal] = useState(false);
    const [showChangePetModal, setShowChangePetModal] = useState(false);
    const [showAddPetModal, setShowAddPetModal] = useState(false);
    const [showEditPetModal, setShowEditPetModal] = useState(false);
    const [showVetPetCodeModal, setShowVetPetCodeModal] = useState(false);
    const [showPlanModal, setShowPlanModal] = useState(false);
    const [showInviteUserModal, setShowInviteUserModal] = useState(false);
    const [showMissingPetModal, setShowMissingPetModal] = useState(false);
    const storage = useStorageContext();

    const closeEditPetModal: React.Dispatch<React.SetStateAction<boolean>> = (close: SetStateAction<boolean>) => {
        if (!close) {
            storage.resetPet();
        }
        return setShowEditPetModal(close);
    }

    return (
        <UIContext.Provider value={{
            showVetModal,
            setShowVetModal,
            showCodeModal,
            setShowCodeModal,
            showFeedbackModal,
            setShowFeedbackModal,
            showChangePetModal,
            setShowChangePetModal,
            showAddPetModal,
            setShowAddPetModal,
            showEditPetModal,
            setShowEditPetModal: closeEditPetModal,
            showVetPetCodeModal,
            setShowVetPetCodeModal,
            showPlanModal,
            setShowPlanModal,
            showInviteUserModal,
            setShowInviteUserModal,
            showMissingPetModal,
            setShowMissingPetModal,
        }}>
            {children}
        </UIContext.Provider>
    );
}
 
----- Archivo: VetContext.tsx ----- 
// src/context/VetContext.tsx
"use client";
import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { getFetch } from "@/app/api";
import type { VeterinarianType } from "@/types/index";
import { useSessionContext } from "./SessionProvider";
import { useRoleContext } from "./RoleProvider";
//import { useUI } from "./UIProvider";
import { useStorageContext } from "./StorageProvider";

interface VetContextType {
    vet: VeterinarianType | null;
    loading: boolean;
    refresh: () => Promise<void>;
}

// Contexto para proveer datos del veterinario autenticado
export const VetContext = createContext<VetContextType | undefined>(undefined);

interface VetProviderProps {
    children: ReactNode;
}

export function VetProvider({ children }: VetProviderProps) {
    const session = useSessionContext();
    const [vet, setVet] = useState<VeterinarianType | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const { isVetWithSession, isVetWithoutSession } = useRoleContext();
    //const { setShowVetPetCodeModal } = useUI();
    const storage = useStorageContext();

    // Función para obtener datos del veterinario desde API
    const fetchVet = async () => {
        setLoading(true);
        try {
            if (isVetWithSession) {
                if (!session?.db?.user?.id) {
                    setVet(null);
                    return;
                }
                if (!storage.storedVetData.vet_id) {
                    const res = await getFetch(`/api/vet/${session.db?.user.id}`);
                    if (!res.ok) {
                        console.error("Error fetching veterinarian profile");
                        setVet(null);
                    } else {
                        const data: VeterinarianType = await res.json();
                        storage.setStoredVetData(data);
                        setVet(data);
                    }
                }
                else {
                    setVet(storage.storedVetData);
                }
                //TODO: check if we want to open directly the modal to ask for the code.
                /*if (!storage.storedVetAccess.id) {
                    setShowVetPetCodeModal(true);
                }*/
            }
            else if (isVetWithoutSession) {
                setVet({
                    vet_id: '',
                    first_name: storage.storedVetAccess.vet_first_name,
                    first_last_name: storage.storedVetAccess.vet_first_last_name,
                    second_last_name: storage.storedVetAccess.vet_second_last_name,
                    identification: storage.storedVetAccess.identification,
                    email: '',
                    registration: storage.storedVetAccess.professional_registration,
                    clinic_name: storage.storedVetAccess.clinic_name,
                    city: storage.storedVetAccess.city
                })
            }

        } catch (error) {
            console.error(error);
            setVet(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchVet();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session]);

    return (
        <VetContext.Provider value={{ vet, loading, refresh: fetchVet }}>
            {children}
        </VetContext.Provider>
    );
}

// Hook para consumir el contexto de veterinario
export function useVetContext(): VetContextType {
    const context = useContext(VetContext);
    if (!context) {
        throw new Error("useVetContext debe usarse dentro de un VetProvider");
    }
    return context;
} 
----- Archivo: empty.ts ----- 
import { StepsStateType, StepStateEnum } from "@/types/lib";
import { PetType, PetCodeType, OwnerDataType, BasicDataType, VaccineDataType, SurgeryDataType, MedicineDataType, ConditionDataType, LabTestDataType, VeterinaryAccessType, FeatureType, PlanType, PlanVersionType, SubscriptionType, PetStep, VeterinarianType } from "@/types/index";
import { ConditionRepository, LabTestRepository, MedicineRepository, SurgeryRepository, VaccineRepository } from "../repositories";
import { BasicDataTypeSchema, ConditionDataTypeSchema, LabTestDataTypeSchema, MedicineDataTypeSchema, PetTypeSchema, SurgeryDataTypeSchema, VaccineDataTypeSchema } from "@/schemas/validationSchemas";

export function Pet(): PetType { return { id: '', name: '', image: '', birth_date: undefined, owner_id: '' } };

export function PetCode(): PetCodeType { return { id: '', pet_id: '', code: '', used: false, expires_at: '' } };

export function OwnerData(): OwnerDataType {
    return {
        owner_id: '',
        name: '',
        last_name: '',
        phone: '',
        address: '',
        city: '',
        country: '',
        email: ''
    }
};
export function BasicData(): BasicDataType {
    return {
        pet_id: '',
        pet_type: '',
        gender: '',
        weight: '0 Kg',
        race: '',
        coat_type: '',
        color: '',
        has_allergies: false,
        weight_condition: '',
        size: '',
        lives_with_others: false,
        main_food: '',
        has_vaccine: false,
        last_vaccine_name: undefined,
        last_vaccine_date: undefined,
        is_sterilized: false,
        sterilization_date: undefined,
        has_anti_flea: false,
        anti_flea_date: undefined,
        uses_medicine: false,
        special_condition: false
    }
};
export function VaccineData(): VaccineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        description: undefined,
        date: undefined,
        batch: '',
        brand: ''
    }
};
export function SurgeryData(): SurgeryDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        date: undefined,
        description: undefined
    }
};
export function MedicineData(): MedicineDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        dosage: '',
        frequency: ''
    }
};
export function ConditionData(): ConditionDataType {
    return {
        id: '',
        pet_id: '',
        condition: '',
        severity: ''
    }
};
export function LabTestData(): LabTestDataType {
    return {
        id: '',
        pet_id: '',
        name: '',
        type: '',
        date: undefined,
        result: undefined
    }
};
export function Feature(): FeatureType {
    return {
        text: '',
        badge: ''
    }
};
export function Plan(): PlanType {
    return {
        id: 0,
        slug: ''
    }
};
export function PlanVersion(): PlanVersionType {
    return {
        id: 0,
        plan_id: 0,
        slug: '',
        version: 0,
        title: '',
        description: '',
        price_month: 0,
        price_year: 0,
        discount_month: 0,
        discount_year: 0,
        features: [],
        effective_from: '',
        effective_to: null,
        plans: Plan()
    }
};
export function Subscription(): SubscriptionType {
    return {
        id: 0,
        user_id: '',
        plan_version_id: 0,
        cycle: 'monthly',
        status: 'pending',
        external_id: null,
        price_at_purchase: 0,
        discount_applied: 0,
        started_at: '',
        expires_at: null,
        updated_at: '',
        plans_versions: PlanVersion()
    }
};

export function VetAccess(): VeterinaryAccessType {
    return {
        id: '',
        pet_id: '',
        pet_code_id: '',
        vet_first_name: '',
        vet_first_last_name: '',
        vet_second_last_name: '',
        identification: '',
        professional_registration: '',
        clinic_name: '',
        city: ''
    }
}

export function VetData(): VeterinarianType {
    return {
        vet_id: '',
        first_name: '',
        first_last_name: '',
        second_last_name: '',
        identification: '',
        email: '',
        registration: '',
        clinic_name: '',
        city: ''
    }
}

export function Steps(): StepsStateType[] {
    return [
        { step: PetStep.Name, state: StepStateEnum.NotInitialize, schema: PetTypeSchema },
        { step: PetStep.BasicData, state: StepStateEnum.NotInitialize, schema: BasicDataTypeSchema },
        { step: PetStep.Vaccines, state: StepStateEnum.NotInitialize, schema: VaccineDataTypeSchema, url: '/api/pets/list/vaccines/', repository: new VaccineRepository() },
        { step: PetStep.Medicines, state: StepStateEnum.NotInitialize, schema: MedicineDataTypeSchema, url: '/api/pets/list/medicines/', repository: new MedicineRepository() },
        { step: PetStep.LabTests, state: StepStateEnum.NotInitialize, schema: LabTestDataTypeSchema, url: '/api/pets/list/lab-tests/', repository: new LabTestRepository() },
        { step: PetStep.Conditions, state: StepStateEnum.NotInitialize, schema: ConditionDataTypeSchema, url: '/api/pets/list/conditions/', repository: new ConditionRepository() },
        { step: PetStep.Surgeries, state: StepStateEnum.NotInitialize, schema: SurgeryDataTypeSchema, url: '/api/pets/list/surgeries/', repository: new SurgeryRepository() }
    ];
}

import { Empty } from "../data";

export function emptyStorage() {
    return {
        resetSession: () => { },
        resetPet: () => { },
        storedPet: Empty.Pet(),
        setStoredPet: () => { },
        storedBasicData: Empty.BasicData(),
        setStoredBasicData: () => { },
        storedOwnerData: Empty.OwnerData(),
        setStoredOwnerData: () => { },
        storedVetData: Empty.VetData(),
        setStoredVetData: () => { },
        storedVetAccess: Empty.VetAccess(),
        setStoredVetAccess: () => { },
        storedPetCode: Empty.PetCode(),
        setStoredPetCode: () => { },
        storedOwnerPets: [],
        setStoredOwnerPets: () => { },
        storedVaccineData: [],
        setStoredVaccineData: () => { },
        storedConditionData: [],
        setStoredConditionData: () => { },
        storedLabTestData: [],
        setStoredLabTestData: () => { },
        storedMedicineData: [],
        setStoredMedicineData: () => { },
        storedSurgeryData: [],
        setStoredSurgeryData: () => { }
    }
} 
----- Archivo: entityFieldData.ts ----- 
import { ConditionDataType, LabTestDataType, SurgeryDataType, VaccineDataType } from "@/types/index";
import { Dates } from "@/utils/index";

export function ForConditions(condition: ConditionDataType) {
    return [
        { label: "Condición", show: true, value: condition.condition },
        { label: "Severidad", show: true, value: condition.severity },
    ];
}

export function ForLabTests(labTest: LabTestDataType) {
    return [
        { label: "Prueba", show: true, value: labTest.name },
        { label: "Tipo", show: true, value: labTest.type },
        {
            label: "Fecha",
            show: labTest.date != null,
            value: Dates.format(labTest.date),
        },
        {
            label: "Resultado",
            show: labTest.result != null,
            value: labTest.result ?? "",
        },
    ];
}

export function ForMedicines(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForSurgeries(surgery: SurgeryDataType) {
    return [
        { label: "Procedimiento", show: true, value: surgery.name },
        {
            label: "Fecha",
            show: surgery.date != null,
            value: Dates.format(surgery.date),
        },
        {
            label: "Notas",
            show: surgery.description != null,
            value: surgery.description ?? "",
        },
    ];
}

export function ForVaccines(vaccine: VaccineDataType) {
    return [
        { label: "Vacuna", show: true, value: vaccine.name },
        {
            label: "Descripción",
            show: vaccine.description != null,
            value: vaccine.description ?? "",
        },
        {
            label: "Fecha",
            show: vaccine.date != null,
            value: Dates.format(vaccine.date),
        },
        { label: "Lote", show: true, value: vaccine.batch },
        { label: "Marca", show: true, value: vaccine.brand },
    ];
} 
----- Archivo: index.ts ----- 
export * as Empty from "./empty";
export * as FieldData from "./entityFieldData"; 
----- Archivo: petdata.ts ----- 
// app/data/petdata.tsx
import { v4 } from "uuid";
import { Metadata } from "next";
import {
  BasicDataType,
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  OwnerDataType,
  PetType,
  SurgeryDataType,
  VaccineDataType
} from "@/types/index";

export const metadata: Metadata = {
  title: "Lampo",
  description: "Lampo es una herramienta para que ayudará a TU MASCOTA en sus proceso clínicos y veterinarios",
};

export const andresData: OwnerDataType = {
  owner_id: '8933eed8-daea-4e6c-b4db-44906b9f44f9',
  name: 'Andrés',
  last_name: 'Aulestia',
  phone: '+57 3146061490',
  address: 'Cra. 74 #152b-70 Torre 3 Apto. 1704',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'a.aulestia@exe.com.co'
}

export const johnnyData: OwnerDataType = {
  owner_id: '41095adf-27a6-48f8-ada1-d8c7d3dd265a',
  name: 'Johnnatan',
  last_name: 'Ruiz',
  phone: '+57 3112849616',
  address: 'Calle 82 #19A-29 Apt 401',
  city: 'Bogotá',
  country: 'Colombia',
  email: 'excellent.exeqtion@gmail.com'
}

export const ownersData: OwnerDataType[] = [
  andresData,
  johnnyData
];

export const PetsData: PetType[] = [
  { id: 'A001', name: 'Camus', image: '/pets/camus.png', owner_id: andresData.owner_id },
  { id: 'A002', name: 'Polar', image: '/pets/polar.png', owner_id: johnnyData.owner_id },
  { id: 'A003', name: 'Toby', image: '/pets/toby.png', owner_id: johnnyData.owner_id }
];

export const camusData: BasicDataType =
{
  pet_id: 'A001', pet_type: 'Gato', gender: 'Macho', weight: '5.5 Kg', race: 'Mestizo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: false, coat_type:'Largo', color: 'Gris',
  main_food: 'Taste the Wild', has_vaccine: true, last_vaccine_name: 'Parvigen', last_vaccine_date: new Date('2024-07-25'),
  is_sterilized: true, sterilization_date: new Date('2023-12-02'), has_anti_flea: true, anti_flea_date: new Date('2023-12-15'),
  uses_medicine: false, special_condition: false
}

export const polarData: BasicDataType =
{
  pet_id: 'A002', pet_type: 'Perro', gender: 'Macho', weight: '7 Kg', race: 'Criollo', has_allergies: false,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true, coat_type:'Corto', color: 'Blanco',
  main_food: 'Pro Plan', has_vaccine: false,
  is_sterilized: true, sterilization_date: new Date('2023-06-30'), has_anti_flea: false,
  uses_medicine: false, special_condition: false
};

export const tobyData: BasicDataType =
{
  pet_id: 'A003', pet_type: 'Perro', gender: 'Macho', weight: '9 Kg', race: 'Criollo', has_allergies: true,
  weight_condition: 'Normal', size: 'Mediano', lives_with_others: true, coat_type:'Corto', color: 'Blanco',
  main_food: 'Vet Life', has_vaccine: false,
  is_sterilized: true, sterilization_date: new Date('2019-05-03'), has_anti_flea: false,
  uses_medicine: false, special_condition: true
};

export const petsData: BasicDataType[] =
  [
    camusData,
    polarData,
    tobyData
  ];


export const vaccinesMock: VaccineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Rabia", description: "Vacuna contra la rabia", date: new Date('2025-03-15'), batch: "RAB12345", brand: "Nobivac" },
  { id: v4(), pet_id: 'A001', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
  { id: v4(), pet_id: 'A002', name: "Parvovirus", description: "Prevención de parvovirus", date: new Date('2025-02-10'), batch: "PARV67890", brand: "Canigen" },
];

export const surgeriesMock: SurgeryDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Castración", date: new Date("2024-11-20"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A001', name: "Extracción dental", date: new Date("2024-12-05"), description: "Tooth extraction" },
  { id: v4(), pet_id: 'A002', name: "Castración", date: new Date("2023-06-30"), description: "Castración preventiva" },
  { id: v4(), pet_id: 'A003', name: "Castración", date: new Date("2019-05-03"), description: "Castración preventiva" },
];

export const medicinesMock: MedicineDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Antibiótico X", dosage: "250mg", frequency: "Cada 12 horas" },
  { id: v4(), pet_id: 'A001', name: "Vitamina C", dosage: "100mg", frequency: "Diaria" },
];

export const conditionsMock: ConditionDataType[] = [
  { id: v4(), pet_id: 'A001', condition: "Esterilidad aórtica", severity: "Moderada" },
  { id: v4(), pet_id: 'A001', condition: "Alergia alimentaria", severity: "Leve" },
  { id: v4(), pet_id: 'A003', condition: "Insuficiencia renal", severity: "Leve" },
];

export const labTestsMock: LabTestDataType[] = [
  { id: v4(), pet_id: 'A001', name: "Hemograma completo", type: "Blood", date: new Date("2025-01-10"), result: "Normal" },
  { id: v4(), pet_id: 'A001', name: "Ultrasonido abdominal", type: "Ultrasound", date: new Date("2024-12-22"), result: "Sin hallazgos" },
];

export const petTypes = ['Perro', 'Gato', 'Ave', 'Reptil', 'Otro'];
export const genders = ['Macho', 'Hembra'];
export const weightUnits = ['Kg', 'Lb'];
export const breedOptions: Record<string, string[]> = {
  Perro: ['Labrador', 'Pastor Alemán', 'Bulldog', 'Otro'],
  Gato: ['Siamés', 'Persa', 'Maine Coon', 'Otro'],
  Ave: ['Loro', 'Canario', 'Periquito', 'Otro'],
  Reptil: ['Iguana', 'Tortuga', 'Otro'],
  Otro: ['Otro'],
};
export const foodOptions = [
  'Royal Canin',
  'Purina Pro Plan',
  'Whiskas',
  'Dog Chow',
  'Eukanuba',
  'Nutra Nuggets',
  'Pedigree',
  'Otro'
];
export const weightConditionOptions = ['Bajo peso', 'Peso ideal', 'Sobrepeso'];
export const sizeOptions = ['Pequeño', 'Mediano', 'Grande', 'Extra Grande'];
export const coatTypes = ['Corto', 'Largo', 'Rizado', 'Duro', 'Sin pelo', 'Otro'];
export const colorOptions = ['Negro', 'Blanco', 'Marrón', 'Gris', 'Dorado', 'Atigrado', 'Bicolor', 'Tricolor', 'Merle', 'Otro']; 
----- Archivo: useAppStorage.ts ----- 
// hooks/useAppStorage.ts
import { useLocalStorage } from "@/hooks/useLocalStorage";
import { PetType, PetCodeType, VeterinaryAccessType, BasicDataType, OwnerDataType, VaccineDataType, ConditionDataType, LabTestDataType, MedicineDataType, SurgeryDataType, VeterinarianType, SubscriptionType } from "@/types/index";
import { Empty } from "@/data/index";
export interface StorageContextType {
  resetSession: () => void;
  resetPet: () => void;
  storedPet: PetType;
  setStoredPet: (value: PetType) => void;
  storedBasicData: BasicDataType;
  setStoredBasicData: (value: BasicDataType) => void;
  storedOwnerData: OwnerDataType;
  setStoredOwnerData: (value: OwnerDataType) => void;
  storedVetData: VeterinarianType;
  setStoredVetData: (value: VeterinarianType) => void;
  storedVetAccess: VeterinaryAccessType;
  setStoredVetAccess: (value: VeterinaryAccessType) => void;
  storedPetCode: PetCodeType;
  setStoredPetCode: (value: PetCodeType) => void;
  storedOwnerPets: PetType[];
  setStoredOwnerPets: (value: PetType[]) => void;
  storedVaccineData: VaccineDataType[],
  setStoredVaccineData: (value: VaccineDataType[] | null) => void,
  storedConditionData: ConditionDataType[],
  setStoredConditionData: (value: ConditionDataType[] | null) => void,
  storedLabTestData: LabTestDataType[],
  setStoredLabTestData: (value: LabTestDataType[] | null) => void,
  storedMedicineData: MedicineDataType[],
  setStoredMedicineData: (value: MedicineDataType[] | null) => void,
  storedSurgeryData: SurgeryDataType[],
  setStoredSurgeryData: (value: SurgeryDataType[] | null) => void,
  storedSubscriptionData: SubscriptionType,
  setStoredSubscriptionData: (value: SubscriptionType | null) => void,
}

export function useAppStorage() {
  const [storedPet, setStoredPet] = useLocalStorage<PetType>(
    "selectedPet",
    Empty.Pet()
  );

  const [storedBasicData, setStoredBasicData] = useLocalStorage<BasicDataType>(
    "petBasicData",
    Empty.BasicData()
  );

  const [storedOwnerData, setStoredOwnerData] = useLocalStorage<OwnerDataType>(
    "petOwnerData",
    Empty.OwnerData()
  );

  const [storedOwnerPets, setStoredOwnerPets] = useLocalStorage<PetType[]>(
    "ownerPets",
    []
  );

  const [storedVaccineData, setStoredVaccineData] = useLocalStorage<VaccineDataType[] | null>(
    "petVaccineData",
    null
  );

  const [storedConditionData, setStoredConditionData] = useLocalStorage<ConditionDataType[] | null>(
    "petConditionData",
    null
  );

  const [storedLabTestData, setStoredLabTestData] = useLocalStorage<LabTestDataType[] | null>(
    "petLabTestData",
    null
  );

  const [storedMedicineData, setStoredMedicineData] = useLocalStorage<MedicineDataType[] | null>(
    "petMedicineData",
    null
  );

  const [storedSurgeryData, setStoredSurgeryData] = useLocalStorage<SurgeryDataType[] | null>(
    "petSurgeryData",
    null
  );

  const [storedVetAccess, setStoredVetAccess] = useLocalStorage<VeterinaryAccessType>(
    "vetAccess",
    Empty.VetAccess()
  );

  const [storedPetCode, setStoredPetCode] = useLocalStorage<PetCodeType>(
    "petCode",
    Empty.PetCode()
  );

  const [storedVetData, setStoredVetData] = useLocalStorage<VeterinarianType>(
    "vetData",
    Empty.VetData()
  );

  const [storedSubscriptionData, setStoredSubscriptionData] = useLocalStorage<SubscriptionType | null>(
    "subscriptionType",
    null
  );

  const resetPet = () => {
    setStoredBasicData(Empty.BasicData());
    setStoredConditionData(null);
    setStoredLabTestData(null);
    setStoredMedicineData(null);
    setStoredSurgeryData(null);
    setStoredVaccineData(null);
  }

  const resetSession = () => {
    resetPet();
    setStoredVetData(Empty.VetData());
    setStoredPetCode(Empty.PetCode());
    setStoredVetAccess(Empty.VetAccess());
    setStoredOwnerData(Empty.OwnerData());
    setStoredOwnerPets([]);
    setStoredPet(Empty.Pet());
    setStoredSubscriptionData(Empty.Subscription());
  }

  return {
    resetSession,
    resetPet,
    storedPet,
    setStoredPet,
    storedBasicData,
    setStoredBasicData,
    storedOwnerData,
    setStoredOwnerData,
    storedVetData,
    setStoredVetData,
    storedOwnerPets,
    setStoredOwnerPets,
    storedVaccineData,
    setStoredVaccineData,
    storedConditionData,
    setStoredConditionData,
    storedLabTestData,
    setStoredLabTestData,
    storedMedicineData,
    setStoredMedicineData,
    storedSurgeryData,
    setStoredSurgeryData,
    storedVetAccess,
    setStoredVetAccess,
    storedPetCode,
    setStoredPetCode,
    storedSubscriptionData: storedSubscriptionData, 
    setStoredSubscriptionData: setStoredSubscriptionData
  } as StorageContextType;
} 
----- Archivo: useAuthRedirect.ts ----- 
// RUTA: src/hooks/useAuthRedirect.ts
"use client";

import { useEffect } from "react";
import { usePathname, useRouter } from "next/navigation";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useRoleContext } from "@/context/RoleProvider";

// ----- Lógica de rutas permitidas para Vet sin sesión (sincronizada con el middleware) -----
const VET_GUEST_ALLOWED_PATHS = [
    '/pages/pet/basic-data',
    '/pages/pet/vaccines',
    '/pages/pet/surgeries',
    '/pages/pet/medicines',
    '/pages/pet/conditions',
    '/pages/pet/lab-tests',
];

function isVetGuestAllowedPath(pathname: string, petId: string): boolean {
    if (VET_GUEST_ALLOWED_PATHS.includes(pathname)) {
        return true;
    }
    const consultationMatch = pathname.match(/^\/pages\/pet\/consultations\/([^/]+)/);
    if (consultationMatch && consultationMatch[1] === petId) {
        return true;
    }
    const newConsultationMatch = pathname.match(/^\/pages\/vet\/consultation\/([^/]+)/);
    if (newConsultationMatch && newConsultationMatch[1] === petId) {
        return true;
    }
    return false;
}
// ----- Fin de la lógica de rutas -----


export default function useAuthRedirect() {
    const router = useRouter();
    const pathname = usePathname();
    const { db: session, isLoading: isSessionLoading } = useSessionContext();
    const { storedVetAccess } = useStorageContext();
    const { isVetWithoutUserSession } = useRoleContext();

    useEffect(() => {
        // 1. No hacer nada mientras la sesión está cargando
        if (isSessionLoading) {
            return;
        }

        // 2. Lógica de redirección si HAY una sesión de usuario
        if (session) {
            if (pathname === "/login") {
                router.replace("/pages/home");
            }
            return; // Si hay sesión, el resto de la lógica no aplica
        }

        // 3. Lógica de redirección si NO HAY sesión de usuario
        // 3.1. Verificar si es un veterinario invitado (acceso por código)
        if (isVetWithoutUserSession) {
            const petId = storedVetAccess?.pet_id;
            // Si el veterinario tiene un petId de acceso y la ruta está permitida, no hacemos nada.
            if (petId && isVetGuestAllowedPath(pathname, petId)) {
                return;
            }

            // Si está en la página de acceso de veterinario, tampoco hacemos nada.
            if (pathname.startsWith('/vet-access')) {
                return;
            }

            // Para cualquier otra ruta no permitida, lo redirigimos a la página de acceso.
            router.replace('/vet-access');
            return;
        }

        // 3.2. Si es un usuario anónimo normal (no es un vet invitado)
        const isGenerallyPublicRoute =
            pathname === "/" ||
            pathname === "/login" ||
            pathname.startsWith("/vet-access") ||
            pathname.startsWith("/pages/auth/verify") ||
            pathname.startsWith("/auth/callback");

        if (!isGenerallyPublicRoute) {
            router.replace("/login");
        }

    }, [session, isSessionLoading, pathname, router, storedVetAccess, isVetWithoutUserSession]);
} 
----- Archivo: useDeviceDetect.ts ----- 
// hooks/useDeviceDetect.ts
import { useState, useEffect } from 'react'

export function useDeviceDetect() {
  const [isMobile, setIsMobile] = useState(false)
  const [isTablet, setIsTablet] = useState(false)
  const [isDesktop, setIsDesktop] = useState(false)

  useEffect(() => {
    const onResize = () => {
      const w = window.innerWidth
      setIsMobile(w <= 767)
      setIsTablet(w > 767 && w <= 1024)
      setIsDesktop(w > 1024)
    }

    onResize() // run once on mount
    window.addEventListener('resize', onResize)
    return () => window.removeEventListener('resize', onResize)
  }, [])

  return { isMobile, isTablet, isDesktop }
}
 
----- Archivo: useEffectDebugger.ts ----- 
/* eslint-disable @typescript-eslint/no-explicit-any */

import { useRef, useEffect } from "react";

const usePrevious = (value: any, initialValue: any) => {
    const ref = useRef(initialValue);
    useEffect(() => {
        ref.current = value;
    });
    return ref.current;
};

export const useEffectDebugger = (processName: string, effectHook: any, dependencies: any, dependencyNames = []) => {
    const previousDeps = usePrevious(dependencies, []);

    const changedDeps = dependencies.reduce((accum: any, dependency: any, index: any) => {
        if (dependency !== previousDeps[index]) {
            const keyName = dependencyNames[index] || index;
            return {
                ...accum,
                [keyName]: {
                    before: previousDeps[index],
                    after: dependency
                }
            };
        }

        return accum;
    }, {});

    if (Object.keys(changedDeps).length) {
        console.log(`[use-effect-debugger] ${processName}:`, changedDeps);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(effectHook, dependencies);
};

 
----- Archivo: useEntityList.ts ----- 
// src/hooks/useEntityList.ts
"use client";

import { deleteFetch } from '@/app/api';
import { ApiError, StepsStateType } from '@/types/lib';
import { Dispatch, SetStateAction } from 'react';

export function useEntityList<T extends { id: string | undefined }>(
    emptyFactory: (id: string) => Partial<T>,
    id: string,
    setList: Dispatch<SetStateAction<Partial<T>[]>>,
    setError: Dispatch<SetStateAction<string | null>>,
    stepNumber: number,
    stepStates: StepsStateType[]
) {
    const addItem = () => setList(prev => [...prev, emptyFactory(id)]);
    const removeItem = (id?: string) => {
        const getUrl = () =>
            stepStates.find(x => x.step == stepNumber)?.url;
        if (id) {
            try {
                deleteFetch(`${getUrl()}${id}`);
            }
            catch {
                throw new ApiError("Error al consumir la api de delete");
            }
        }
        setList(prev => {
            const items = prev.filter(item => item.id !== id);
            if (items.length == 0) {
                setError('');
            }
            return items;
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateItem = (index: number, field: keyof T, value: any) =>
        setList(prev => prev.map((item, idx) => (idx === index ? { ...item, [field]: value } : item)));

    return { addItem, removeItem, updateItem };
}
 
----- Archivo: useEntitySubmit.ts ----- 
// src/hooks/useEntitySubmit.ts
"use client";

import { Dispatch, SetStateAction, useState } from 'react';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { Steps, Validations } from '@/utils/index';
import { FieldConfig } from '../types/lib/index';
import { postFetch } from '@/app/api';

export function useEntitySubmit<T>(
    id: string,
    entities: Partial<T>[],
    entityName: string,
    setStoredList: (list: T[]) => void,
    setDataCallback: (data: T[]) => void,
    fieldConfig: FieldConfig<T>[],
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: React.Dispatch<React.SetStateAction<StepsStateType[]>>,
    error: string | null,
    setError: Dispatch<SetStateAction<string | null>>
) {
    const [submitting, setSubmitting] = useState(false);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x => x.step === stepNumber)?.url;

    const submit = async (onNext: () => void) => {
        setSubmitting(false);
        const validationError = Validations.forFields(entities, entityName, fieldConfig);
        if (validationError) {
            setError(validationError);
            return;
        }
        setError(null);
        try {
            if (stateEq(StepStateEnum.Modified)) {
                if (entities.length > 0) {
                    const basicDataResponse = await postFetch(`${getUrl()}${id}`, undefined, entities);
                    if (!basicDataResponse.ok) throw new ApiError(`Error actualizado ${entityName}.`);
                    setDataCallback(entities as T[]);
                    setStoredList(entities as T[]);
                }
                setState(StepStateEnum.Saved);
            }
            onNext();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (err: any) {
            setError(err.message);
            setState(StepStateEnum.Error, err.message);
        } finally {
            setSubmitting(true);
        }
    };

    return { submit, loading: submitting, error };
} 
----- Archivo: useLoadEntities.ts ----- 

// src/hooks/useLoadEntities.ts
"use client";

import { useState, useEffect, Dispatch, SetStateAction } from 'react';
import { Steps } from '@/utils/index';
import { ApiError, StepStateEnum, StepsStateType } from '@/types/lib';
import { getFetch } from '@/app/api';

export function useLoadEntities<T>(
    id: string,
    entityName: string,
    storedList: T[],
    setStoredList: (list: T[] | null) => void,
    initialData: T[],
    setDataCallback: (data: T[]) => void,
    stepNumber: number,
    stepStates: StepsStateType[],
    setStepStates: Dispatch<SetStateAction<StepsStateType[]>>
) {
    const [list, setList] = useState<Partial<T>[]>(initialData);
    const [savedData, setSavedData] = useState<T[]>(initialData);
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(true);

    const setState = (state: StepStateEnum, err: string | null = null) => {
        Steps.ChangeState(stepStates, setStepStates, stepNumber, state, err);
    };
    const stateEq = (state: StepStateEnum) =>
        stepStates.find(x => x.step === stepNumber)?.state === state;
    const getUrl = () =>
        stepStates.find(x => x.step == stepNumber)?.url;

    useEffect(() => {
        const fetch = async () => {
            if (stateEq(StepStateEnum.NotInitialize)) {
                setState(StepStateEnum.Initialize);
                let saved: T[] = [];
                if (storedList == null) {
                    const response = await getFetch(`${getUrl()}}${id}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener información de ${entityName}`);
                    if (saved.length > 0) {
                        setStoredList(saved);
                    }
                }
                else {
                    saved = storedList;
                }
                if (saved) {
                    setSavedData(saved);
                    setDataCallback(saved);
                    setList(saved);
                }
            }
            setLoading(false);
        }
        fetch();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [id]);

    useEffect(() => {
        if (JSON.stringify(savedData) !== JSON.stringify(list) && !stateEq(StepStateEnum.NotInitialize) && loading == false) {
            setState(StepStateEnum.Modified);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [list]);

    return { list, setList, error, setError, loading, setState, stateEq };
}
 
----- Archivo: useOwnerSession.ts ----- 
import { getFetch } from "@/app/api";
import { useRoleContext } from "@/context/RoleProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { useUI } from "@/context/UIProvider";
import { ApiError } from "@/types/lib";
import { useEffect, useState } from "react";
import { Empty } from "../data";
import { PetType } from "../types";
import { useSessionContext } from "@/context/SessionProvider";
import { usePlanContext } from "@/context/PlanProvider";
import { usePathname } from "next/navigation";

export function useOwnerSession(): { isLoading: boolean } {
    const { db: session } = useSessionContext();
    const pathname = usePathname();
    const storage = useStorageContext();
    const { setShowMissingPetModal, setShowPlanModal } = useUI();
    const { isOwner } = useRoleContext();
    const { hasSelectedPlan, isLoading: isLoadingPlan } = usePlanContext();

    const [loadingOwnerPets, setLoadingOwnerPets] = useState(true);
    const [loadingSelectedPet, setLoadingSelectedPet] = useState(true);

    useEffect(() => {
        const ownerId = session?.user?.id;
        if (!session || !ownerId) return;

        (async () => {
            if (isOwner) {
                if (storage.storedOwnerPets.length === 0) {
                    const response = await getFetch(`/api/owners/pets/${ownerId}`);
                    if (!response.ok) throw new ApiError(`Fallo al obtener las mascotas del dueño: ${ownerId}`);
                    const data = await response.json();
                    storage.setStoredOwnerPets(data as PetType[]);
                }
            }
            setLoadingOwnerPets(false);
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session, session?.user?.id]);

    useEffect(() => {
        let initialPet = Empty.Pet();
        if (storage.storedOwnerPets.length > 0) initialPet = storage.storedOwnerPets[0];
        if (storage.storedPet.id) initialPet = storage.storedPet;
        if (JSON.stringify(initialPet) !== JSON.stringify(storage.storedPet)) {
            storage.setStoredPet(initialPet);
        }

        if (isOwner && !hasSelectedPlan && pathname !== '/pages/owner/register' && !isLoadingPlan) {
            setShowPlanModal(true);
        }
        else {
            setShowPlanModal(false);
        }
        if (!initialPet.id && isOwner && hasSelectedPlan && !loadingSelectedPet) {
            setShowMissingPetModal(true);
        }
        setLoadingSelectedPet(false);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [storage.storedOwnerPets, pathname]);

    return { isLoading: loadingOwnerPets || loadingSelectedPet }
} 
----- Archivo: usePetProfileProgress.ts ----- 
// src/hooks/usePetProfileProgress.ts
import { useStorageContext } from "@/context/StorageProvider";
import { PetStep } from "@/types/index";
import { useMemo } from "react";

export function usePetProfileProgress() {
    const {
        storedBasicData,
        storedVaccineData,
        storedMedicineData,
        storedLabTestData,
        storedConditionData,
        storedSurgeryData,
    } = useStorageContext();

    const progress = useMemo(() => {
        const isComplete = (step: PetStep): boolean => {
            switch (step) {
                case PetStep.BasicData:
                    // Consideramos completo si tiene al menos tipo, género y peso.
                    return !!(storedBasicData.pet_type && storedBasicData.gender && storedBasicData.weight !== '0 Kg');
                case PetStep.Vaccines:
                    return (storedVaccineData?.length ?? 0) > 0;
                case PetStep.Medicines:
                    return (storedMedicineData?.length ?? 0) > 0;
                case PetStep.LabTests:
                    return (storedLabTestData?.length ?? 0) > 0;
                case PetStep.Conditions:
                    return (storedConditionData?.length ?? 0) > 0;
                case PetStep.Surgeries:
                    return (storedSurgeryData?.length ?? 0) > 0;
                default:
                    return false;
            }
        };

        return {
            basicData: isComplete(PetStep.BasicData),
            vaccines: isComplete(PetStep.Vaccines),
            medicines: isComplete(PetStep.Medicines),
            labTests: isComplete(PetStep.LabTests),
            conditions: isComplete(PetStep.Conditions),
            surgeries: isComplete(PetStep.Surgeries),
        };
    }, [storedBasicData, storedVaccineData, storedMedicineData, storedLabTestData, storedConditionData, storedSurgeryData]);

    return progress;
} 
----- Archivo: useRole.ts ----- 
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";

export function useRole() {
  const { db: session } = useSessionContext();
  const { storedVetAccess } = useStorageContext();

  const isOwner = session?.user.user_metadata.role === "owner";
  const isVetWithSession = session?.user.user_metadata.role === "veterinarian";
  const hasVetAccessWithoutSession = !session && Boolean(storedVetAccess?.id);
  const isVetWithUserSession = Boolean(storedVetAccess?.id) && isOwner;
  const isVetWithoutUserSession =
    (isVetWithSession || hasVetAccessWithoutSession) && !isVetWithUserSession;
  const isVet =
    isVetWithSession || 
    isVetWithoutUserSession || 
    isVetWithUserSession;
  return {
    isOwner,
    isVet,
    isVetWithSession,
    isVetWithoutSession: hasVetAccessWithoutSession,
    isVetWithUserSession,
    isVetWithoutUserSession,
  } as const;
}
 
----- Archivo: useSelectedPlan.ts ----- 
import { getFetch } from "@/app/api";
import { useRoleContext } from "@/context/RoleProvider";
import { useSessionContext } from "@/context/SessionProvider";
import { useStorageContext } from "@/context/StorageProvider";
import { ApiError } from "@/types/lib";
import { useState, useEffect } from "react";
import { SubscriptionType } from "@/types/index";
import { Empty } from "../data";

export function useSelectedPlan(): {
    isLoading: boolean;
    hasSelectedPlan: boolean;
    hasFreePlan: boolean;
    hasStandardPlan: boolean;
    hasAdvancedPlan: boolean;
    hasLifetimePlan: boolean;
    requiresPlan: boolean;
} {
    const { db: session } = useSessionContext();
    const storage = useStorageContext();
    const { isOwner } = useRoleContext();

    const [loadingPlan, setLoadingPlan] = useState(true);
    const [hasSelectedPlan, setHasSelectedPlan] = useState(false);
    const [hasFreePlan, setHasFreePlan] = useState(false);
    const [hasStandardPlan, setHasStandardPlan] = useState(false);
    const [hasAdvancedPlan, setHasAdvancedPlan] = useState(false);
    const [hasLifetimePlan, setHasLifetimePlan] = useState(false);
    const [requiresPlan, setRequiresPlan] = useState(false);

    const requestSubscription = async () => {
        const ownerId = session?.user?.id;
        const response = await getFetch(`/api/plans/subscriptions/${ownerId}`);
        if (!response.ok) throw new ApiError(`Fallo al obtener la suscripción actual del dueño: ${ownerId}`);
        const { data } = await response.json();
        let subscription = Empty.Subscription();
        subscription.id = -1;
        let hasSelectedPlan = false;
        if (data) {
            hasSelectedPlan = true;
            subscription = data as SubscriptionType;
        }
        storage.setStoredSubscriptionData(subscription);
        setStates(hasSelectedPlan, subscription);
    }

    useEffect(() => {
        const ownerId = session?.user?.id;
        if (!session || !ownerId) return;

        (async () => {
            if (!isOwner) {
                setStates(true, Empty.Subscription());
            }
            else {
                if (!storage.storedSubscriptionData?.id) {
                    await requestSubscription();
                }
                else {
                    setStates(true, storage.storedSubscriptionData);
                }
            }
            setLoadingPlan(false);
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [session?.user?.id, storage.storedSubscriptionData]);

    const setStates = (hasSelectedPlan: boolean, subscription: SubscriptionType) => {
        if (!isOwner) {
            setHasSelectedPlan(true);
            setHasLifetimePlan(false);
            setHasAdvancedPlan(false);
            setHasStandardPlan(false);
            setHasFreePlan(false);
            setRequiresPlan(false);
            return;
        }
        if (!hasSelectedPlan || subscription.id == -1) {
            setHasSelectedPlan(false);
            setHasLifetimePlan(false);
            setHasAdvancedPlan(false);
            setHasStandardPlan(false);
            setHasFreePlan(false);
            setRequiresPlan(true);
            return;
        }
        switch (subscription.plans_versions.plans.slug) {
            case 'lifetime': {
                setHasSelectedPlan(true);
                setHasLifetimePlan(true);
                setHasAdvancedPlan(false);
                setHasStandardPlan(false);
                setHasFreePlan(false);
                setRequiresPlan(true);
            }
            case 'advanced': {
                setHasSelectedPlan(true);
                setHasLifetimePlan(false);
                setHasAdvancedPlan(true);
                setHasStandardPlan(false);
                setHasFreePlan(false);
                setRequiresPlan(true);
            }
            case 'standard': {
                setHasSelectedPlan(true);
                setHasLifetimePlan(false);
                setHasAdvancedPlan(false);
                setHasStandardPlan(true);
                setHasFreePlan(false);
                setRequiresPlan(true);
            }
            default:
            case 'free': {
                setHasSelectedPlan(true);
                setHasLifetimePlan(false);
                setHasAdvancedPlan(false);
                setHasStandardPlan(false);
                setHasFreePlan(true);
                setRequiresPlan(true);
            }
        }
    }

    return {
        isLoading: loadingPlan,
        hasSelectedPlan,
        hasFreePlan,
        hasStandardPlan,
        hasAdvancedPlan,
        hasLifetimePlan,
        requiresPlan
    };
}
 
----- Archivo: useLocalStorage.tsx ----- 
// app/lib/db/hooks/useLocalStorage.tsx
import { useState, useEffect } from "react";
import CryptoJS from "crypto-js";

/**
 * Hook para manejar un valor en localStorage con encriptación opcional y hash de clave,
 * implementando hidratación para evitar lectura antes del montaje.
 * @param key Clave original para identificar item en storage.
 * @param initialValue Valor inicial si no existe valor en storage.
 * @param options.secret Secreto para encriptar/hashear clave y valor.
 * @returns [valor, setter] donde setter actualiza estado y storage.
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T,
  options?: { secret?: string }
): [T, (value: T | null) => void] {
  const secret = options?.secret || (process.env.NEXT_PUBLIC_ENABLE_ENCRYPTION == 'false' ? '' : process.env.NEXT_PUBLIC_STORAGE_SECRET!);
  // Generar clave de storage hasheada si hay secreto
  const storageKey = secret
    ? CryptoJS.SHA256(key + secret).toString()
    : key;

  // Estado del valor almacenado
  const [storedValue, setStoredValue] = useState<T>(initialValue);

  // Al hidratar, leer de localStorage
  useEffect(() => {
    try {
      const item = window.localStorage.getItem(storageKey);
      if (item === null) {
        setStoredValue(initialValue);
      } else {
        const raw = secret
          ? CryptoJS.AES.decrypt(item, secret).toString(CryptoJS.enc.Utf8)
          : item;
        setStoredValue(JSON.parse(raw) as T);
      }
    } catch {
      setStoredValue(initialValue);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storageKey, secret]);

  /**
   * Setter que guarda en estado y en localStorage (o elimina si value es null).
   */
  const setValue = (value: T | null) => {
    if (typeof window === "undefined") {
      setStoredValue(value as T);
      return;
    }
    try {
      if (value === null) {
        window.localStorage.removeItem(storageKey);
        setStoredValue(initialValue);
      } else {
        const stringValue = JSON.stringify(value);
        const encrypted = secret
          ? CryptoJS.AES.encrypt(stringValue, secret).toString()
          : stringValue;
        window.localStorage.setItem(storageKey, encrypted);
        setStoredValue(value);
      }
    } catch {
      // Ignorar errores de storage
    }
  };

  return [storedValue, setValue];
}
 
----- Archivo: useSession.tsx ----- 
// src/hooks/useSession.tsx
"use client";
import { useState, useEffect } from "react";
import { authClient, AuthSession } from "@/lib/auth";

export function useSession(): {
  session: AuthSession | null;
  setSession: (session: AuthSession) => Promise<void>;
  isLoading: boolean;
} {
  const [session, setSession] = useState<AuthSession | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    let mounted = true;

    const { data: authSubscription } = authClient.onAuthStateChange(
      (event: string, sessionState: AuthSession | null) => {
        if (mounted) {
          setSession(sessionState);

          if (event === 'INITIAL_SESSION' || event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
            if (isLoading) {
              setIsLoading(false);
            }
          }
        } else {
          console.log('hooks/useSession: onAuthStateChange FIRED but component unmounted (Full App Context).');
        }
      });

    authClient.getSession().then(currentSession => {
      if (mounted) {
        setSession(prev => JSON.stringify(prev) === JSON.stringify(currentSession) ? prev : currentSession);

        if (isLoading) {
          setIsLoading(false);
        }
      }
    }).catch(error => {
      if (mounted) {
        console.error("hooks/useSession: authClient.getSession() PROMISE REJECTED (Full App Context):", error);
        if (isLoading) {
          setIsLoading(false);
        }
      }
    });

    return () => {
      mounted = false;
      authSubscription.unsubscribe();
    };
  }, [isLoading]);

  const setAppSession = async (session: AuthSession) => {
    await authClient.setSession(session);
    setIsLoading(false);
    setSession(session);
  }

  return { session, setSession: setAppSession, isLoading };
} 
----- Archivo: i18n.ts ----- 
// src/i18n.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

import es from '../../public/locales/es/errors.json';

i18n
    .use(initReactI18next)
    .init({
        resources: {
            es: { errors: es },
        },
        lng: 'es',
        fallbackLng: 'es',
        interpolation: { escapeValue: false },
    });

export default i18n;
 
----- Archivo: index.ts ----- 
// lib/auth/index.ts
import { SupabaseAuthClient } from "./supabase/authClient";
//import { createServerClient as SupabaseServerClient } from "./supabase/serverClient"; // Usar el cliente de servidor real
import { updateSession as SupabaseUpdateSession } from "./supabase/middleware"; // Usar el middleware real
import { NextRequest, NextResponse } from "next/server"; // NextResponse añadido
import { getClientWithToken as getSupabaseClientWithToken } from "./supabase/tokenClient";
import { createServerClient as createSupabaseServerClient } from "./supabase/serverClient";
import { ReadonlyRequestCookies } from "next/dist/server/web/spec-extension/adapters/request-cookies";
import { RepositoryOptions } from "@/types/lib";
import { createBrowserClient as SupabaseCreateBrowserClient } from "./supabase/browserClient";

export type SignInResponse = { data?: { session: AuthSession; user: AuthUser } | null; error?: AuthError | null };
export type SignUpResponse = { data: { user: AuthUser | null, /* session?: AuthSession | null */ }; error: AuthError | null }; // session es opcional en signup
export type ResetPasswordResponse = { data: object | null; error: AuthError | null };
export type ServerSession = { data: { session: AuthSession; }; error: null; } | { data: { session: null; }; error: AuthError; } | { data: { session: null; }; error: null; };
export type AuthUserResponse = { data: { user: AuthUser; }; error: null; } | { data: { user: null; }; error: AuthError; };
export type AuthSession = { access_token: string; refresh_token: string; expires_in: number; expires_at?: number; token_type: string; user: AuthUser }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type AuthUser = { id: string; aud: string; user_metadata: { [key: string]: any }; confirmation_sent_at?: string; recovery_sent_at?: string; email_change_sent_at?: string; new_email?: string; new_phone?: string; invited_at?: string; action_link?: string; email?: string; phone?: string; created_at: string; confirmed_at?: string; email_confirmed_at?: string; phone_confirmed_at?: string; last_sign_in_at?: string; role?: string; updated_at?: string; is_anonymous?: boolean; is_sso_user?: boolean; };
export type AuthError = { name: string; message: string; stack?: string; code: string | undefined; status: number | undefined; details?: string; hint?: string; }


export interface BrowserAuthClient {
    getSession(): Promise<AuthSession | null>;
    onAuthStateChange(
        cb: (event: string, session: AuthSession | null) => void
    ): { data: { unsubscribe: () => void } };
    signIn(email: string, password: string): Promise<SignInResponse>;
    signOut(): Promise<void>;
    resetPassword(email: string): Promise<ResetPasswordResponse>;
    signUp(email: string, password: string, role: string): Promise<SignUpResponse>;
    setSession(session: { access_token: string; refresh_token: string; }): Promise<void>;
    inviteUser(email: string): Promise<void>;
}

export interface ServerAuthClient {
    getSession(): Promise<ServerSession>;
    getUser(jwt?: string): Promise<AuthUserResponse>;
}

const authClientImpl = new SupabaseAuthClient();
export { authClientImpl as authClient };

const createAuthServerClient = async (cookieStore: ReadonlyRequestCookies): Promise<ServerAuthClient> => {
    const serverSupabaseClient = await createSupabaseServerClient(cookieStore);
    return serverSupabaseClient;
};
export { createAuthServerClient as createServerClient };

const updateSessionImpl = async (req: NextRequest): Promise<NextResponse> => {
    return SupabaseUpdateSession(req);
}
export { updateSessionImpl as updateSession };

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const dbClientImpl = (options: RepositoryOptions): any => {
    const supabaseClient = getSupabaseClientWithToken(options);
    return supabaseClient;
};;

export { dbClientImpl as dbClient };

export { SupabaseCreateBrowserClient as createBrowserClient } 
----- Archivo: authClient.ts ----- 
// lib/auth/supabase/authClient.ts
import type { BrowserAuthClient, AuthSession, SignInResponse, SignUpResponse, ResetPasswordResponse, AuthUser } from "..";
import { createBrowserClient } from "./browserClient";

export class SupabaseAuthClient implements BrowserAuthClient {
    async getSession(): Promise<AuthSession | null> {
        const { data, error } = await createBrowserClient().auth.getSession();
        if (error) {
            console.error("Error getting session:", error);
            return null;
        }
        return data.session;
    }

    onAuthStateChange(
        cb: (event: string, session: AuthSession | null) => void
    ): { data: { unsubscribe(): void } } {
        const { data: { subscription } } = createBrowserClient().auth.onAuthStateChange((event, session) => {
            cb(event, session as AuthSession | null);
        });
        return { data: { unsubscribe: () => subscription.unsubscribe() } };
    }

    async signIn(email: string, password: string): Promise<SignInResponse> {
        const { data, error } = await createBrowserClient().auth.signInWithPassword({ email, password });
        if (error) {
            return { error };
        }
        return {
            data: data ? { session: data.session as AuthSession, user: data.user as AuthUser } : null,
        };
    }

    async signOut(): Promise<void> {
        const { error } = await createBrowserClient().auth.signOut();
        if (error) {
            console.error("Error signing out:", error);
        }
    }

    async resetPassword(email: string): Promise<ResetPasswordResponse> {
        const { data, error } = await createBrowserClient().auth.resetPasswordForEmail(email, {
            // TODO: redirectTo: 'tu-url-de-reset-password-si-es-diferente-a-la-configurada-en-supabase'
        });
        return { data, error };
    }

    async signUp(email: string, password: string, role = 'owner'): Promise<SignUpResponse> {
        const { data, error } = await createBrowserClient().auth.signUp({
            email,
            password,
            options: {
                data: { role }
            },
        });
        return {
            data: data ? { user: data.user as AuthUser | null } : { user: null },
            error,
        };
    }

    async setSession(session: { access_token: string; refresh_token: string }): Promise<void> {
        const { error } = await createBrowserClient().auth.setSession(session);
        if (error) {
            console.error("Error setting session:", error);
        }
    }

    async inviteUser(email: string): Promise<void> {
        await createBrowserClient().auth.admin.inviteUserByEmail(email)
    }
} 
----- Archivo: middleware.ts ----- 
// src/lib/auth/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth') &&
    request.nextUrl.pathname !== "/" &&
    !request.nextUrl.pathname.startsWith('/api/owners') &&
    !request.nextUrl.pathname.startsWith('/vet-access') &&
    !request.nextUrl.pathname.startsWith('/api/vet/use-code')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse
} 
----- Archivo: serverClient.ts ----- 
// lib/auth/supabase/serverClient.ts
import { createServerClient as supabaseCreateServerClient, type CookieOptions } from '@supabase/ssr';
import { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';

// Cliente Supabase para Server Components, API Routes y Middleware
export async function createServerClient(cookieStore: ReadonlyRequestCookies) {

  return (await supabaseCreateServerClient( // Usa la función importada directamente
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          // Cuando Supabase llama a esto en una Route Handler,
          // está indicando que una cookie necesita ser establecida en la RESPUESTA.
          // La instancia de `cookieStore` aquí puede ser usada para esto.
          try {
            cookieStore.set(name, value, options); // Correcto para la respuesta
            // O si la API de cookieStore requiere un objeto:
            // cookieStore.set({ name, value, ...options });
          } catch (error) {
            console.error(`SSR Error (Route Handler): Failed to set cookie ${name}`, error);
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            // Para eliminar, establece el valor a vacío y usa las opciones para expirar.
            cookieStore.set(name, '', options); // Correcto para la respuesta
            // O si la API de cookieStore requiere un objeto:
            // cookieStore.set({ name, value: '', ...options });
          } catch (error) {
            console.error(`SSR Error (Route Handler): Failed to remove cookie ${name}`, error);
          }
        },
      }
    }
  )).auth;
} 
----- Archivo: browserClient.tsx ----- 
// lib/auth/supabase/browserClient.ts
import { createBrowserClient as SupabaseCreateBrowserClient } from '@supabase/ssr';

export function createBrowserClient() {
  return SupabaseCreateBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { // Añadir opciones explícitas
      auth: {
        persistSession: true, // Forzar la persistencia, aunque es el default
        autoRefreshToken: true, // Default, bueno tenerlo explícito
        // detectSessionInUrl: true, // Default, para manejar tokens en hash de URL
      }
    }
  );
} 
----- Archivo: tokenClient.tsx ----- 
// lib/auth/supabase/tokenClient.ts
import { RepositoryOptions } from "@/types/lib";
import { Cookies } from "@/utils/index";
import { createClient } from "@supabase/supabase-js";

export function getClientWithToken(options: RepositoryOptions) {
    return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        (options.cookies && !Cookies.isVetAccessFromCookie(options.cookies)) ? {
            global: { headers: { Authorization: `Bearer ${Cookies.getAccessTokenFromCookie(options.cookies)}` } }
        } : {}
    );
} 
----- Archivo: basicData.repository.ts ----- 
// src/repositories/basicData.repository.ts
import { dbClient } from '@/lib/auth';
import type { BasicDataType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class BasicDataRepository {
  static async upsert(basicData: BasicDataType, options: RepositoryOptions) {
    const { data, error } = await dbClient(options).from('basic_data')
      .upsert(basicData, { onConflict: 'pet_id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  static async findByPetId(pet_id: string, options: RepositoryOptions): Promise<BasicDataType | null> {
    const { data, error } = await dbClient(options).from('basic_data').select('*').eq('pet_id', pet_id);
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  static async update(data: BasicDataType, options: RepositoryOptions) {
    return dbClient(options).from('basic_data').update(data).eq('pet_id', data.pet_id);
  }
}
 
----- Archivo: comvezcol.repository.ts ----- 
// src/repository/comvezcol.repository.ts

import axios, { AxiosResponse } from 'axios';
import * as cheerio from 'cheerio';
import type { CheerioAPI } from 'cheerio';
import type { RepositoryResponse } from '@/types/lib'; // Asumo que tienes un tipo como este
import type { ProfessionalData } from '@/types/index'; // Asumo que moverías la interfaz a un archivo central de tipos

// Mueve la interfaz a tu archivo de tipos (ej: src/types/index.ts)
// export interface ProfessionalData { ... }

const dataMapping: Record<string, keyof Omit<ProfessionalData, 'foto' | 'estado' | 'matriculaBuscada'>> = {
    'Nombre': 'nombres',
    'Apellidos': 'apellidos',
    'Titulo Obtenido': 'tituloObtenido',
    'Universidad': 'universidad',
    'Matricula No.': 'numeroMatricula',
    'Acta de grado No.': 'actaGrado',
};

class ComvezcolRepository {
    private static BASE_URL = 'https://administrador.consejoapp.com.co';

    public static async validate(matricula: string): Promise<RepositoryResponse<ProfessionalData>> {
        const SEARCH_ACTION_URL = `${this.BASE_URL}/index.php/consultas/profesionalesS`;

        try {
            const searchResponse: AxiosResponse<string> = await axios.post(SEARCH_ACTION_URL, { matricula }, {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            });

            const $resultsPage: CheerioAPI = cheerio.load(searchResponse.data);
            const detailLink = $resultsPage('table.table a.btn-success').attr('href');

            if (!detailLink) {
                return { data: null, error: { message: `No se encontró profesional con matrícula ${matricula}.`, status: 404 } };
            }

            const detailResponse = await axios.get(detailLink);
            const $detailPage = cheerio.load(detailResponse.data);

            const professionalData: Partial<ProfessionalData> = {};
            const fotoSrc = $detailPage('.col-sm-12.col-lg-4 img').attr('src');
            if (fotoSrc) {
                professionalData.foto = fotoSrc.startsWith('http') ? fotoSrc : `${this.BASE_URL}${fotoSrc}`;
            }

            $detailPage('.table-bordered tbody tr').each((_, element) => {
                const th = $detailPage(element).find('th').text().trim();
                const td = $detailPage(element).find('td').text().trim();
                const key = dataMapping[th];
                if (key) professionalData[key] = td;
            });

            professionalData.estado = Object.keys(professionalData).length > 2 ? 'Habilitado' : 'Desconocido';
            professionalData.matriculaBuscada = matricula;

            return { data: professionalData as ProfessionalData, error: null };

        } catch (error) {
            console.error(`Error en el scraping para la matrícula ${matricula}:`, error);
            const message = error instanceof Error ? error.message : 'Error interno del servidor';
            return { data: null, error: { message, status: 500 } };
        }
    }
}

export default ComvezcolRepository; 
----- Archivo: condition.repository.ts ----- 
// src/repositories/condition.repository.ts
import { dbClient } from '@/lib/auth';
import type { ConditionDataType } from '@/types/index';
import { FormRepository, RepositoryOptions } from '@/types/lib';

export default class ConditionRepository implements FormRepository<ConditionDataType> {
    async createAll(conditions: ConditionDataType[], options: RepositoryOptions) {
        const { data, error } = await dbClient(options)
            .from('conditions')
            .upsert(conditions, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string, options: RepositoryOptions): Promise<ConditionDataType[] | null> {
        const { data, error } = await dbClient(options).from('conditions').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string, options: RepositoryOptions) {
        try {
            const currentTimestamp = new Date().toISOString();
            await dbClient(options).from('conditions').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch(err) {
            console.log(err);
            return false;
        }
    }
}
 
----- Archivo: consultation.repository.ts ----- 
// src/repos/consultation.repository.ts
import { dbClient } from '@/lib/auth';
import type { ConsultationType, CreateConsultationPayload } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class ConsultationRepository {
    static async create(payload: CreateConsultationPayload, options: RepositoryOptions): Promise<{ data: ConsultationType | null; error: Error | null }> {
        // Separar los campos principales para el JSONB y los arrays
        const {
            pet_id, // Este va como parámetro separado
            veterinarian_id, // Este va como parámetro separado
            veterinary_access_id, // Este va como parámetro separado
            procedures, // Este va como parámetro de array separado
            medications, // Este va como parámetro de array separado
            ...consultation_data_fields // El resto va en el JSONB
        } = payload;

        // El objeto `consultation_data_fields` ya debería tener la estructura correcta
        // si `CreateConsultationPayload` se define adecuadamente.
        // Asegúrate de que las claves en `consultation_data_fields` coincidan con los
        // nombres de campo en tu `CREATE TYPE public.consultation_input_type AS (...)`.
        // Por ejemplo, si tu tipo tiene `consultation_date DATE`, tu objeto JS debe tener una clave `consultation_date`.

        // Sanitización: Asegurar que los campos opcionales que no se envían sean null,
        // y que los tipos de datos sean compatibles con lo que espera el tipo compuesto.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const mainConsultDataForRPC: { [key: string]: any } = {};
        const typeFields = [ // Lista de campos definidos en consultation_input_type
            'p_consultation_date', 'p_consultation_time', 'p_hc_number', 'p_institution_name',
            'p_reason_for_consultation', 'p_current_diet', 'p_previous_illnesses', 'p_previous_surgeries',
            'p_vaccination_history', 'p_last_deworming_product', 'p_recent_treatments', 'p_recent_travels',
            'p_animal_behavior_owner_description', 'p_lives_with_other_animals_details',
            'p_sterilized_status', 'p_birth_count', 'p_body_condition_score', 'p_temperature_celsius',
            'p_heart_rate_bpm', 'p_respiratory_rate_rpm', 'p_capillary_refill_time_sec', 'p_pulse_description',
            'p_mucous_membranes_description', 'p_hydration_percentage_description', 'p_sense_organs_description',
            'p_skin_and_coat_description', 'p_lymph_nodes_description', 'p_digestive_system_findings',
            'p_respiratory_system_findings', 'p_endocrine_system_findings', 'p_musculoskeletal_system_findings',
            'p_nervous_system_findings', 'p_urinary_system_findings', 'p_reproductive_system_findings',
            'p_rectal_palpation_findings', 'p_other_physical_findings', 'p_problem_list', 'p_master_problem_list',
            'p_differential_diagnoses', 'p_complementary_exams_summary', 'p_presumptive_diagnosis',
            'p_definitive_diagnosis', 'p_therapeutic_plan', 'p_prognosis', 'p_evolution_notes',
            'p_general_observations', 'p_signature_confirmation'
        ];

        for (const key of typeFields) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const value = (consultation_data_fields as any)[key.replace('p_', '')];
            if (value === undefined || value === '') {
                // Para campos numéricos o de fecha que son opcionales, un string vacío puede causar error en el CAST de SQL.
                // Es mejor enviar `null` si el campo es opcional y está vacío.
                if (['p_birth_count', 'p_body_condition_score', 'p_temperature_celsius', /* otros numéricos/fecha */].includes(key) && value === '') {
                    mainConsultDataForRPC[key] = null;
                } else if (value === undefined) {
                    mainConsultDataForRPC[key] = null;
                } else {
                    mainConsultDataForRPC[key] = value; // Mantener string vacío si el tipo SQL es TEXT y se permite
                }
            } else {
                mainConsultDataForRPC[key] = value;
            }
        }

        const proceduresForRPC = procedures?.map(p => ({
            procedure_name: p.procedure_name,
            description: p.description ?? null
        })) || [];

        const medicationsForRPC = medications?.map(m => ({
            medication_name: m.medication_name,
            dosage: m.dosage,
            frequency: m.frequency,
            duration_days: m.duration_days ?? null,
            notes: m.notes ?? null
        })) || [];

        const rpcParams = {
            p_pet_id: pet_id,
            p_veterinarian_id: veterinarian_id || null,
            p_veterinary_access_id: veterinary_access_id || null,
            p_consultation_main_data: mainConsultDataForRPC, 
            p_procedures: proceduresForRPC,
            p_medications: medicationsForRPC
        };

        try {
            const { data, error } = await dbClient(options).rpc('insert_consultation_with_type', rpcParams);

            if (error) throw error;

            return { data: data as ConsultationType, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.create (RPC call):', error);
            return { data: null, error: new Error(error.message || 'RPC call to insert_consultation_with_type failed') };
        }

    }

    // ... (tus otros métodos findByPetId, findById) ...
    static async findByPetId(petId: string, options: RepositoryOptions): Promise<{ data: ConsultationType[] | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .from('consultations')
                .select(`
                *,
                procedures:consultation_procedures(*),
                medications:consultation_medications(*),
                files:consultation_files(*)
            `)
                .eq('pet_id', petId)
                .order('consultation_date', { ascending: false, nullsFirst: false })
                .order('consultation_time', { ascending: false, nullsFirst: false });


            if (error) throw error;
            return { data, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.findByPetId:', error);
            return { data: null, error };
        }
    }

    static async findById(consultationId: string, options: RepositoryOptions): Promise<{ data: ConsultationType | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .from('consultations')
                .select(`
                *,
                procedures:consultation_procedures(*),
                medications:consultation_medications(*),
                files:consultation_files(*)
            `)
                .eq('id', consultationId)
                .single();

            if (error) throw error;
            return { data, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationRepository.findById:', error);
            return { data: null, error };
        }
    }
} 
----- Archivo: consultationFile.repository.ts ----- 
// src/repos/consultationFile.repository.ts
import { dbClient } from '@/lib/auth';
import type { ConsultationFileType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

const CONSULTATION_FILES_BUCKET = 'consultation-files'; // Define tu bucket

export default class ConsultationFileRepository {
    static async uploadAndCreateRecord(
        consultationId: string,
        petId: string, // Necesario para la ruta del archivo
        file: File,
        options: RepositoryOptions,
        uploadedByUserId?: string | null
    ): Promise<{ data: ConsultationFileType | null; error: Error | null }> {
        const fileName = `${file.name}`; // Podrías añadir un timestamp o UUID para unicidad
        const filePath = `${petId}/${consultationId}/${fileName}`;

        try {
            // 1. Subir archivo a Supabase Storage
            const { error: uploadError } = await dbClient(options).storage
                .from(CONSULTATION_FILES_BUCKET)
                .upload(filePath, file);

            if (uploadError) throw uploadError;

            // 2. Crear registro en la tabla consultation_files
            const fileRecord: Omit<ConsultationFileType, 'id' | 'created_at'> = {
                consultation_id: consultationId,
                file_name: fileName,
                file_path: filePath,
                file_type: file.type,
                file_size_bytes: file.size,
                uploaded_by_user_id: uploadedByUserId || undefined,
            };

            const { data: dbData, error: dbError } = await dbClient(options)
                .from('consultation_files')
                .insert(fileRecord)
                .select()
                .single();

            if (dbError) {
                // Si falla la inserción en BD, intentar eliminar el archivo de Storage (rollback)
                await dbClient(options).storage.from(CONSULTATION_FILES_BUCKET).remove([filePath]);
                throw dbError;
            }

            return { data: dbData, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.uploadAndCreateRecord:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string, options: RepositoryOptions): Promise<{ data: ConsultationFileType[] | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .from('consultation_files')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }

    static async delete(fileId: string, options: RepositoryOptions): Promise<{ error: Error | null }> {
        try {
            // 1. Obtener el path del archivo para eliminarlo de Storage
            const { data: fileRecord, error: findError } = await dbClient(options)
                .from('consultation_files')
                .select('file_path')
                .eq('id', fileId)
                .single();

            if (findError) throw findError;
            if (!fileRecord) throw new Error('File record not found for deletion.');

            // 2. Eliminar de la base de datos
            const { error: dbDeleteError } = await dbClient(options)
                .from('consultation_files')
                .delete()
                .eq('id', fileId);

            if (dbDeleteError) throw dbDeleteError;

            // 3. Eliminar de Supabase Storage
            const { error: storageDeleteError } = await dbClient(options).storage
                .from(CONSULTATION_FILES_BUCKET)
                .remove([fileRecord.file_path]);

            // Incluso si la eliminación de storage falla, el registro en BD ya se fue.
            // Podrías loggear el error de storage.
            if (storageDeleteError) {
                console.warn('Failed to delete file from storage, but DB record removed:', storageDeleteError);
            }

            return { error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationFileRepository.delete:', error);
            return { error };
        }
    }

    /**
     * Genera una URL firmada para descargar un archivo.
     * La URL tiene un tiempo de expiración.
     */
    static async getSignedUrl(filePath: string, options: RepositoryOptions, expiresInSeconds = 3600): Promise<{ signedURL: string | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .storage
                .from(CONSULTATION_FILES_BUCKET)
                .createSignedUrl(filePath, expiresInSeconds);

            if (error) throw error;
            return { signedURL: data?.signedUrl || null, error: null };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error creating signed URL:', error);
            return { signedURL: null, error };
        }
    }

    static async getFile(fileId: string, options: RepositoryOptions) {
        const { data: fileRecord, error: findError } = await dbClient(options)
            .from('consultation_files')
            .select('file_path')
            .eq('id', fileId)

        if (findError) throw new Error(findError.message);
        if (!fileRecord || fileRecord.length === 0) return null;
        return fileRecord[0];
    }
} 
----- Archivo: consultationMedication.repository.ts ----- 
// src/repos/consultationMedication.repository.ts
import { dbClient } from '@/lib/auth';
import type { ConsultationMedicationType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class ConsultationMedicationRepository {
    static async createAll(
        consultationId: string,
        medications: Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>[], 
        options: RepositoryOptions
    ): Promise<{ data: ConsultationMedicationType[] | null; error: Error | null }> {
        const medicationsToInsert = medications.map(med => ({
            ...med,
            consultation_id: consultationId,
        }));

        try {
            const { data, error } = await dbClient(options)
                .from('consultation_medications')
                .insert(medicationsToInsert)
                .select();

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.createAll:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string, options: RepositoryOptions): Promise<{ data: ConsultationMedicationType[] | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .from('consultation_medications')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }
     static async delete(medicationId: string, options: RepositoryOptions): Promise<{ error: Error | null }> {
        try {
            const { error } = await dbClient(options)
                .from('consultation_medications')
                .delete()
                .eq('id', medicationId);

            if (error) throw error;
            return { error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationMedicationRepository.delete:', error);
            return { error };
        }
    }
} 
----- Archivo: consultationProcedure.repository.ts ----- 
// src/repos/consultationProcedure.repository.ts
import { dbClient } from '@/lib/auth';
import type { ConsultationProcedureType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class ConsultationProcedureRepository {
    static async createAll(
        consultationId: string,
        procedures: Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>[],
        options: RepositoryOptions
    ): Promise<{ data: ConsultationProcedureType[] | null; error: Error | null }> {
        const proceduresToInsert = procedures.map(proc => ({
            ...proc,
            consultation_id: consultationId,
        }));

        try {
            const { data, error } = await dbClient(options)
                .from('consultation_procedures')
                .insert(proceduresToInsert)
                .select();

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.createAll:', error);
            return { data: null, error };
        }
    }

    static async findByConsultationId(consultationId: string, options: RepositoryOptions): Promise<{ data: ConsultationProcedureType[] | null; error: Error | null }> {
        try {
            const { data, error } = await dbClient(options)
                .from('consultation_procedures')
                .select('*')
                .eq('consultation_id', consultationId)
                .order('created_at', { ascending: true });

            if (error) throw error;
            return { data, error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.findByConsultationId:', error);
            return { data: null, error };
        }
    }

    static async delete(procedureId: string, options: RepositoryOptions): Promise<{ error: Error | null }> {
        try {
            const { error } = await dbClient(options)
                .from('consultation_procedures')
                .delete()
                .eq('id', procedureId);

            if (error) throw error;
            return { error: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (error: any) {
            console.error('Error in ConsultationProcedureRepository.delete:', error);
            return { error };
        }
    }
} 
----- Archivo: index.ts ----- 
export { default as BasicDataRepository } from './basicData.repository';
export { default as ConditionRepository } from './condition.repository';
export { default as LabTestRepository } from './labTest.repository';
export { default as MedicineRepository } from './medicine.repository';
export { default as OwnerRepository } from './owner.repository';
export { default as PetRepository } from './pet.repository';
export { default as PetCodeRepository } from './petCode.repository';
export { default as PlanRepository } from './plan.repository';
export { default as SubscriptionRepository } from './subscription.repository';
export { default as SurgeryRepository } from './surgery.repository';
export { default as VaccineRepository } from './vaccine.repository';
export { default as VeterinaryAccessRepository } from './veterinaryAccess.repository';

export { default as ConsultationRepository } from './consultation.repository';
export { default as ConsultationProcedureRepository } from './consultationProcedure.repository';
export { default as ConsultationMedicationRepository } from './consultationMedication.repository';
export { default as ConsultationFileRepository } from './consultationFile.repository'; 
----- Archivo: labTest.repository.ts ----- 
// src/repositories/labTest.repository.ts
import { dbClient } from '@/lib/auth';
import type { LabTestDataType } from '@/types/index';
import { FormRepository, RepositoryOptions } from '@/types/lib';

export default class LabTestRepository implements FormRepository<LabTestDataType> {
    async createAll(tests: LabTestDataType[], options: RepositoryOptions) {
        const { data, error } = await dbClient(options)
            .from('lab_tests')
            .upsert(tests, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string, options: RepositoryOptions): Promise<LabTestDataType[] | null> {
        const { data, error } = await dbClient(options).from('lab_tests').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string, options: RepositoryOptions) {
        try {
            const currentTimestamp = new Date().toISOString();
            await dbClient(options).from('lab_tests').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: medicine.repository.ts ----- 
// src/repositories/medicine.repository.ts
import { dbClient } from '@/lib/auth';
import type { MedicineDataType } from '@/types/index';
import { FormRepository, RepositoryOptions } from '@/types/lib';

export default class MedicineRepository implements FormRepository<MedicineDataType> {
    async createAll(medicines: MedicineDataType[], options: RepositoryOptions) {
        const { data, error } = await dbClient(options)
            .from('medicines')
            .upsert(medicines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string, options: RepositoryOptions): Promise<MedicineDataType[] | null> {
        const { data, error } = await dbClient(options).from('medicines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string, options: RepositoryOptions) {
        try {
            const currentTimestamp = new Date().toISOString();
            await dbClient(options).from('medicines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: owner.repository.ts ----- 
// src/repositories/owner.repository.ts
import { createBrowserClient, dbClient } from '@/lib/auth';
import type { OwnerDataType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class OwnerRepository {
    static async create(owner: OwnerDataType) {
        return createBrowserClient().from('owners').insert(owner);
    }

    static async findById(owner_id: string, options: RepositoryOptions): Promise<OwnerDataType | null> {
        if (owner_id == undefined) {
            return null;
        }
        const { data, error } = await dbClient(options).from('owners').select('*').eq('owner_id', owner_id);
        if (error) throw new Error(error.message);
        if (!data || data.length === 0) return null;
        return data[0];
    }

    static async findByPetId(pet_id: string, options: RepositoryOptions): Promise<OwnerDataType | null> {
        if (!pet_id) return null;
        // Join: pets → owners
        const { data, error } = await dbClient(options)
            .from('pets')
            .select('owner_id, owners:owner_id(*)')
            .eq('id', pet_id);

        if (error) throw new Error(error.message);
        if (!data || data.length === 0 || !data[0].owners) return null;
        return data[0].owners as OwnerDataType;
    }

    static async update(owner: OwnerDataType, options: RepositoryOptions) {
        return dbClient(options).from('owners').update(owner).eq('owner_id', owner.owner_id);
    }

    static async delete(owner_id: string, options: RepositoryOptions) {
        return dbClient(options).from('owners').delete().eq('owner_id', owner_id);
    }
}
 
----- Archivo: pet.repository.ts ----- 
// src/repositories/pet.repository.ts
import { dbClient } from "@/lib/auth";
import { PetType } from "@/types/index";
import { RepositoryOptions } from "@/types/lib";

export default class PetRepository {
  static async upsert(pet: PetType, options: RepositoryOptions) {
    const { data, error } = await dbClient(options).from('pets')
      .upsert(pet, { onConflict: 'id' })
      .select();

    if (error) console.error('Upsert failed:', error);
    else console.log('Upserted rows:', data);
    return { data, error };
  }

  /** Busca la mascota por ID */
  static async findById(id: string, options: RepositoryOptions): Promise<PetType> {
    const { data, error } = await dbClient(options)
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("id", id)
      .single();
    if (error) throw new Error(error.message);
    return data;
  }
  /** Busca la mascota por ID */
  static async existsById(id: string, options: RepositoryOptions): Promise<boolean> {
    const { data, error } = await dbClient(options)
      .from("pets")
      .select("*", { count: 'exact', head: true })
      .eq("deleted", false)
      .eq("id", id);
    if (error) throw new Error(error.message);
    return data != null;
  }

  /** Actualiza campos de la mascota */
  static async updateById(
    id: string,
    updates: Partial<Pick<PetType, "image" | "name">>, 
    options: RepositoryOptions
  ): Promise<boolean> {
    const { data, error } = await dbClient(options)
      .from("pets")
      .update(updates)
      .eq("id", id);
    if (error) throw new Error(error.message);
    if (!data) return false;
    return true;
  }

  /** Verifica que el usuario loggeado y la mascota seleccionada se encuentren en la base de datos  */
  static async findByOwnerIdAndPetId(ownerId: string, pet_id: string, options: RepositoryOptions): Promise<{ id: string } | null> {
    const { data, error } = await dbClient(options)
      .from("pets")
      .select("id")
      .eq("deleted", false)
      .eq("owner_id", ownerId)
      .eq("id", pet_id);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data[0];
  }

  /** Retorna la primera mascota del owner, o null */
  static async findByOwnerId(ownerId: string, options: RepositoryOptions): Promise<PetType[]> {
    const { data, error } = await dbClient(options)
      .from("pets")
      .select("*")
      .eq("deleted", false)
      .eq("owner_id", ownerId);

    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return [];

    // Devolvemos la primera mascota (puedes adaptar si quieres soportar varias)
    return data ?? [];
  }

  /**
   * Marca una mascota como eliminada (soft delete).
   * @param id ID de la mascota a borrar
   * @returns true si la operación no falló
   */
  static async deleteById(id: string, options: RepositoryOptions): Promise<boolean> {
    const now = new Date().toISOString();
    try {
      const { error } = await dbClient(options)
        .from("pets")
        .update({ deleted: true, deleted_at: now })
        .eq("id", id);

      if (error) {
        console.error("Error al eliminar mascota:", error);
        throw new Error(error.message);
      }
      return true;
    }
    catch {
      return false;
    }
  }
} 
----- Archivo: petCode.repository.ts ----- 
// src/repositories/petCode.repository.ts
import { createBrowserClient, dbClient } from "@/lib/auth";
import { PetCodeType } from "@/types/index";
import { RepositoryOptions } from "@/types/lib";
import { Random } from "@/utils/index";

export default class PetCodeRepository {
  /** Busca un código activo */
  static async find(code: string, options: RepositoryOptions | undefined = undefined): Promise<PetCodeType | null> {
    //TODO: Review  removal of .overrideTypes<PetCodeType[], { merge: false }>();
    const { data, error } = await (options? dbClient(options): createBrowserClient())
      .from("pet_codes")
      .select("*")
      .eq("code", code);
    if (error) throw new Error(error.message);
    if (!data || data.length === 0) return null;
    return data[0];
  }

  /** Invalida (marca used=true) todos los códigos previos de una mascota */
  static async invalidateAll(petId: string, options: RepositoryOptions): Promise<void> {
    const { error } = await dbClient(options)
      .from("pet_codes")
      .delete()
      .eq("pet_id", petId);
    if (error) throw new Error(error.message);
  }

  /** Genera e inserta un nuevo código, devolviéndolo */
  static async create(
    petId: string,
    ttlMinutes: number, 
    options: RepositoryOptions
  ): Promise<string> {
    const code = Random.generateCode();
    const expiresAt = new Date(Date.now() + ttlMinutes * 60_000).toISOString();
    const { error } = await dbClient(options)
      .from("pet_codes")
      .insert({ pet_id: petId, code, expires_at: expiresAt });
    if (error) throw new Error(error.message);
    return code;
  }

  /** Marca un código como usado */
  static async markUsed(code: string): Promise<void> {
    const { error } = await createBrowserClient()
      .from("pet_codes")
      .update({ used: true })
      .eq("code", code);
    if (error) throw new Error(error.message);
  }
}
 
----- Archivo: plan.repository.ts ----- 
// src/repositories/plan.repository.ts
import { PlanVersionType } from '../types/index';
import { dbClient } from '@/lib/auth';
import { RepositoryOptions } from '@/types/lib';

export default class PlanRepository {
  /**
   * Trae todas las versiones vigentes (effective_to IS NULL)
   */
  static async getAllCurrent(options: RepositoryOptions): Promise<PlanVersionType[]> {
    const { data, error } = await dbClient(options)
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)

    if (error) throw error
    // Mapear para llevar slug al root
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return data.map((row: any) => ({
      ...row,
      slug: row.plans.slug
    }))
  }

  /**
   * Busca la versión actual de un plan por su slug
   */
  static async getBySlug(slug: string, options: RepositoryOptions): Promise<PlanVersionType | null> {
    //TODO: Review  .overrideTypes<PlanVersionType[], { merge: false }>()
    const { data, error } = await dbClient(options)
      .from('plans_versions')
      .select(`
        id,
        plan_id,
        version,
        title,
        description,
        price_month,
        price_year,
        discount_month,
        discount_year,
        features,
        effective_from,
        effective_to,
        plans (
          slug
        )
      `)
      .is('effective_to', null)
      .eq('plans.slug', slug)

    if (error) {
      if (error.code === 'PGRST116') return null // sin datos
      throw error
    }

    return {
      ...data[0],
      slug: data[0].plans.slug
    }
  }

  /**
   * Trae todas las versiones históricas de un plan
   */
  static async getVersions(planId: number, options: RepositoryOptions): Promise<PlanVersionType[]> {
    const { data, error } = await dbClient(options)
      .from('plans_versions')
      .select('*')
      .eq('plan_id', planId)
      .order('version', { ascending: false })

    if (error) throw error
    return data
  }
}
 
----- Archivo: subscription.repository.ts ----- 
// src/repositories/subscription.repository.ts
import { dbClient } from '@/lib/auth';
import { CreateSubscriptionType, SubscriptionType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class SubscriptionRepository {
    /**
     * Crea una suscripción en estado pending
     */
    static async create(params: CreateSubscriptionType, options: RepositoryOptions): Promise<SubscriptionType | null> {
        const { data, error } = await dbClient(options)
            .from('subscriptions')
            .insert([{
                user_id: params.ownerId,
                plan_version_id: params.planVersionId,
                cycle: params.cycle,
                status: params.planVersionId == parseInt(process.env.FREE_PLAN ?? "0") ? 'active' : 'pending',
                price_at_purchase: params.priceAtPurchase,
                discount_applied: params.discountApplied
            }])
            .select(
                `*,
                plans_versions (
                    plans (
                        slug
                    )
                )`)

        if (error) throw error;
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Obtiene la suscripción activa de un owner
     */
    static async getActiveByOwner(ownerId: string, options: RepositoryOptions): Promise<SubscriptionType | null> {
        const { data, error } = await dbClient(options)
            .from('subscriptions')
            .select(
                `*,
                plans_versions (
                    plans (
                        slug
                    )
                )`)
            .eq('user_id', ownerId)
            .eq('status', 'active')

        if (error) {
            if (error.code === 'PGRST116') return null
            throw error
        }
        if (!data || data.length === 0) return null;
        return data[0];
    }

    /**
     * Lista todas las suscripciones de un owner
     */
    static async getByOwner(ownerId: string, options: RepositoryOptions): Promise<SubscriptionType[] | null> {
        const { data, error } = await dbClient(options)
            .from('subscriptions')
            .select('*')
            .eq('user_id', ownerId)
            .order('started_at', { ascending: false })

        if (error) throw error
        if (!data || data.length === 0) return null;
        return data
    }

    /**
     * Actualiza el estado y fechas de una suscripción
     */
    static async updateStatus(params: {
        subscriptionId: number
        status: 'active' | 'canceled' | 'expired'
        externalId?: string
        expiresAt?: string
    }, options: RepositoryOptions): Promise<SubscriptionType | null> {
        const { data, error } = await dbClient(options)
            .from('subscriptions')
            .update({
                status: params.status,
                external_id: params.externalId,
                expires_at: params.expiresAt,
                updated_at: new Date().toISOString()
            })
            .eq('id', params.subscriptionId)
            .select()

        if (error) throw error

        if (!data || data.length === 0) return null;
        return data[0]
    }
}
 
----- Archivo: surgery.repository.ts ----- 
// src/repositories/surgery.repository.ts
import { dbClient } from '@/lib/auth';
import type { SurgeryDataType } from '@/types/index';
import { FormRepository, RepositoryOptions } from '@/types/lib';

export default class SurgeryRepository implements FormRepository<SurgeryDataType> {
    async createAll(surgeries: SurgeryDataType[], options: RepositoryOptions) {
        const { data, error } = await dbClient(options)
            .from('surgeries')
            .upsert(surgeries, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string, options: RepositoryOptions): Promise<SurgeryDataType[] | null> {
        const { data, error } = await dbClient(options).from('surgeries').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string, options: RepositoryOptions) {
        try {
            const currentTimestamp = new Date().toISOString();
            await dbClient(options).from('surgeries').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: vaccine.repository.ts ----- 
// src/repositories/vaccine.repository.ts
import { dbClient } from '@/lib/auth';
import type { VaccineDataType } from '@/types/index';
import { FormRepository, RepositoryOptions } from '@/types/lib';

export default class VaccineRepository implements FormRepository<VaccineDataType> {
    async createAll(vaccines: VaccineDataType[], options: RepositoryOptions) {
        const { data, error } = await dbClient(options)
            .from('vaccines')
            .upsert(vaccines, { onConflict: 'id' })
            .select();

        if (error) console.error('Upsert failed:', error);
        else console.log('Upserted rows:', data);
        return { data, error };
    }

    async findByParentId(parent_id: string, options: RepositoryOptions): Promise<VaccineDataType[] | null> {
        const { data, error } = await dbClient(options).from('vaccines').select('*').eq('deleted', false).eq('pet_id', parent_id);
        if (error) throw new Error(error.message);
        if (!data) return null;
        return data;
    }

    async delete(id: string, options: RepositoryOptions) {
        try {
            const currentTimestamp = new Date().toISOString();
            await dbClient(options).from('vaccines').update({ deleted: true, deleted_at: currentTimestamp }).eq('id', id);
            return true;
        }
        catch {
            return false;
        }
    }
}
 
----- Archivo: veterinarian.repository.ts ----- 
// src/repositories/veterinarian.repository.ts
import { dbClient } from '@/lib/auth';
import type { VeterinarianType } from '@/types/index';
import { RepositoryOptions } from '@/types/lib';

export default class VeterinarianRepository {
    /** Inserta un nuevo veterinario */
    static async create(vet: VeterinarianType, options: RepositoryOptions) {
        return dbClient(options).from('veterinarians').insert(vet);
    }

    /** Busca un veterinario por su ID */
    static async findById(vet_id: string, options: RepositoryOptions): Promise<VeterinarianType | null> {
        if (!vet_id) return null;
        const { data, error } = await dbClient(options)
            .from('veterinarians')
            .select('*')
            .eq('vet_id', vet_id);
        if (error) throw new Error(error.message);
        return data && data.length > 0 ? data[0] : null;
    }

    /** Actualiza todos los campos de un veterinario */
    static async update(vet: VeterinarianType, options: RepositoryOptions) {
        return dbClient(options)
            .from('veterinarians')
            .update(vet)
            .eq('vet_id', vet.vet_id);
    }

    /** Elimina un veterinario por su ID */
    static async delete(vet_id: string, options: RepositoryOptions) {
        return dbClient(options)
            .from('veterinarians')
            .delete()
            .eq('vet_id', vet_id);
    }
}
 
----- Archivo: veterinaryAccess.repository.ts ----- 
// src/repositories/veterinaryAccess.repository.ts
import { createBrowserClient, dbClient } from "@/lib/auth";
import { RepositoryOptions } from "@/types/lib";
import { VeterinaryAccessType } from "../types";
import PetCodeRepository from "./petCode.repository";

export default class VeterinaryAccessRepository {
    /** Registra un nuevo acceso de veterinario */
    static async create(access: Omit<
        VeterinaryAccessType,
        "id" | "created_at"
    >, options: RepositoryOptions | undefined = undefined): Promise<VeterinaryAccessType> {
        const { data, error } = await (options? dbClient(options): createBrowserClient())
            .from("veterinary_accesses")
            .insert(access)
            .select("*")
            .single();

        if (error) throw new Error(error.message);
        return data;
    }

    /** Obtiene datos de acceso por código (para validaciones o historial) */
    static async findByCodeAndByPetId(
        code: string,
        pet_id: string, 
        options: RepositoryOptions
    ): Promise<VeterinaryAccessType | null> {
        try {
            const petCode = await PetCodeRepository.find(code, options);
            if (!petCode) return null;
            const { data, error } = await dbClient(options)
                .from("veterinary_accesses")
                .select("*")
                .eq("pet_code_id", petCode.id)
                .eq("pet_id", pet_id)


            if (error) throw new Error(error.message);
            if (!data || data.length === 0) return null;
            return data[0];
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        catch (errCode: any) {
            if (errCode) throw new Error(errCode.message);
            return null;
        }

    }
}
 
----- Archivo: validationSchemas.ts ----- 
// src/schemas/validationSchemas.ts
import { z } from 'zod';

// PetType
export const PetTypeSchema = z.object({
  id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  image: z.string().nullable().optional(),
  birth_date: z.string().optional(),
  owner_id: z.string(),
});

// PetCodeType
export const PetCodeTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  code: z.string(),
  used: z.boolean(),
  expires_at: z.string(),
});

// OwnerDataType
export const OwnerDataTypeSchema = z.object({
  owner_id: z.string(),
  name: z.string(),
  last_name: z.string(),
  phone: z.string(),
  address: z.string(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  city: z.string(),
  country: z.string(),
  email: z.string(),
});

// BasicDataType
export const BasicDataTypeSchema = z.object({
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  pet_type: z.string(),
  gender: z.string(),
  weight: z.string(),
  race: z.string(),
  coat_type: z.string(),
  color: z.string(),
  has_allergies: z.boolean(),
  weight_condition: z.string(),
  size: z.string(),
  lives_with_others: z.boolean(),
  main_food: z.string(),
  has_vaccine: z.boolean(),
  last_vaccine_name: z.string().optional().nullable(),
  last_vaccine_date: z.string().optional().nullable(),
  is_sterilized: z.boolean(),
  sterilization_date: z.string().optional().nullable(),
  has_anti_flea: z.boolean(),
  anti_flea_date: z.string().optional().nullable(),
  uses_medicine: z.boolean(),
  special_condition: z.boolean(),
});

// InitialBasicDataType
export const InitialBasicDataTypeSchema = z.object({
  petType: z.string(),
  food: z.string(),
  race: z.string(),
  otherPetType: z.string(),
  otherFood: z.string(),
  otherRace: z.string(),
});

// VaccineDataType
export const VaccineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  description: z.string().optional().nullable(),
  date: z.string().optional().nullable(),
  batch: z.string(),
  brand: z.string(),
});

// SurgeryDataType
export const SurgeryDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  date: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
});

// MedicineDataType
export const MedicineDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  dosage: z.string(),
  frequency: z.string(),
});

// ConditionDataType
export const ConditionDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string(),
  condition: z.string(),
  severity: z.string(),
});

// LabTestDataType
export const LabTestDataTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  name: z.string(),
  type: z.string(),
  date: z.string().optional().nullable(),
  result: z.string().optional().nullable(),
});

// VeterinaryAccessType
export const VeterinaryAccessTypeSchema = z.object({
  id: z.string(),
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  pet_code_id: z.string(),
  vet_first_name: z.string(),
  vet_first_last_name: z.string(),
  vet_second_last_name: z.string(),
  identification: z.string(),
  professional_registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
  created_at: z.string(),
});

//Veterinarian
export const VeterinarianTypeSchema = z.object({
  vet_id: z.string().uuid(),
  first_name: z.string(),
  first_last_name: z.string(),
  second_last_name: z.string(),
  identification: z.string(),
  email: z.string().email(),
  registration: z.string(),
  clinic_name: z.string(),
  city: z.string(),
});

// FeatureType
export const FeatureTypeSchema = z.object({
  text: z.string(),
  badge: z.string().optional(),
});

// PlanType
export const PlanTypeSchema = z.object({
  id: z.number(),
  slug: z.string(),
});

// PlanVersionType
export const PlanVersionTypeSchema = z.object({
  id: z.number(),
  plan_id: z.number(),
  slug: z.string(),
  version: z.number(),
  title: z.string(),
  description: z.string(),
  price_month: z.number(),
  price_year: z.number(),
  discount_month: z.number(),
  discount_year: z.number(),
  features: z.array(FeatureTypeSchema),
  effective_from: z.string(),
  effective_to: z.string().nullable(),
  plans: PlanTypeSchema,
});

// SubscriptionType
export const SubscriptionTypeSchema = z.object({
  id: z.number(),
  owner_id: z.string(),
  plan_version_id: z.number(),
  cycle: z.enum(['monthly', 'annual']),
  status: z.enum(['pending', 'active', 'canceled', 'expired']),
  external_id: z.string().nullable(),
  price_at_purchase: z.number(),
  discount_applied: z.number(),
  started_at: z.string(),
  expires_at: z.string().nullable(),
  updated_at: z.string(),
});

export const SubscriptionInsertSchema = z.object({
  ownerId: z.string(),
  planVersionId: z.string(),
  cycle: z.enum(["monthly", "annual"]),
  priceAtPurchase: z.number(),
  discountApplied: z.number()
});


export const ConsultationProcedurePayloadSchema = z.object({
  procedure_name: z.string().min(1, "El nombre del procedimiento es requerido."),
  description: z.string().optional().nullable(),
  // No incluyas consultation_id aquí, se añade en el backend
});

export const ConsultationMedicationPayloadSchema = z.object({
  medication_name: z.string().min(1, "El nombre del medicamento es requerido."),
  dosage: z.string().min(1, "La dosis es requerida."),
  frequency: z.string().min(1, "La frecuencia es requerida."),
  duration_days: z.number().int().positive().optional().nullable(),
  notes: z.string().optional().nullable(),
});

export const CreateConsultationPayloadSchema = z.object({
  pet_id: z.string().regex(new RegExp(/^[A-Za-z]\d{3}$/)),
  consultation_date: z.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Fecha de consulta inválida.",
  }), // o z.date() si envías objetos Date
  reason_for_consultation: z.string().min(1, "El motivo de la consulta es requerido."),
  current_diet: z.string().optional().nullable(),
  previous_illnesses: z.string().optional().nullable(),
  previous_surgeries: z.string().optional().nullable(),
  vaccination_history: z.string().optional().nullable(), // Podría ser más estructurado
  last_deworming_product: z.string().optional().nullable(),
  recent_treatments: z.string().optional().nullable(),
  recent_travels: z.string().optional().nullable(),
  animal_behavior_owner_description: z.string().optional().nullable(),

  // Examen Físico General
  body_condition_score: z.number().min(1).max(5).optional().nullable(), // Asumiendo escala 1-5
  temperature_celsius: z.number().optional().nullable(),
  heart_rate_bpm: z.number().int().positive().optional().nullable(),
  respiratory_rate_rpm: z.number().int().positive().optional().nullable(),
  capillary_refill_time_sec: z.number().positive().optional().nullable(),
  mucous_membranes_description: z.string().optional().nullable(),
  hydration_percentage: z.number().min(0).max(100).optional().nullable(), // O descripción
  sense_organs_description: z.string().optional().nullable(),
  skin_and_coat_description: z.string().optional().nullable(),
  lymph_nodes_description: z.string().optional().nullable(),
  digestive_system_findings: z.string().optional().nullable(),
  respiratory_system_findings: z.string().optional().nullable(),
  endocrine_system_findings: z.string().optional().nullable(),
  musculoskeletal_system_findings: z.string().optional().nullable(),
  nervous_system_findings: z.string().optional().nullable(),
  urinary_system_findings: z.string().optional().nullable(),
  reproductive_system_findings: z.string().optional().nullable(),
  rectal_palpation_findings: z.string().optional().nullable(),
  other_physical_findings: z.string().optional().nullable(),

  // Abordaje Diagnóstico
  problem_list: z.string().optional().nullable(), // Podría ser un array de strings
  master_problem_list: z.string().optional().nullable(),
  differential_diagnoses: z.string().optional().nullable(), // Podría ser un array

  // Exámenes Complementarios (se manejan con subida de archivos, o podrían ser campos de texto)
  // Aquí solo información textual si no se suben archivos para todo
  complementary_exams_summary: z.string().optional().nullable(),

  presumptive_diagnosis: z.string().min(1, "El diagnóstico presuntivo es requerido."),
  definitive_diagnosis: z.string().optional().nullable(),
  therapeutic_plan: z.string().min(1, "El plan terapéutico es requerido."),
  prognosis: z.string().optional().nullable(),
  evolution_notes: z.string().optional().nullable(), // Para la evolución inicial si aplica
  general_observations: z.string().optional().nullable(),

  // Campos para identificar al veterinario, opcionales si se infieren de la sesión
  veterinarian_id: z.string().uuid("ID de veterinario inválido.").optional().nullable(),
  veterinary_access_id: z.string().uuid("ID de acceso veterinario inválido.").optional().nullable(),

  // Arrays para procedimientos y medicamentos que se crearán junto con la consulta
  procedures: z.array(ConsultationProcedurePayloadSchema).optional(),
  medications: z.array(ConsultationMedicationPayloadSchema).optional(),
}); 
----- Archivo: apiService.ts ----- 
import { QueryParamError, StepStateError, RepositoryError, ValidationResult, AuthExceptionError } from "@/types/lib";
import { NextRequest, NextResponse } from "next/server";
import { ZodSchema, ZodError } from "zod";

/** 
 * Envuelve la ejecución de un handler de API, capturando cualquier excepción
 * y devolviendo un 500 en caso de error interno.
 *
 * @param req    – el NextRequest que llega
 * @param handler– Función que ejecuta la lógica de negocio y devuelve un NextResponse
 */
export async function getWithErrorHandling(
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        return await handler()
    } catch (err: unknown) {
        console.error(`[GET] Error en ${req.url} —`, err);
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthExceptionError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * Extrae un parámetro de query y lanza QueryParamError si no existe.
 */
export function getRequiredQueryParam(req: NextRequest, name: string): string {
    const value = req.nextUrl.searchParams.get(name)
    if (!value) {
        throw new QueryParamError(`${name} es requerido`)
    }
    return value
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withErrorHandling(
    method: string,
    req: NextRequest,
    handler: () => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 2) Lógica de negocio con body ya parseado
        return await handler();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthExceptionError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Combina validación de body con manejo de errores.
 * 
 * @param method – nombre del método HTTP (para logging)
 * @param req    – el NextRequest que llega
 * @param schema – el ZodSchema contra el que validar
 * @param handler– función que recibe el body ya parseado
 */
export async function withValidationAndErrorHandling<T>(
    method: string,
    req: NextRequest,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schema: ZodSchema<any>,
    handler: (data: T) => Promise<NextResponse>
): Promise<NextResponse> {
    try {
        // 1) Validación del body
        const { data, error } = await validateBody(req, schema);
        if (error) {
            return error;
        }

        // 2) Lógica de negocio con body ya parseado
        return await handler(data);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        console.error(`[${method}] Error en ${req.url} —`, JSON.stringify(err));
        // 3) Falta de parámetro de query → 400
        if (err instanceof QueryParamError) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 400 }
            )
        }
        // 4) Falta de configuración en el step -> 500
        if (err instanceof StepStateError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 5) Error con el patron repository -> 500
        if (err instanceof RepositoryError) {
            return NextResponse.json(
                { success: false, message: `Error interno del servidor | ${err.message}` },
                { status: 500 }
            )
        }
        // 6) Error con la autenticación -> 500
        if (err instanceof AuthExceptionError) {
            return NextResponse.json(
                { success: false, message: `Error en la autenticación | ${err.message}` },
                { status: 500 }
            )
        }
        // 7) Error cualquiera -> 500
        if (err instanceof Error) {
            return NextResponse.json(
                { success: false, message: err.message },
                { status: 500 }
            )
        }

        // 8) Cualquier otro error cae aquí
        return NextResponse.json(
            { success: false, message: "Error interno del servidor" },
            { status: 500 }
        );
    }
}

/**
 * Valida y parsea el body de la request según el esquema.
 * @param req NextRequest
 * @param schema ZodSchema que define la forma esperada
 * @returns Un objeto { data } si parseó bien, o { error } con NextResponse si falló.
 */
async function validateBody<T>(
    req: NextRequest,
    schema: ZodSchema<T>
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
): Promise<ValidationResult<any>> {
    try {
        const body = await req.json();
        if (Array.isArray(body)) {
            body.forEach((e: T) => {
                const parsed = schema.safeParse(e);
                if (!parsed.success) {
                    // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                        console.log(parsed.error);
                    return {
                        error: NextResponse.json(
                            {
                                success: false,
                                message: "Payload inválido",
                                errors: (parsed.error as ZodError).format(),
                            },
                            { status: 400 }
                        ),
                    };
                }
            });
        }
        else {
            const parsed = schema.safeParse(body);
            if (!parsed.success) {
                        console.log(parsed.error);
                // Opcionalmente, podemos enviar detalles de ZodError.flatten()
                return {
                    error: NextResponse.json(
                        {
                            success: false,
                            message: "Payload inválido",
                            errors: (parsed.error as ZodError).format(),
                        },
                        { status: 400 }
                    ),
                };
            }
        }
        return { data: body };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (err: any) {
        // JSON inválido u otro error de lectura
        return {
            error: NextResponse.json(
                { success: false, message: err.message || "No se pudo leer el body" },
                { status: 400 }
            ),
        };
    }
} 
----- Archivo: authService.ts ----- 
// src/services/authService.ts
import { StorageContextType } from "@/hooks/useAppStorage";
import { authClient } from '@/lib/auth';
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";

export const handleLogout = async (storage: StorageContextType, router: AppRouterInstance): Promise<void> => {
  try {
    storage.resetSession();
    // Llamamos a nuestro nuevo endpoint de logout
    await fetch('/api/auth/logout', { method: 'POST' });
    await authClient.signOut();
  } catch (error) {
    console.error("Error during sign out in authService:", error);
  } finally {
    router.replace("/login");
    router.refresh();
  }
}; 
----- Archivo: emailService.ts ----- 
// src/services/emailService.ts

export interface SendEmailOptions {
  subject: string;
  text: string;
  from?: string;
  to?: string;
}

export async function sendEmail({ subject, text, from, to }: SendEmailOptions) {
  const MAILTRAP_URL = process.env.MAILTRAP_URL;
  const MAILTRAP_TOKEN = process.env.MAILTRAP_TOKEN;
  const MAILTRAP_FROM = from || process.env.MAILTRAP_FROM;
  const MAILTRAP_TO = to || process.env.MAILTRAP_TO;

  // Validación de configuración
  if (!MAILTRAP_URL || !MAILTRAP_TOKEN || !MAILTRAP_FROM || !MAILTRAP_TO) {
    throw new Error('Configuración de email incompleta');
  }

  // Envío de correo vía API
  const response = await fetch(MAILTRAP_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${MAILTRAP_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from: { email: MAILTRAP_FROM },
      to: [{ email: MAILTRAP_TO }],
      subject,
      text,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Error al enviar correo: ${response.status} - ${errorText}`);
  }
} 
----- Archivo: basicData_update.sql ----- 
-- Agregamos las columnas para el color y el tipo de pelaje:
ALTER TABLE public.basic_data
ADD COLUMN coat_type TEXT,
ADD COLUMN color TEXT;
 
----- Archivo: consultations.sql ----- 
-- 1. Tabla Principal de Consultas
CREATE TABLE consultations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pet_id varchar(4) NOT NULL REFERENCES pets(id) ON DELETE CASCADE, -- Si se borra la mascota, se borran sus consultas
    veterinarian_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Quién hizo la consulta (si es usuario vet)
    veterinary_access_id UUID REFERENCES veterinary_accesses(id) ON DELETE SET NULL, -- Si se usó código de acceso
    
    consultation_date DATE NOT NULL,
    consultation_time TIME WITHOUT TIME ZONE,
    hc_number TEXT,
    institution_name TEXT,

    -- Anamnesis
    reason_for_consultation TEXT NOT NULL,
    current_diet TEXT,
    previous_illnesses TEXT,
    previous_surgeries TEXT,
    vaccination_history TEXT,
    last_deworming_product TEXT,
    recent_treatments TEXT,
    recent_travels TEXT,
    animal_behavior_owner_description TEXT,
    lives_with_other_animals_details TEXT,
    sterilized_status TEXT CHECK (sterilized_status IN ('yes', 'no', 'unknown')),
    birth_count INTEGER,

    -- Examen Físico General
    body_condition_score NUMERIC(2,1), -- ej: 3.5
    temperature_celsius NUMERIC(4,1), -- ej: 38.5
    heart_rate_bpm INTEGER,
    respiratory_rate_rpm INTEGER,
    capillary_refill_time_sec NUMERIC(3,1),
    pulse_description TEXT,
    mucous_membranes_description TEXT,
    hydration_percentage_description TEXT,
    sense_organs_description TEXT,

    -- Examen Físico por Sistemas
    skin_and_coat_description TEXT,
    lymph_nodes_description TEXT,
    digestive_system_findings TEXT,
    respiratory_system_findings TEXT,
    endocrine_system_findings TEXT,
    musculoskeletal_system_findings TEXT,
    nervous_system_findings TEXT,
    urinary_system_findings TEXT,
    reproductive_system_findings TEXT,
    rectal_palpation_findings TEXT,
    other_physical_findings TEXT,

    -- Abordaje Diagnóstico
    problem_list TEXT,
    master_problem_list TEXT,
    differential_diagnoses TEXT,

    -- Exámenes Complementarios (Resumen textual)
    complementary_exams_summary TEXT,

    -- Diagnóstico y Plan
    presumptive_diagnosis TEXT NOT NULL,
    definitive_diagnosis TEXT,
    therapeutic_plan TEXT NOT NULL,
    prognosis TEXT,
    evolution_notes TEXT,
    general_observations TEXT,
    signature_confirmation TEXT,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT check_vet_responsible CHECK (veterinarian_id IS NOT NULL OR veterinary_access_id IS NOT NULL)
);

-- Trigger para actualizar 'updated_at'
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_consultations_modtime
    BEFORE UPDATE ON consultations
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

-- Índices
CREATE INDEX idx_consultations_pet_id ON consultations(pet_id);
CREATE INDEX idx_consultations_veterinarian_id ON consultations(veterinarian_id);
CREATE INDEX idx_consultations_veterinary_access_id ON consultations(veterinary_access_id);


-- 2. Tabla de Procedimientos de Consulta
CREATE TABLE consultation_procedures (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    procedure_name TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_procedures_consultation_id ON consultation_procedures(consultation_id);


-- 3. Tabla de Medicamentos de Consulta
CREATE TABLE consultation_medications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    medication_name TEXT NOT NULL,
    dosage TEXT NOT NULL,
    frequency TEXT NOT NULL,
    duration_days INTEGER,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_medications_consultation_id ON consultation_medications(consultation_id);


-- 4. Tabla de Archivos Adjuntos de Consulta
CREATE TABLE consultation_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    consultation_id UUID NOT NULL REFERENCES consultations(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL UNIQUE, -- Ruta en Supabase Storage, ej: 'pet_uuid/consultation_uuid/filename.pdf'
    file_type TEXT, -- MIME type
    file_size_bytes BIGINT,
    uploaded_by_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_consultation_files_consultation_id ON consultation_files(consultation_id);

-- Asegúrate de crear un BUCKET en Supabase Storage para los archivos, por ejemplo, 'consultation-files'
-- y configura sus políticas. Generalmente, el bucket es privado y se accede mediante URLs firmadas.

--- POLÍTICAS RLS (Row Level Security) ---

-- Habilitar RLS para cada tabla
ALTER TABLE consultations ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_procedures ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_medications ENABLE ROW LEVEL SECURITY;
ALTER TABLE consultation_files ENABLE ROW LEVEL SECURITY;

-- Función auxiliar para verificar si el usuario actual es el dueño de la mascota asociada a una consulta
CREATE OR REPLACE FUNCTION is_pet_owner(p_consultation_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    is_owner BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM consultations c
        JOIN pets p ON c.pet_id = p.id
        WHERE c.id = p_consultation_id AND p.owner_id = auth.uid()
    ) INTO is_owner;
    RETURN is_owner;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; -- SECURITY DEFINER es importante para que pueda acceder a tablas necesarias

-- Función auxiliar para verificar si el veterinario actual creó la consulta o tiene acceso a través de veterinary_access
CREATE OR REPLACE FUNCTION veterinarian_has_access_to_consultation(p_consultation_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    has_access BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM consultations c
        WHERE c.id = p_consultation_id
          AND (
            c.veterinarian_id = auth.uid() -- Vet creó la consulta
            OR EXISTS ( -- Vet tiene un acceso activo para esta mascota (más complejo, simplificado aquí)
                SELECT 1
                FROM veterinary_accesses va
                WHERE va.id = c.veterinary_access_id
                  AND va.pet_id = c.pet_id
                  -- AND va.expires_at > NOW() -- (Si los códigos de acceso tienen expiración y el vet_access se liga al usuario)
                  -- Esta parte es más compleja si el acceso es por código y no por sesión de veterinario.
                  -- Si veterinary_access_id es solo una referencia al código usado, la validación del código
                  -- debe ocurrir en la capa de API antes de la inserción/actualización.
                  -- Para RLS de SELECT, podría ser suficiente si la API ya validó.
            )
          )
    ) INTO has_access;
    RETURN has_access;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Políticas para 'consultations'
CREATE POLICY "Owners can view their pets consultations"
    ON consultations FOR SELECT
    USING (is_pet_owner(id));

CREATE POLICY "Veterinarians can view consultations they are linked to"
    ON consultations FOR SELECT
    USING (veterinarian_has_access_to_consultation(id));

CREATE POLICY "Authenticated veterinarians can insert consultations"
    ON consultations FOR INSERT
    WITH CHECK (
        (auth.role() = 'authenticated') AND
        (
            -- El ID del veterinario en el payload coincide con el usuario autenticado Y el rol del usuario es 'veterinarian'
            (veterinarian_id = auth.uid() AND (SELECT raw_user_meta_data->>'role' FROM auth.users WHERE id = auth.uid()) = 'veterinarian')
            OR
            -- O se proporciona un veterinary_access_id válido (la validez del código en sí se manejaría en la API)
            (veterinary_access_id IS NOT NULL) -- La API debe validar que este access_id es legítimo para la mascota y el vet.
        )
    );
    
CREATE POLICY "Veterinarians can update consultations they created"
    ON consultations FOR UPDATE
    USING (veterinarian_id = auth.uid() AND (SELECT raw_user_meta_data->>'role' FROM auth.users WHERE id = auth.uid()) = 'veterinarian')
    WITH CHECK (veterinarian_id = auth.uid()); -- No pueden cambiar el vet_id a otro

-- DELETE: Nadie puede eliminar directamente (según requerimiento)
CREATE POLICY "Consultations are protected from direct deletion"
    ON consultations FOR DELETE
    USING (false); -- O más restrictivo: TO none;

-- Políticas para 'consultation_procedures', 'consultation_medications'
-- Asumimos que si puedes ver/editar la consulta, puedes ver/editar sus detalles.
CREATE POLICY "Users can manage procedures of consultations they have access to"
    ON consultation_procedures FOR ALL
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)); -- Re-evalúa RLS de la tabla 'consultations'

CREATE POLICY "Users can manage medications of consultations they have access to"
    ON consultation_medications FOR ALL
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id));

-- DELETE para procedures/medications: Solo si el veterinario que creó la consulta lo hace.
-- Esto podría ser más granular. Por ahora, si pueden actualizar la consulta, pueden borrar sub-items.
-- Podrías hacerla más restrictiva:
CREATE POLICY "Procedures can only be deleted by the creating veterinarian"
    ON consultation_procedures FOR DELETE
    USING (EXISTS (SELECT 1 FROM consultations c WHERE c.id = consultation_id AND c.veterinarian_id = auth.uid()));

CREATE POLICY "Medications can only be deleted by the creating veterinarian"
    ON consultation_medications FOR DELETE
    USING (EXISTS (SELECT 1 FROM consultations c WHERE c.id = consultation_id AND c.veterinarian_id = auth.uid()));


-- Políticas para 'consultation_files'
CREATE POLICY "Users can view files of consultations they have access to"
    ON consultation_files FOR SELECT
    USING (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)); -- Re-evalúa RLS

CREATE POLICY "Authenticated users (vets) can upload files to consultations they have access to"
    ON consultation_files FOR INSERT
    WITH CHECK (
        (auth.role() = 'authenticated') AND
        (EXISTS (SELECT 1 FROM consultations WHERE id = consultation_id)) AND -- Implícitamente verifica acceso a consulta
        (uploaded_by_user_id = auth.uid()) -- Quien sube es el usuario actual
    );

CREATE POLICY "Users can delete files they uploaded"
    ON consultation_files FOR DELETE
    USING (uploaded_by_user_id = auth.uid());

-- Políticas de Supabase Storage para el bucket 'consultation-files' (Ejemplos conceptuales):
-- Estas se configuran en la UI de Supabase Storage, no directamente con SQL aquí.
-- 1. SELECT: Permitir a usuarios autenticados que tengan una RLS de SELECT en `consultation_files` para el `file_path` correspondiente.
   -- ( (bucket_id = 'consultation-files') AND (ROLE() = 'authenticated') AND (EXISTS (SELECT 1 FROM public.consultation_files WHERE consultation_files.file_path = storage.objectid((storage.objects.name)::text) AND auth.uid() = consultation_files.uploaded_by_user_id /* O reglas de acceso a la consulta */ )) )
-- 2. INSERT: Permitir a usuarios autenticados que puedan hacer INSERT en `consultation_files` y que `uploaded_by_user_id` sea su `auth.uid()`.
-- 3. UPDATE: Generalmente no se permite para evitar corrupción, se sube una nueva versión.
-- 4. DELETE: Permitir a usuarios autenticados que puedan hacer DELETE en `consultation_files` y que `uploaded_by_user_id` sea su `auth.uid()`.


GRANT REFERENCES (id) ON TABLE auth.users TO authenticated;

CREATE OR REPLACE FUNCTION create_consultation_secure(
    p_pet_id UUID,
    p_veterinarian_id UUID,
    p_reason TEXT
    -- ... otros parámetros ...
)
RETURNS UUID -- o el ID de la consulta creada
LANGUAGE plpgsql
SECURITY DEFINER -- ¡Importante!
-- SET search_path = public, auth; -- Asegura que los esquemas correctos estén en el path
AS $$
DECLARE
    new_consultation_id UUID;
BEGIN
    -- Aquí puedes añadir validaciones adicionales si es necesario,
    -- como verificar que p_veterinarian_id (si es auth.uid()) realmente es un veterinario.
    -- Esta validación es importante ya que la función se ejecuta con altos privilegios.

    INSERT INTO public.consultations (pet_id, veterinarian_id, reason_for_consultation /*, ...otros campos... */)
    VALUES (p_pet_id, p_veterinarian_id, p_reason /*, ...otros valores... */)
    RETURNING id INTO new_consultation_id;

    RETURN new_consultation_id;
END;
$$;

-- Luego, otorgas permiso de EXECUTE en esta función a los roles necesarios:
GRANT EXECUTE ON FUNCTION create_consultation_secure(UUID, UUID, TEXT) TO authenticated;

CREATE POLICY "Allow individual user access"
ON auth.users
FOR SELECT
USING (auth.uid() = id);

-- Tipo para los procedimientos que se pasarán como array
CREATE TYPE consultation_procedure_input AS (
    procedure_name TEXT,
    description TEXT
);

-- Tipo para los medicamentos que se pasarán como array
CREATE TYPE consultation_medication_input AS (
    medication_name TEXT,
    dosage TEXT,
    frequency TEXT,
    duration_days INTEGER,
    notes TEXT
);

CREATE TYPE consultation_input_type AS (
    p_consultation_date DATE,
    p_consultation_time TIME WITHOUT TIME ZONE,
    p_hc_number TEXT,
    p_institution_name TEXT,
    p_reason_for_consultation TEXT,
    p_current_diet TEXT,
    p_previous_illnesses TEXT,
    p_previous_surgeries TEXT,
    p_vaccination_history TEXT,
    p_last_deworming_product TEXT,
    p_recent_treatments TEXT,
    p_recent_travels TEXT,
    p_animal_behavior_owner_description TEXT,
    p_lives_with_other_animals_details TEXT,
    p_sterilized_status TEXT,
    p_birth_count INTEGER,
    p_body_condition_score NUMERIC,
    p_temperature_celsius NUMERIC,
    p_heart_rate_bpm INTEGER,
    p_respiratory_rate_rpm INTEGER,
    p_capillary_refill_time_sec NUMERIC,
    p_pulse_description TEXT,
    p_mucous_membranes_description TEXT,
    p_hydration_percentage_description TEXT,
    p_sense_organs_description TEXT,
    p_skin_and_coat_description TEXT,
    p_lymph_nodes_description TEXT,
    p_digestive_system_findings TEXT,
    p_respiratory_system_findings TEXT,
    p_endocrine_system_findings TEXT,
    p_musculoskeletal_system_findings TEXT,
    p_nervous_system_findings TEXT,
    p_urinary_system_findings TEXT,
    p_reproductive_system_findings TEXT,
    p_rectal_palpation_findings TEXT,
    p_other_physical_findings TEXT,
    p_problem_list TEXT,
    p_master_problem_list TEXT,
    p_differential_diagnoses TEXT,
    p_complementary_exams_summary TEXT,
    p_presumptive_diagnosis TEXT,
    p_definitive_diagnosis TEXT,
    p_therapeutic_plan TEXT,
    p_prognosis TEXT,
    p_evolution_notes TEXT,
    p_general_observations TEXT,
    p_signature_confirmation TEXT
);


-- Tipos para los inputs de arrays (si ya los tienes, no necesitas volver a crearlos)
-- CREATE TYPE consultation_procedure_input AS (...);
-- CREATE TYPE consultation_medication_input AS (...);

CREATE OR REPLACE FUNCTION insert_consultation_with_type(
    p_pet_id TEXT,
    p_veterinarian_id UUID, -- Puede ser NULL
    p_veterinary_access_id UUID, -- Puede ser NULL
    p_consultation_main_data consultation_input_type,
    p_procedures consultation_procedure_input[],
    p_medications consultation_medication_input[]
)
RETURNS JSON -- Devolvemos la consulta creada como JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    new_consultation_id UUID;
    full_consultation_json JSON;
    proc_input consultation_procedure_input;
    med_input consultation_medication_input;
BEGIN
    IF p_veterinarian_id IS NULL AND p_veterinary_access_id IS NULL THEN
        RAISE EXCEPTION 'Se requiere veterinarian_id o veterinary_access_id para crear una consulta.';
    END IF;

    INSERT INTO public.consultations (
        pet_id, veterinarian_id, veterinary_access_id,
        consultation_date, consultation_time, hc_number, institution_name,
        reason_for_consultation, current_diet, previous_illnesses, previous_surgeries,
        vaccination_history, last_deworming_product, recent_treatments, recent_travels,
        animal_behavior_owner_description, lives_with_other_animals_details,
        sterilized_status, birth_count, body_condition_score, temperature_celsius,
        heart_rate_bpm, respiratory_rate_rpm, capillary_refill_time_sec, pulse_description,
        mucous_membranes_description, hydration_percentage_description, sense_organs_description,
        skin_and_coat_description, lymph_nodes_description, digestive_system_findings,
        respiratory_system_findings, endocrine_system_findings, musculoskeletal_system_findings,
        nervous_system_findings, urinary_system_findings, reproductive_system_findings,
        rectal_palpation_findings, other_physical_findings, problem_list, master_problem_list,
        differential_diagnoses, complementary_exams_summary, presumptive_diagnosis,
        definitive_diagnosis, therapeutic_plan, prognosis, evolution_notes,
        general_observations, signature_confirmation
    ) VALUES (
        p_pet_id, p_veterinarian_id, p_veterinary_access_id,
        (p_consultation_main_data).p_consultation_date,
        (p_consultation_main_data).p_consultation_time,
        (p_consultation_main_data).p_hc_number,
        (p_consultation_main_data).p_institution_name,
        (p_consultation_main_data).p_reason_for_consultation,
        (p_consultation_main_data).p_current_diet,
        (p_consultation_main_data).p_previous_illnesses,
        (p_consultation_main_data).p_previous_surgeries,
        (p_consultation_main_data).p_vaccination_history,
        (p_consultation_main_data).p_last_deworming_product,
        (p_consultation_main_data).p_recent_treatments,
        (p_consultation_main_data).p_recent_travels,
        (p_consultation_main_data).p_animal_behavior_owner_description,
        (p_consultation_main_data).p_lives_with_other_animals_details,
        (p_consultation_main_data).p_sterilized_status,
        (p_consultation_main_data).p_birth_count,
        (p_consultation_main_data).p_body_condition_score,
        (p_consultation_main_data).p_temperature_celsius,
        (p_consultation_main_data).p_heart_rate_bpm,
        (p_consultation_main_data).p_respiratory_rate_rpm,
        (p_consultation_main_data).p_capillary_refill_time_sec,
        (p_consultation_main_data).p_pulse_description,
        (p_consultation_main_data).p_mucous_membranes_description,
        (p_consultation_main_data).p_hydration_percentage_description,
        (p_consultation_main_data).p_sense_organs_description,
        (p_consultation_main_data).p_skin_and_coat_description,
        (p_consultation_main_data).p_lymph_nodes_description,
        (p_consultation_main_data).p_digestive_system_findings,
        (p_consultation_main_data).p_respiratory_system_findings,
        (p_consultation_main_data).p_endocrine_system_findings,
        (p_consultation_main_data).p_musculoskeletal_system_findings,
        (p_consultation_main_data).p_nervous_system_findings,
        (p_consultation_main_data).p_urinary_system_findings,
        (p_consultation_main_data).p_reproductive_system_findings,
        (p_consultation_main_data).p_rectal_palpation_findings,
        (p_consultation_main_data).p_other_physical_findings,
        (p_consultation_main_data).p_problem_list,
        (p_consultation_main_data).p_master_problem_list,
        (p_consultation_main_data).p_differential_diagnoses,
        (p_consultation_main_data).p_complementary_exams_summary,
        (p_consultation_main_data).p_presumptive_diagnosis,
        (p_consultation_main_data).p_definitive_diagnosis,
        (p_consultation_main_data).p_therapeutic_plan,
        (p_consultation_main_data).p_prognosis,
        (p_consultation_main_data).p_evolution_notes,
        (p_consultation_main_data).p_general_observations,
        (p_consultation_main_data).p_signature_confirmation
    ) RETURNING id INTO new_consultation_id;

    IF p_procedures IS NOT NULL AND array_length(p_procedures, 1) > 0 THEN
        FOREACH proc_input IN ARRAY p_procedures LOOP
            INSERT INTO public.consultation_procedures (consultation_id, procedure_name, description)
            VALUES (new_consultation_id, proc_input.procedure_name, proc_input.description);
        END LOOP;
    END IF;

    IF p_medications IS NOT NULL AND array_length(p_medications, 1) > 0 THEN
        FOREACH med_input IN ARRAY p_medications LOOP
            INSERT INTO public.consultation_medications (consultation_id, medication_name, dosage, frequency, duration_days, notes)
            VALUES (new_consultation_id, med_input.medication_name, med_input.dosage, med_input.frequency, med_input.duration_days, med_input.notes);
        END LOOP;
    END IF;

    -- Devolver la consulta completa como JSON
    SELECT json_build_object(
        'id', c.id, 'pet_id', c.pet_id, 'veterinarian_id', c.veterinarian_id, 'veterinary_access_id', c.veterinary_access_id,
        'consultation_date', c.consultation_date, 'consultation_time', c.consultation_time, 'hc_number', c.hc_number, 'institution_name', c.institution_name,
        'reason_for_consultation', c.reason_for_consultation, 'current_diet', c.current_diet, 'previous_illnesses', c.previous_illnesses, 'previous_surgeries', c.previous_surgeries,
        'vaccination_history', c.vaccination_history, 'last_deworming_product', c.last_deworming_product, 'recent_treatments', c.recent_treatments, 'recent_travels', c.recent_travels,
        'animal_behavior_owner_description', c.animal_behavior_owner_description, 'lives_with_other_animals_details', c.lives_with_other_animals_details,
        'sterilized_status', c.sterilized_status, 'birth_count', c.birth_count, 'body_condition_score', c.body_condition_score, 'temperature_celsius', c.temperature_celsius,
        'heart_rate_bpm', c.heart_rate_bpm, 'respiratory_rate_rpm', c.respiratory_rate_rpm, 'capillary_refill_time_sec', c.capillary_refill_time_sec, 'pulse_description', c.pulse_description,
        'mucous_membranes_description', c.mucous_membranes_description, 'hydration_percentage_description', c.hydration_percentage_description, 'sense_organs_description', c.sense_organs_description,
        'skin_and_coat_description', c.skin_and_coat_description, 'lymph_nodes_description', c.lymph_nodes_description, 'digestive_system_findings', c.digestive_system_findings,
        'respiratory_system_findings', c.respiratory_system_findings, 'endocrine_system_findings', c.endocrine_system_findings, 'musculoskeletal_system_findings', c.musculoskeletal_system_findings,
        'nervous_system_findings', c.nervous_system_findings, 'urinary_system_findings', c.urinary_system_findings, 'reproductive_system_findings', c.reproductive_system_findings,
        'rectal_palpation_findings', c.rectal_palpation_findings, 'other_physical_findings', c.other_physical_findings, 'problem_list', c.problem_list, 'master_problem_list', c.master_problem_list,
        'differential_diagnoses', c.differential_diagnoses, 'complementary_exams_summary', c.complementary_exams_summary, 'presumptive_diagnosis', c.presumptive_diagnosis,
        'definitive_diagnosis', c.definitive_diagnosis, 'therapeutic_plan', c.therapeutic_plan, 'prognosis', c.prognosis, 'evolution_notes', c.evolution_notes,
        'general_observations', c.general_observations, 'signature_confirmation', c.signature_confirmation,
        'created_at', c.created_at, 'updated_at', c.updated_at,
        'procedures', (SELECT COALESCE(json_agg(cp), '[]'::json) FROM consultation_procedures cp WHERE cp.consultation_id = new_consultation_id),
        'medications', (SELECT COALESCE(json_agg(cm), '[]'::json) FROM consultation_medications cm WHERE cm.consultation_id = new_consultation_id),
        'files', '[]'::json
    )
    INTO full_consultation_json
    FROM consultations c
    WHERE c.id = new_consultation_id;

    RETURN full_consultation_json;

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error en create_consultation_secure: %', SQLERRM;
        RAISE;
END;
$$;

GRANT EXECUTE ON FUNCTION insert_consultation_with_type(
	TEXT, -- p_pet_id
    UUID, -- p_veterinarian_id
    UUID, -- p_veterinary_access_id
    consultation_input_type, -- p_consultation_data
    consultation_procedure_input[], -- p_procedures
    consultation_medication_input[]  -- p_medications
) TO authenticated;



--MANUAL CREATE STORAGE IN SUPABASE PAGE
-- Permite subir archivos si el usuario está autenticado
create policy "Authenticated can upload consultation files"
on storage.objects
for insert
with check (bucket_id = 'consultation-files' AND auth.role() = 'authenticated');

-- Permitir que usuarios autenticados puedan generar URLs firmadas
create policy "Authenticated can read consultation files"
on storage.objects
for select
using (bucket_id = 'consultation-files' AND auth.role() = 'authenticated');

-- Permitir que usuarios autenticados puedan eliminar archivos de consultation-files
create policy "Authenticated can delete consultation files"
on storage.objects
for delete
using (
  bucket_id = 'consultation-files'
  AND auth.role() = 'authenticated'
); 
----- Archivo: owner_update.sql ----- 
-- Agregamos las columnas para latitud, longitud y el código de país.
ALTER TABLE public.owners
ADD COLUMN latitude NUMERIC(9, 6),
ADD COLUMN longitude NUMERIC(9, 6);

-- Opcional pero recomendado: Se podría modificar la columna 'phone'
-- para indicar que ahora solo guarda el número local, no el código.
COMMENT ON COLUMN public.owners.phone IS 'Número de teléfono local sin el código de país.'; 
----- Archivo: pets.sql ----- 
create table public.pets (
  id            varchar(4)                           not null
                   constraint pets_pk
                     primary key,
  -- enforce format like A001, B123, etc.
  constraint pets_id_format
    check (id ~ '^[A-Za-z]\d{3}$'),

  owner_id      uuid                                 not null
                   references auth.users (id)
                     on delete cascade,

  name          text                                 not null,
  species       text,
  breed         text,
  birth_date    date,

  created_at    timestamp with time zone default now()  not null,
  updated_at    timestamp with time zone default now()  not null
);

-- trigger to auto-update updated_at on row modification
create function update_updated_at_column()
  returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger trigger_update_pets_updated_at
  before update
  on public.pets
  for each row
  execute procedure update_updated_at_column(); 
----- Archivo: pets_update.sql ----- 
-- Agregamos la columna de fecha de nacimiento:
ALTER TABLE public.pets
ADD COLUMN birth_date   TIMESTAMP; 
----- Archivo: pet_codes.sql ----- 
-- Puedes ejecutarlo en el SQL editor de Supabase
create table public.pet_codes (
  id          uuid        default uuid_generate_v4() primary key,
  pet_id      varchar     not null references public.pets(id),
  code        varchar     not null unique,
  expires_at  timestamp   not null,
  used        boolean     not null default false,
  created_at  timestamp   not null default now()
);
 
----- Archivo: plans.sql ----- 
-- --------------------------------------------------
-- 2. Master de Planes
-- --------------------------------------------------
create table if not exists public.plans (
  id    serial      primary key,
  slug  text        not null unique    -- por ej: 'free','standard','advanced','lifetime'
);

-- --------------------------------------------------
-- 3. Versiones de Planes
-- --------------------------------------------------
create table if not exists public.plans_versions (
  id             serial      primary key,
  plan_id        integer     not null
    references public.plans(id) on delete cascade,
  version        integer     not null,
  title          text        not null,
  description    text,
  price_month    integer     not null,   -- en dolares
  price_year     integer     not null,
  discount_month integer     not null default 0,   -- % de descuento mensual aplicado
  discount_year  integer     not null default 0,   -- % de descuento anual aplicado
  features       jsonb       not null,   -- lista de strings o { text, badge }
  effective_from timestamptz default now(),
  effective_to   timestamptz
);

-- índice para evitar versiones duplicadas
create unique index if not exists idx_plans_versions_unique
  on public.plans_versions(plan_id, version);

-- --------------------------------------------------
-- 4. Suscripciones de Owners a PlanVersions
-- --------------------------------------------------
create table if not exists public.subscriptions (
  id                  serial      primary key,
  user_id            uuid        not null
    references public.owners(owner_id) on delete cascade,
  plan_version_id     integer     not null
    references public.plans_versions(id) on delete restrict,
  cycle               text        not null
    check (cycle in ('monthly','annual')),
  status              text        not null
    check (status in ('pending','active','canceled','expired')),
  external_id         text,       -- id de transacción en Bold
  price_at_purchase   integer     not null,   -- snapshot del precio al momento
  discount_applied    integer     not null default 0,
  started_at          timestamptz default now(),
  expires_at          timestamptz,
  updated_at          timestamptz default now()
);

-- --------------------------------------------------
-- 5. Opcional: RLS para que cada owner solo vea sus suscripciones
-- --------------------------------------------------
alter table public.subscriptions
  enable row level security;

create policy "Owners can view own subscriptions"
  on public.subscriptions for select
  using ( user_id = auth.uid() );

create policy "Owners can insert subscriptions"
  on public.subscriptions for insert
  with check ( user_id = auth.uid() );

create policy "Owners can update own subscriptions"
  on public.subscriptions for update
  using ( user_id = auth.uid() )
  with check ( user_id = auth.uid() );
  
  
  -- --------------------------------------------------
-- 6. Inserción de datos iniciales en public.plans y public.plans_versions
-- --------------------------------------------------

-- 1. Insertar los slugs maestros en public.plans
INSERT INTO public.plans (slug)
VALUES
  ('free'),
  ('standard'),
  ('advanced'),
  ('lifetime');

-- 2. Insertar la versión 1 de cada plan en public.plans_versions

-- 2.1 Plan gratuito
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'free'),
  1,
  'Modelo Gratuito',
  'Para personas nuevas y con necesidades básicas de gestión de Historias clínicas para tu mascota',
  0,
  0,
  0,
  0,
  '[
    {"text":"1 perfil de mascota"},
    {"text":"Carga de examenes hasta 500MB"},
    {"text":"Información de contacto"},
    {"text":"Acceso a la APP"},
    {"text":"Plataforma de gestión para tu VET"},
    {"text":"Seguridad de doble factor"}
  ]'::jsonb
);

-- 2.2 Plan estándar
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'standard'),
  1,
  'Modelo estándar',
  'Especial para quienes tienen más de una mascota y quieren utilizar todos nuestros servicios.',
  500,    -- $5.00 USD en centavos
  5400,   -- $54.00 USD en centavos
  0,
  10,     -- 10% de descuento
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Perfiles de 3 mascotas"},
    {"text":"Carga de examenes sin límites"},
    {"text":"Función de pérdida de mascota"},
    {"text":"Múltiples sesiones activas en la app"},
    {"text":"Soporte personalizado"},
    {"text":"Plan de recomendados"},
    {"text":"Descargas de copias de historial"},
    {"text":"Lectura en múltiples idiomas","badge":"Pronto"}
  ]'::jsonb
);

-- 2.3 Plan avanzado
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'advanced'),
  1,
  'Modelo avanzado',
  'Diseñado para quien tiene más de una mascota y quiere agregar collares a la suscripción.',
  900,    -- $9.00 USD en centavos
  8640,   -- $86.40 USD en centavos
  0,
  20,     -- 20% de descuento
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Todas las funciones del plan estándar"},
    {"text":"Perfiles de mascotas ilimitados"},
    {"text":"Plan de recomendados plus"},
    {"text":"Hasta 5 Tags información"},
    {"text":"IA de pre-diagnóstico","badge":"Coming Soon"},
    {"text":"Sistema de alertas","badge":"Coming Soon"}
  ]'::jsonb
);

-- 2.4 Plan vitalicio
INSERT INTO public.plans_versions (
  plan_id,
  version,
  title,
  description,
  price_month,
  price_year,
  discount_month,
  discount_year,
  features
)
VALUES (
  (SELECT id FROM public.plans WHERE slug = 'lifetime'),
  1,
  'Vitalicio',
  'OFERTA ÚNICA POR TIEMPO LIMITADO SOLO VÁLIDO PARA LOS PRIMEROS 1000 USUARIOS',
  15000,  -- $150.00 USD en centavos
  15000,  -- $150.00 USD en centavos
  0,
  0,
  '[
    {"text":"Todas las funciones del plan gratuito"},
    {"text":"Todas las funciones del plan estándar"},
    {"text":"Todas las funciones del plan avanzado"},
    {"text":"Hasta 10 Tags información"},
    {"text":"Acceso a nuestra versión Beta"},
    {"text":"Recibes nuevas funcionalidades antes"},
    {"text":"Descuentos únicos en LAMPO"},
    {"text":"Ingreso a nuestro plan fundadores"}
  ]'::jsonb
);
 
----- Archivo: tables.sql ----- 
-- 1) Habilitar extensión para UUID si no está
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 2) Tabla de dueños
CREATE TABLE owners (
  owner_id UUID PRIMARY KEY,
  name        TEXT    NOT NULL,
  phone       TEXT    NOT NULL,
  address     TEXT    NOT NULL,
  city        TEXT    NOT NULL,
  country     TEXT    NOT NULL,
  email       TEXT    NOT NULL UNIQUE
);

-- 3) Tabla de datos básicos de la mascota
CREATE TABLE basic_data (
  pet_id              TEXT      PRIMARY KEY REFERENCES pets(id) ON DELETE CASCADE,
  pet_type            TEXT      NOT NULL,
  gender              TEXT      NOT NULL,
  weight              TEXT      NOT NULL,
  race                TEXT      NOT NULL,
  coat_type           TEXT      NOT NULL,
  color               TEXT      NOT NULL,
  has_allergies       BOOLEAN   NOT NULL,
  weight_condition    TEXT      NOT NULL,
  size                TEXT      NOT NULL,
  lives_with_others   BOOLEAN   NOT NULL,
  main_food           TEXT      NOT NULL,
  has_vaccine         BOOLEAN   NOT NULL,
  last_vaccine_name   TEXT,
  last_vaccine_date   TIMESTAMP,
  is_sterilized       BOOLEAN   NOT NULL,
  sterilization_date  TIMESTAMP,
  has_anti_flea       BOOLEAN   NOT NULL,
  anti_flea_date      TIMESTAMP,
  uses_medicine       BOOLEAN   NOT NULL,
  special_condition   BOOLEAN   NOT NULL
);

-- 4) Vacunas
CREATE TABLE vaccines (
  id          UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id      TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name        TEXT      NOT NULL,
  description TEXT,
  date        TIMESTAMP,
  batch       TEXT      NOT NULL,
  brand       TEXT      NOT NULL
);

-- 5) Cirugías
CREATE TABLE surgeries (
  id          UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id      TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name        TEXT      NOT NULL,
  date        TIMESTAMP,
  description TEXT
);

-- 6) Medicinas
CREATE TABLE medicines (
  id        UUID    PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id    TEXT    REFERENCES pets(id) ON DELETE CASCADE,
  name      TEXT    NOT NULL,
  dosage    TEXT    NOT NULL,
  frequency TEXT    NOT NULL
);

-- 7) Condiciones especiales
CREATE TABLE conditions (
  id        UUID    PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id    TEXT    REFERENCES pets(id) ON DELETE CASCADE,
  condition TEXT    NOT NULL,
  severity  TEXT    NOT NULL
);

-- 8) Exámenes de laboratorio
CREATE TABLE lab_tests (
  id     UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  pet_id TEXT      REFERENCES pets(id) ON DELETE CASCADE,
  name   TEXT      NOT NULL,
  type   TEXT      NOT NULL,
  date   TIMESTAMP,
  result TEXT
);


-- Owners
INSERT INTO owners(owner_id, name, phone, address, city, country, email) VALUES
  ('8933eed8-daea-4e6c-b4db-44906b9f44f9','Andrés Aulestia','+57 3146061490','Cra. 74 #152b-70 Torre 3 Apto. 1704','Bogotá','Colombia','a.aulestia@exe.com.co'),
  ('41095adf-27a6-48f8-ada1-d8c7d3dd265a','Johnnatan Ruiz','+57 3112849616','Calle 82 #19A-29 Apt 401','Bogotá','Colombia','excellent.exeqtion@gmail.com');

-- Basic data
INSERT INTO basic_data(
  pet_id, pet_type, gender, weight, race, has_allergies,
  weight_condition, size, lives_with_others, main_food,
  has_vaccine, last_vaccine_name, last_vaccine_date,
  is_castrated, castration_date, has_anti_flea, anti_flea_date,
  uses_medicine, special_condition
) VALUES
  (
    'A001','Gato','Macho','5.5 Kg','Mestizo',false,
    'Normal','Mediano',false,'Taste the Wild',
    true,'Parvigen','2024-07-25',
    true,'2023-12-02',true,'2023-12-15',
    false,false
  ),
  (
    'A002','Perro','Macho','7 Kg','Criollo',false,
    'Normal','Mediano',true,'Pro Plan',
    false,NULL,NULL,
    true,'2023-06-30',false,NULL,
    false,false
  ),
  (
    'A003','Perro','Macho','9 Kg','Criollo',true,
    'Normal','Mediano',true,'Vet Life',
    false,NULL,NULL,
    true,'2019-05-03',false,NULL,
    false,true
  );

-- Vacunas
INSERT INTO vaccines(pet_id, name, description, date, batch, brand) VALUES
  ('A001','Rabia','Vacuna contra la rabia','2025-03-15','RAB12345','Nobivac'),
  ('A001','Parvovirus','Prevención de parvovirus','2025-02-10','PARV67890','Canigen'),
  ('A002','Parvovirus','Prevención de parvovirus','2025-02-10','PARV67890','Canigen');

-- Cirugías
INSERT INTO surgeries(pet_id, name, date, description) VALUES
  ('A001','Castración','2024-11-20','Castración preventiva'),
  ('A001','Extracción dental','2024-12-05','Tooth extraction'),
  ('A002','Castración','2023-06-30','Castración preventiva'),
  ('A003','Castración','2019-05-03','Castración preventiva');

-- Medicinas
INSERT INTO medicines(pet_id, name, dosage, frequency) VALUES
  ('A001','Antibiótico X','250mg','Cada 12 horas'),
  ('A001','Vitamina C','100mg','Diaria');

-- Condiciones especiales
INSERT INTO conditions(pet_id, condition, severity) VALUES
  ('A001','Esterilidad aórtica','Moderada'),
  ('A001','Alergia alimentaria','Leve'),
  ('A003','Insuficiencia renal','Leve');

-- Exámenes de laboratorio
INSERT INTO lab_tests(pet_id, name, type, date, result) VALUES
  ('A001','Hemograma completo','Blood','2025-01-10','Normal'),
  ('A001','Ultrasonido abdominal','Ultrasound','2024-12-22','Sin hallazgos');
 
----- Archivo: veterinarians.sql ----- 
-- migrations/20250529_create_veterinarians.sql

create table if not exists veterinarians (
  vet_id uuid primary key,
  first_name text not null,
  first_last_name text not null,
  second_last_name text not null,
  identification text not null,
  email text not null,
  registration text not null,
  clinic_name text not null,
  city text not null,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- (Opcional) Trigger para actualizar updated_at en cada modificación
create or replace function set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_veterinarians_updated_at on veterinarians;
create trigger trg_veterinarians_updated_at
  before update on veterinarians
  for each row execute function set_updated_at();
 
----- Archivo: veterinary_access.sql ----- 
-- Crear entidad para registrar accesos de veterinarios
create table if not exists veterinary_accesses (
  id uuid primary key default gen_random_uuid(),
  pet_id varchar(4) not null references pets(id) on delete cascade,
  pet_code_id uuid not null,
  vet_first_name text not null,
  vet_first_last_name text not null,
  vet_second_last_name text not null,
  identification text not null,
  professional_registration text not null,
  clinic_name text not null,
  city text not null,
  created_at timestamp with time zone default now()
);

-- Índice para optimizar búsquedas por código
create index if not exists idx_vet_accesses_code on veterinary_accesses(pet_code_id); 
----- Archivo: geist.ts ----- 
import { Geist, Geist_Mono } from "next/font/google";

export const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
export const geistMono = Geist_Mono({ variable: "--font-geist-mono", subsets: ["latin"] }); 
----- Archivo: tooltip.ts ----- 
// app/css/tooltip.tsx
export const tooltipStyles =
  `
        .tooltip-container {
          position: relative;
          display: inline-block;
        }
        .tooltip-container .tooltip-text {
          visibility: hidden;
          width: max-content;
          background-color: var(--primary-inverse);
          color:var(--pico-primary);
          border: 1px solid var(--pico-primary);
          text-align: center;
          padding: 4px 8px;
          border-radius: 4px;
          position: absolute;
          font-size: 0.75rem;
          white-space: nowrap;
          z-index: 1600;
          font-weight: bold;
          opacity: 0;
        }
        .tooltip-left {
          top: 18%;
          right: 100%;
          margin-right: 0.5rem;
          transition: opacity 0.2s !important;
        }
        .tooltip-right {
          left: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-left: 0.5rem;
        }
        .tooltip-container:hover .tooltip-text {
          visibility: visible;
          opacity: 1;
        }
      `; 
----- Archivo: veterinary.ts ----- 
// app/css/veterinary.tsx
export const veterinaryStyles =
`
        .overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: var(--primary-darkertransparent);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2000;
        }
        .modal {
          background: var(--primary-inverse);
          border-radius: 1rem;
          padding: 2rem;
          width: 90%;
          max-width: 400px;
          position: relative;
          box-shadow: 0 10px 25px var(--primary-lighttransparent);
        }
        .close-btn {
          position: absolute;
          top: 0.5rem;
          right: 0.5rem;
          background: none;
          border: none;
          font-size: 1.25rem;
          color: var(--primary-darkgray);
          cursor: pointer;
        }
        .label {
          font-size: 1.1rem;
          margin-bottom: 0.5rem;
          color: var(--primary-darkgray);
        }
        .input-code {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          border: 1px solid var(--primary-lightgray);
          border-radius: 0.25rem;
          text-transform: uppercase;
          margin-bottom: 1rem;
          transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-code:focus {
          outline: none;
          border-color: var(--pico-primary);
          box-shadow: 0 0 0 3px var(--primary-darkblue);
        }
        .error {
          color: var(--primary-red);
          font-size: 0.875rem;
          margin-bottom: 1rem;
        }
        .submit-btn {
          width: 100%;
          padding: 0.75rem;
          font-size: 1rem;
          background-color: var(--pico-primary);
          color: var(--primary-inverse);
          border: none;
          border-radius: 0.25rem;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        .submit-btn:disabled {
          background-color: var(--primary-lightgray);
          cursor: not-allowed;
        }
        .submit-btn:not(:disabled):hover {
          background-color: var(--pico-primary);
        }
      `; 
----- Archivo: index.ts ----- 
export interface PetType {
    id: string;
    name: string;
    image?: string | null;
    birth_date?: Date | null; 
    owner_id: string;
}
export interface PetCodeType {
    id: string;
    pet_id: string;
    code: string;
    used: boolean;
    expires_at: string;
}
export interface OwnerDataType {
    owner_id: string;
    name: string;
    last_name: string;
    phone: string;
    address: string;
    latitude?: number | null;
    longitude?: number | null;
    city: string;
    country: string;
    email: string;
}
export interface BasicDataType {
    pet_id: string;
    pet_type: string;
    gender: string;
    weight: string;
    race: string;
    coat_type: string;
    color: string;
    has_allergies: boolean;
    weight_condition: string;
    size: string;
    lives_with_others: boolean;
    main_food: string;
    has_vaccine: boolean;
    last_vaccine_name?: string;
    last_vaccine_date?: Date;
    is_sterilized: boolean;
    sterilization_date?: Date;
    has_anti_flea: boolean;
    anti_flea_date?: Date;
    uses_medicine: boolean;
    special_condition: boolean;
}
export interface InitialBasicDataType {
    petType: string,
    food: string,
    race: string,
    otherPetType: string,
    otherFood: string,
    otherRace: string
}
export interface VaccineDataType {
    id: string;
    pet_id: string;
    name: string;
    description?: string;
    date?: Date;
    batch: string;
    brand: string;
}
export interface SurgeryDataType {
    id: string;
    pet_id: string;
    name: string;
    date?: Date;
    description?: string;
}
export interface MedicineDataType {
    id: string;
    pet_id: string;
    name: string;
    dosage: string;
    frequency: string;
}
export interface ConditionDataType {
    id: string;
    pet_id: string;
    condition: string;
    severity: string;
}
export interface LabTestDataType {
    id: string;
    pet_id: string;
    name: string;
    type: string;
    date?: Date;
    result?: string;
}
export interface VeterinaryAccessType {
    id: string;
    pet_id: string;
    pet_code_id: string;
    vet_first_name: string;
    vet_first_last_name: string;
    vet_second_last_name: string;
    identification: string;
    professional_registration: string;
    clinic_name: string;
    city: string;
}

export interface VeterinarianType {
    vet_id: string;
    first_name: string;
    first_last_name: string;
    second_last_name: string;
    identification: string;
    email: string;
    registration: string;
    clinic_name: string;
    city: string;
}

export interface FeatureType {
    text: string;
    badge?: string;
}

export interface PlanType {
    id: number;
    slug: string;
}

export interface PlanVersionType {
    id: number;
    plan_id: number;
    slug: string;
    version: number;
    title: string;
    description: string;
    price_month: number;
    price_year: number;
    discount_month: number;
    discount_year: number;
    features: FeatureType[];
    effective_from: string;
    effective_to: string | null;
    plans: PlanType;
}
export interface SubscriptionType {
    id: number;
    user_id: string;
    plan_version_id: number;
    cycle: 'monthly' | 'annual';
    status: 'pending' | 'active' | 'canceled' | 'expired';
    external_id: string | null;
    price_at_purchase: number;
    discount_applied: number;
    started_at: string;
    expires_at: string | null;
    updated_at: string;
    plans_versions: PlanVersionType;
}

export interface CreateSubscriptionType {
    ownerId: string;
    planVersionId: number;
    cycle: 'monthly' | 'annual';
    priceAtPurchase: number;
    discountApplied: number;
}

export interface ProfessionalData {
    foto: string;
    nombres: string;
    apellidos: string;
    tituloObtenido: string;
    universidad: string;
    numeroMatricula: string;
    actaGrado: string;
    estado: 'Habilitado' | 'Desconocido'; // Usamos tipos literales para mayor precisión
    matriculaBuscada: string;
}

export enum PetStep {
    Name = 0,
    BasicData = 1,
    Vaccines = 2,
    Medicines = 3,
    LabTests = 4,
    Conditions = 5,
    Surgeries = 6
}

export interface ConsultationProcedureType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    procedure_name: string;
    description?: string | null;
    created_at: string; // timestamptz
}

export interface ConsultationMedicationType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    medication_name: string;
    dosage: string;
    frequency: string;
    duration_days?: number | null;
    notes?: string | null;
    created_at: string; // timestamptz
}

export interface ConsultationFileType {
    id: string; // uuid
    consultation_id: string; // uuid, FK to consultations
    file_name: string;
    file_path: string; // Path en Supabase Storage
    file_type?: string | null; // MIME type
    file_size_bytes?: number | null;
    uploaded_by_user_id?: string | null; // uuid, FK to auth.users (quien subió el archivo)
    created_at: string; // timestamptz
}

export interface ConsultationType {
    id: string; // uuid, PK
    pet_id: string; // uuid, FK to pets
    veterinarian_id?: string | null; // uuid, FK to auth.users (si es un vet con cuenta)
    veterinary_access_id?: string | null; // uuid, FK to veterinary_accesses (si se usó código)

    consultation_date: string; // date
    consultation_time?: string | null; // time
    hc_number?: string | null; // Número de historia clínica si aplica
    institution_name?: string | null; // Nombre de la clínica/institución

    // Anamnesis (basado en el formato)
    reason_for_consultation: string;
    current_diet?: string | null;
    previous_illnesses?: string | null;
    previous_surgeries?: string | null;
    vaccination_history?: string | null; // Podría ser un resumen, los detalles están en su propia sección
    last_deworming_product?: string | null;
    recent_treatments?: string | null;
    recent_travels?: string | null;
    animal_behavior_owner_description?: string | null;
    lives_with_other_animals_details?: string | null; // ej: "Sí, un perro y un gato"
    sterilized_status?: 'yes' | 'no' | 'unknown' | null; // o booleano si es más simple
    birth_count?: number | null;

    // Examen Físico General
    body_condition_score?: number | null; // Escala 1-5 o 1-9
    temperature_celsius?: number | null;
    heart_rate_bpm?: number | null; // FC
    respiratory_rate_rpm?: number | null; // FR
    capillary_refill_time_sec?: number | null; // TRPC / TLLC
    pulse_description?: string | null; // Descripción del pulso (fuerte, débil, rítmico)
    mucous_membranes_description?: string | null;
    hydration_percentage_description?: string | null; // Descripción o % estimado
    sense_organs_description?: string | null;

    // Examen Físico por Sistemas
    skin_and_coat_description?: string | null;
    lymph_nodes_description?: string | null;
    digestive_system_findings?: string | null;
    respiratory_system_findings?: string | null;
    endocrine_system_findings?: string | null;
    musculoskeletal_system_findings?: string | null;
    nervous_system_findings?: string | null;
    urinary_system_findings?: string | null;
    reproductive_system_findings?: string | null;
    rectal_palpation_findings?: string | null;
    other_physical_findings?: string | null;

    // Abordaje Diagnóstico
    problem_list?: string | null; // Podría ser un array de strings JSON.stringify
    master_problem_list?: string | null;
    differential_diagnoses?: string | null; // Podría ser un array de strings JSON.stringify

    // Exámenes Complementarios (Resumen textual, los archivos van en otra tabla)
    complementary_exams_summary?: string | null;

    // Diagnóstico y Plan
    presumptive_diagnosis: string;
    definitive_diagnosis?: string | null;
    therapeutic_plan: string;
    prognosis?: string | null;
    evolution_notes?: string | null; // Evolución durante la consulta o plan de seguimiento inmediato
    general_observations?: string | null; // Observaciones generales, recomendaciones de egreso, etc.
    signature_confirmation?: string | null; // Campo para que el vet confirme digitalmente (texto)


    // Relaciones (pobladas al hacer fetch si se usa SELECT anidado)
    procedures?: ConsultationProcedureType[];
    medications?: ConsultationMedicationType[];
    files?: ConsultationFileType[];

    created_at: string; // timestamptz
    updated_at: string; // timestamptz
}

// Payload para crear una consulta, puede ser un subconjunto o incluir arrays para sub-registros
export type CreateConsultationPayload = Omit<ConsultationType, 'id' | 'created_at' | 'updated_at' | 'procedures' | 'medications' | 'files'> & {
    procedures?: Array<Omit<ConsultationProcedureType, 'id' | 'consultation_id' | 'created_at'>>;
    medications?: Array<Omit<ConsultationMedicationType, 'id' | 'consultation_id' | 'created_at'>>;
    // Los archivos se manejarán con un endpoint separado después de crear la consulta,
    // o podrías tener un array de `File` objects aquí si tu API lo maneja en un solo paso.
}; 
----- Archivo: index.ts ----- 
import { StorageContextType } from "@/hooks/useAppStorage";
import { AuthError, AuthSession } from "@/lib/auth";
import { ReadonlyRequestCookies } from "next/dist/server/web/spec-extension/adapters/request-cookies";
import { NextResponse } from "next/server";
import { Dispatch, SetStateAction } from "react";
import { ZodObject } from "zod";

export interface AppContextType {
  session: AppSession | null;
  logout: () => object;
  storage: StorageContextType;
  showEditPetModal: boolean;
}

export interface AppSession {
  db: AuthSession | null;
}

export interface FormType {
  id: string,
  fields: FieldType[]
}

export interface FieldType {
  label: string;
  show: boolean;
  value?: string;
}

export interface MenuType {
  label: string;
  icon: React.JSX.Element,
  url: string;
  showModal?: Dispatch<SetStateAction<boolean>>,
  show: boolean;
}

export interface StepsStateType {
  step: number;
  state: StepStateEnum;
  url?: string;
  error?: string | null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  schema: ZodObject<any>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  repository?: FormRepository<any>
}

export enum StepStateEnum {
  NotInitialize = 0,
  Initialize = 1,
  Saved = 2,
  Modified = 3,
  Skipped = 4,
  Error = 5,
}

export type StepConfig<T> = {
  entityName: string;
  storedList: T[];
  setStoredList: (list: T[] | null) => void;
  emptyFactory: (petId: string) => T;
  fieldsConfig: FieldConfig<T>[];
};

export interface FieldConfig<T> {
  label: string;
  name: keyof T;
  type: "text" | "date";
  mandatory?: boolean;
  className?: string;
}

export interface FormRepository<T> {
  createAll: (list: T[], options: RepositoryOptions) => Promise<{
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    data: any[] | null;
    error: AuthError | null;
  }>;
  findByParentId: (parent_id: string, options: RepositoryOptions) => Promise<T[] | null>;
  delete: (id: string, options: RepositoryOptions) => Promise<boolean>
}

export interface RepositoryOptions {
  cookies?: ReadonlyRequestCookies
}

export interface ReposError {
  message: string;
  status: number;
}

export type RepositoryResponse<T> = | { data: T; error: null } | { data: null; error: ReposError };

export interface LogInType {
  email: string;
  password: string;
  role: 'owner' | 'veterinarian';
}
export interface SetSesionType {
  access_token: string;
  refresh_token: string;
}

export interface ApiParams {
  params: Record<string, string>;
};

export type ApiResponse = Promise<NextResponse<{ message: string; success: boolean }>>;

export type ValidationResult<T> =
  | { data: T; error?: undefined }
  | { data?: undefined; error: NextResponse };


/**
 * Excepción que lanzamos cuando falta un parámetro obligatorio en la query.
 */
export class QueryParamError extends Error { }

/**
 * Excepción que lanzamos cuando falta alguna configuración en los steps.
 */
export class StepStateError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema en el repositorio.
 */
export class RepositoryError extends Error { }

/**
 * Excepción que lanzamos cuando hay un problema consumiendo un api.
 */
export class ApiError extends Error { }
/**
 * Excepción que lanzamos cuando hay un problema con el cliente de autenticación.
 */
export class AuthExceptionError extends Error { } 
----- Archivo: cookies.ts ----- 
// src/utils/cookies.ts
import { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';

export function getAccessTokenFromCookie(cookies: ReadonlyRequestCookies) {
  const projectRef = process.env.NEXT_PUBLIC_SUPABASE_PROJECT_REF;
  const cookieName = `sb-${projectRef}-auth-token`;
  const cookieValue = cookies.get(cookieName)?.value;
  if (!cookieValue) return null;

  // Decodifica base64url a base64
  const base64 = cookieValue.replace("base64-", "").replace(/-/g, '+').replace(/_/g, '/')
    + '='.repeat((4 - cookieValue.length % 4) % 4);

  // Ahora decodifica a string y parsea JSON
  const jsonStr = Buffer.from(base64, 'base64').toString('utf-8');
  const json = JSON.parse(jsonStr);
  return json.access_token;
}

export function isVetAccessFromCookie(cookies: ReadonlyRequestCookies): boolean {
  const cookieName = 'lampo-vet-access';
  const cookieValue = cookies.get(cookieName)?.value;
  if (!cookieValue) return false;
  return true;
} 
----- Archivo: currency.ts ----- 

export function format(cents: number) {
    return new Intl.NumberFormat("es-CO", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2,
    }).format(cents / 100);
} 
----- Archivo: dates.ts ----- 
export function format(date: string | Date | undefined | null): string {
    if (date == undefined || date == null) {
        return '';
    }
    if (typeof (date) == typeof ("")) {
        return (date as string).split('T')[0];
    }
    return (date as Date).toISOString().split('T')[0];
}

export function calculateAge(birthDate: string | Date | undefined | null): string {
    if (!birthDate) {
        return "N/A";
    }

    const birth = new Date(birthDate);
    const today = new Date();

    let age = today.getFullYear() - birth.getFullYear();
    const monthDifference = today.getMonth() - birth.getMonth();

    if (monthDifference < 0 || (monthDifference === 0 && today.getDate() < birth.getDate())) {
        age--;
    }

    if (age < 0) return "N/A";
    if (age === 0) {
        const months = today.getMonth() - birth.getMonth() + (12 * (today.getFullYear() - birth.getFullYear()));
        return `${months} mes(es)`;
    }

    return `${age} año(s)`;
} 
----- Archivo: factories.ts ----- 
// src/utils/factories.ts
"use client";

import { v4 } from 'uuid';
import type {
  ConditionDataType,
  LabTestDataType,
  MedicineDataType,
  SurgeryDataType,
  VaccineDataType
} from '@/types/index';

export const emptyVaccine = (petId: string): Partial<VaccineDataType> => ({
    pet_id: petId,
    id: v4(),
    name: "",
    description: "",
    date: undefined,
    batch: "",
    brand: "",
});

export const emptyCondition = (petId: string): Partial<ConditionDataType> => ({
  id: v4(),
  pet_id: petId,
  condition: '',
  severity: '',
});

export const emptyLabTest = (petId: string): Partial<LabTestDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  type: '',
  date: undefined,
  result: '',
});

export const emptyMedicine = (petId: string): Partial<MedicineDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  dosage: '',
  frequency: '',
});

export const emptySurgery = (petId: string): Partial<SurgeryDataType> => ({
  id: v4(),
  pet_id: petId,
  name: '',
  date: undefined,
  description: '',
}); 
----- Archivo: index.ts ----- 
export * as Cookies from "@/utils/cookies";
export * as Currency from "@/utils/currency";
export * as Dates from "@/utils/dates";
export * as Factores from "@/utils/factories";
export * as Random from "@/utils/random";
export * as Steps from "@/utils/steps";
export * as Strings from "@/utils/strings";
export * as Validations from "@/utils/validations"; 
----- Archivo: random.ts ----- 
// src/utils/random.tsx
import { customAlphabet } from "nanoid";

// Define un alfabeto con dígitos y letras (mayúsculas + minúsculas)
const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

// Crea un generador de IDs de 6 caracteres
export const generateCode = customAlphabet(ALPHABET, 6);


/**
 * Genera un ID aleatorio que cumple el patrón: letra + 3 dígitos (e.g. A012, z999).
 */
function randomPetId(): string {
  const letter = LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));
  const number = Math.floor(Math.random() * 1000)
    .toString()
    .padStart(3, '0');
  return `${letter}${number}`;
}

/**
 * Genera un ID único para mascota, repitiendo hasta que no exista en la base de datos.
 */
export async function generateUniquePetId(): Promise<string> {
  let candidate: string;
  let exists: boolean;

  do {
    candidate = randomPetId();

    const res = await fetch(`/api/pets/exists?id=${candidate}`);
    const data = await res.json();
    exists = data.exists;
  } while (exists);

  return candidate;
} 
----- Archivo: steps.ts ----- 
// src/utils/steps.ts
import { StepsStateType, StepStateEnum } from '@/types/lib';
import { Dispatch } from 'react';

export function ChangeState(stepStates: StepsStateType[], setStepStates: Dispatch<React.SetStateAction<StepsStateType[]>>, stepNumber: number, stepState: StepStateEnum, stepError: string | null = null) {
    const step = stepStates.find(s => s.step == stepNumber);
    if (step) {
        step.state = stepState;
        step.error = stepError;
    }
    setStepStates(stepStates);
} 
----- Archivo: strings.ts ----- 
// src/utils/string.ts
import { ApiParams } from "@/types/lib";

export function titleCase(word: string) {
    if (!word) return word;
    return word[0].toUpperCase() + word.substr(1).toLowerCase();
}

/**
 * Convierte un objeto en un query string para URL.
 * Omite claves con valor undefined o null.
 *
 * @example
 * paramsToString({ a: 1, b: 'hola mundo', c: undefined }) 
 * // devuelve "?a=1&b=hola%20mundo"
 *
 * @param params Objeto cuyas claves/valores se desean serializar.
 * @returns Query string (incluye '?' si hay al menos un parámetro).
 */
export function fromParams(params: ApiParams): string {
  const entries = Object.entries(params)
    .filter(([, value]) => value !== undefined && value !== null)
    .map(([key, value]) => {
      // Si es array, repetimos key=valor por cada elemento
      if (Array.isArray(value)) {
        return value
          .map(v => `${encodeURIComponent(key)}=${encodeURIComponent(String(v))}`)
          .join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
    });

  if (entries.length === 0) {
    return '';
  }
  return `?${entries.join('&')}`;
} 
----- Archivo: validations.ts ----- 
// src/utils/validations.ts

import { FieldConfig } from "@/types/lib";

/**
 * Valida un array de entidades genericas contra su configuracion de campos.
 * Devuelve null si todo pasa, o un mensaje con los campos obligatorios faltantes.
 */
export function forFields<T>(
  items: Partial<T>[],
  entityName: string,
  fieldsConfig: FieldConfig<T>[]
): string | null {
  const missing: string[] = [];

  items.forEach((item, idx) => {
    fieldsConfig
      .filter(field => field.mandatory)
      .forEach(field => {
        if (!item[field.name]) {
          missing.push(`${field.label} en ${entityName} #${idx + 1}`);
        }
      });
  });

  if (missing.length > 0) {
    return `Faltan los campos obligatorios: ${missing.join(', ')}`;
  }
  return null;
}
 
